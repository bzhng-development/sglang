<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.distributed.utils API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.distributed.utils</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sglang.srt.distributed.utils.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>numerator, denominator)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(numerator, denominator):
    &#34;&#34;&#34;Ensure that numerator is divisible by the denominator and return
    the division value.&#34;&#34;&#34;
    ensure_divisibility(numerator, denominator)
    return numerator // denominator</code></pre>
</details>
<div class="desc"><p>Ensure that numerator is divisible by the denominator and return
the division value.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.ensure_divisibility"><code class="name flex">
<span>def <span class="ident">ensure_divisibility</span></span>(<span>numerator, denominator)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_divisibility(numerator, denominator):
    &#34;&#34;&#34;Ensure that numerator is divisible by the denominator.&#34;&#34;&#34;
    assert numerator % denominator == 0, &#34;{} is not divisible by {}&#34;.format(
        numerator, denominator
    )</code></pre>
</details>
<div class="desc"><p>Ensure that numerator is divisible by the denominator.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.get_pp_indices"><code class="name flex">
<span>def <span class="ident">get_pp_indices</span></span>(<span>num_hidden_layers: int, pp_rank: int, pp_size: int) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pp_indices(
    num_hidden_layers: int, pp_rank: int, pp_size: int
) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Try to evenly distribute layers across partitions.
    If the number of layers is not divisible by the number of partitions,
    the last partition will have the remaining layers.
    &#34;&#34;&#34;
    # partition_list_str can be set to None in sglang
    partition_list_str = os.getenv(&#34;SGLANG_PP_LAYER_PARTITION&#34;, None)
    if partition_list_str is not None:
        try:
            partitions = [int(layer) for layer in partition_list_str.split(&#34;,&#34;)]
        except ValueError as err:
            raise ValueError(
                &#34;Invalid partition string: {}&#34;.format(partition_list_str)
            ) from err
        if len(partitions) != pp_size:
            raise ValueError(f&#34;{len(partitions)=} does not match {pp_size=}.&#34;)
        if sum(partitions) != num_hidden_layers:
            raise ValueError(f&#34;{sum(partitions)=} does not match {num_hidden_layers=}.&#34;)
        start_layer = sum(partitions[:pp_rank])
        end_layer = start_layer + partitions[pp_rank]
    else:
        layers_per_partition = num_hidden_layers // pp_size
        start_layer = pp_rank * layers_per_partition
        end_layer = start_layer + layers_per_partition

        if pp_rank == pp_size - 1:
            end_layer = num_hidden_layers

    return (start_layer, end_layer)</code></pre>
</details>
<div class="desc"><p>Try to evenly distribute layers across partitions.
If the number of layers is not divisible by the number of partitions,
the last partition will have the remaining layers.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.split_tensor_along_last_dim"><code class="name flex">
<span>def <span class="ident">split_tensor_along_last_dim</span></span>(<span>tensor: torch.Tensor,<br>num_partitions: int,<br>contiguous_split_chunks: bool = False) ‑> Sequence[torch.Tensor]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_tensor_along_last_dim(
    tensor: torch.Tensor,
    num_partitions: int,
    contiguous_split_chunks: bool = False,
) -&gt; Sequence[torch.Tensor]:
    &#34;&#34;&#34;Split a tensor along its last dimension.

    Arguments:
        tensor: input tensor.
        num_partitions: number of partitions to split the tensor
        contiguous_split_chunks: If True, make each chunk contiguous
                                 in memory.

    Returns:
        A list of Tensors
    &#34;&#34;&#34;
    # Get the size and dimension.
    last_dim = tensor.dim() - 1
    last_dim_size = divide(tensor.size()[last_dim], num_partitions)
    # Split.
    tensor_list = torch.split(tensor, last_dim_size, dim=last_dim)
    # NOTE: torch.split does not create contiguous tensors by default.
    if contiguous_split_chunks:
        return tuple(chunk.contiguous() for chunk in tensor_list)

    return tensor_list</code></pre>
</details>
<div class="desc"><p>Split a tensor along its last dimension.</p>
<h2 id="arguments">Arguments</h2>
<p>tensor: input tensor.
num_partitions: number of partitions to split the tensor
contiguous_split_chunks: If True, make each chunk contiguous
in memory.</p>
<h2 id="returns">Returns</h2>
<p>A list of Tensors</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup"><code class="flex name class">
<span>class <span class="ident">StatelessProcessGroup</span></span>
<span>(</span><span>rank: int,<br>world_size: int,<br>store: torch.distributed.distributed_c10d.Store,<br>data_expiration_seconds: int = 3600,<br>send_dst_counter: Dict[int, int] = &lt;factory&gt;,<br>recv_src_counter: Dict[int, int] = &lt;factory&gt;,<br>broadcast_send_counter: int = 0,<br>broadcast_recv_src_counter: Dict[int, int] = &lt;factory&gt;,<br>entries: Deque[Tuple[str, float]] = &lt;factory&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class StatelessProcessGroup:
    &#34;&#34;&#34;A dataclass to hold a metadata store, and the rank, world_size of the
    group. Only use it to communicate metadata between processes.
    For data-plane communication, create NCCL-related objects.
    &#34;&#34;&#34;

    rank: int
    world_size: int
    store: torch._C._distributed_c10d.Store
    data_expiration_seconds: int = 3600  # 1 hour

    # dst rank -&gt; counter
    send_dst_counter: Dict[int, int] = dataclasses.field(default_factory=dict)
    # src rank -&gt; counter
    recv_src_counter: Dict[int, int] = dataclasses.field(default_factory=dict)
    broadcast_send_counter: int = 0
    broadcast_recv_src_counter: Dict[int, int] = dataclasses.field(default_factory=dict)

    # A deque to store the data entries, with key and timestamp.
    entries: Deque[Tuple[str, float]] = dataclasses.field(default_factory=deque)

    def __post_init__(self):
        assert self.rank &lt; self.world_size
        self.send_dst_counter = {i: 0 for i in range(self.world_size)}
        self.recv_src_counter = {i: 0 for i in range(self.world_size)}
        self.broadcast_recv_src_counter = {i: 0 for i in range(self.world_size)}

    def send_obj(self, obj: Any, dst: int):
        &#34;&#34;&#34;Send an object to a destination rank.&#34;&#34;&#34;
        self.expire_data()
        key = f&#34;send_to/{dst}/{self.send_dst_counter[dst]}&#34;
        self.store.set(key, pickle.dumps(obj))
        self.send_dst_counter[dst] += 1
        self.entries.append((key, time.perf_counter()))

    def expire_data(self):
        &#34;&#34;&#34;Expire data that is older than `data_expiration_seconds` seconds.&#34;&#34;&#34;
        while self.entries:
            # check the oldest entry
            key, timestamp = self.entries[0]
            if time.perf_counter() - timestamp &gt; self.data_expiration_seconds:
                self.store.delete_key(key)
                self.entries.popleft()
            else:
                break

    def recv_obj(self, src: int) -&gt; Any:
        &#34;&#34;&#34;Receive an object from a source rank.&#34;&#34;&#34;
        obj = pickle.loads(
            self.store.get(f&#34;send_to/{self.rank}/{self.recv_src_counter[src]}&#34;)
        )
        self.recv_src_counter[src] += 1
        return obj

    def broadcast_obj(self, obj: Optional[Any], src: int) -&gt; Any:
        &#34;&#34;&#34;Broadcast an object from a source rank to all other ranks.
        It does not clean up after all ranks have received the object.
        Use it for limited times, e.g., for initialization.
        &#34;&#34;&#34;
        if self.rank == src:
            self.expire_data()
            key = f&#34;broadcast_from/{src}/&#34; f&#34;{self.broadcast_send_counter}&#34;
            self.store.set(key, pickle.dumps(obj))
            self.broadcast_send_counter += 1
            self.entries.append((key, time.perf_counter()))
            return obj
        else:
            key = f&#34;broadcast_from/{src}/&#34; f&#34;{self.broadcast_recv_src_counter[src]}&#34;
            recv_obj = pickle.loads(self.store.get(key))
            self.broadcast_recv_src_counter[src] += 1
            return recv_obj

    def all_gather_obj(self, obj: Any) -&gt; list[Any]:
        &#34;&#34;&#34;All gather an object from all ranks.&#34;&#34;&#34;
        gathered_objs = []
        for i in range(self.world_size):
            if i == self.rank:
                gathered_objs.append(obj)
                self.broadcast_obj(obj, src=self.rank)
            else:
                recv_obj = self.broadcast_obj(None, src=i)
                gathered_objs.append(recv_obj)
        return gathered_objs

    def barrier(self):
        &#34;&#34;&#34;A barrier to synchronize all ranks.&#34;&#34;&#34;
        for i in range(self.world_size):
            if i == self.rank:
                self.broadcast_obj(None, src=self.rank)
            else:
                self.broadcast_obj(None, src=i)

    @staticmethod
    def create(
        host: str,
        port: int,
        rank: int,
        world_size: int,
        data_expiration_seconds: int = 3600,
    ) -&gt; &#34;StatelessProcessGroup&#34;:
        &#34;&#34;&#34;A replacement for `torch.distributed.init_process_group` that does not
        pollute the global state.

        If we have process A and process B called `torch.distributed.init_process_group`
        to form a group, and then we want to form another group with process A, B, C,
        D, it is not possible in PyTorch, because process A and process B have already
        formed a group, and process C and process D cannot join that group. This
        function is a workaround for this issue.

        `torch.distributed.init_process_group` is a global call, while this function
        is a stateless call. It will return a `StatelessProcessGroup` object that can be
        used for exchanging metadata. With this function, process A and process B
        can call `StatelessProcessGroup.create` to form a group, and then process A, B,
        C, and D can call `StatelessProcessGroup.create` to form another group.
        &#34;&#34;&#34;  # noqa
        store = TCPStore(
            host_name=host,
            port=port,
            world_size=world_size,
            is_master=(rank == 0),
        )

        return StatelessProcessGroup(
            rank=rank,
            world_size=world_size,
            store=store,
            data_expiration_seconds=data_expiration_seconds,
        )</code></pre>
</details>
<div class="desc"><p>A dataclass to hold a metadata store, and the rank, world_size of the
group. Only use it to communicate metadata between processes.
For data-plane communication, create NCCL-related objects.</p></div>
<h3>Static methods</h3>
<dl>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.create"><code class="name flex">
<span>def <span class="ident">create</span></span>(<span>host: str,<br>port: int,<br>rank: int,<br>world_size: int,<br>data_expiration_seconds: int = 3600) ‑> <a title="sglang.srt.distributed.utils.StatelessProcessGroup" href="#sglang.srt.distributed.utils.StatelessProcessGroup">StatelessProcessGroup</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create(
    host: str,
    port: int,
    rank: int,
    world_size: int,
    data_expiration_seconds: int = 3600,
) -&gt; &#34;StatelessProcessGroup&#34;:
    &#34;&#34;&#34;A replacement for `torch.distributed.init_process_group` that does not
    pollute the global state.

    If we have process A and process B called `torch.distributed.init_process_group`
    to form a group, and then we want to form another group with process A, B, C,
    D, it is not possible in PyTorch, because process A and process B have already
    formed a group, and process C and process D cannot join that group. This
    function is a workaround for this issue.

    `torch.distributed.init_process_group` is a global call, while this function
    is a stateless call. It will return a `StatelessProcessGroup` object that can be
    used for exchanging metadata. With this function, process A and process B
    can call `StatelessProcessGroup.create` to form a group, and then process A, B,
    C, and D can call `StatelessProcessGroup.create` to form another group.
    &#34;&#34;&#34;  # noqa
    store = TCPStore(
        host_name=host,
        port=port,
        world_size=world_size,
        is_master=(rank == 0),
    )

    return StatelessProcessGroup(
        rank=rank,
        world_size=world_size,
        store=store,
        data_expiration_seconds=data_expiration_seconds,
    )</code></pre>
</details>
<div class="desc"><p>A replacement for <code>torch.distributed.init_process_group</code> that does not
pollute the global state.</p>
<p>If we have process A and process B called <code>torch.distributed.init_process_group</code>
to form a group, and then we want to form another group with process A, B, C,
D, it is not possible in PyTorch, because process A and process B have already
formed a group, and process C and process D cannot join that group. This
function is a workaround for this issue.</p>
<p><code>torch.distributed.init_process_group</code> is a global call, while this function
is a stateless call. It will return a <code><a title="sglang.srt.distributed.utils.StatelessProcessGroup" href="#sglang.srt.distributed.utils.StatelessProcessGroup">StatelessProcessGroup</a></code> object that can be
used for exchanging metadata. With this function, process A and process B
can call <code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.create" href="#sglang.srt.distributed.utils.StatelessProcessGroup.create">StatelessProcessGroup.create()</a></code> to form a group, and then process A, B,
C, and D can call <code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.create" href="#sglang.srt.distributed.utils.StatelessProcessGroup.create">StatelessProcessGroup.create()</a></code> to form another group.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_recv_src_counter"><code class="name">var <span class="ident">broadcast_recv_src_counter</span> : Dict[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_send_counter"><code class="name">var <span class="ident">broadcast_send_counter</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.data_expiration_seconds"><code class="name">var <span class="ident">data_expiration_seconds</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.entries"><code class="name">var <span class="ident">entries</span> : Deque[Tuple[str, float]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.rank"><code class="name">var <span class="ident">rank</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.recv_src_counter"><code class="name">var <span class="ident">recv_src_counter</span> : Dict[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.send_dst_counter"><code class="name">var <span class="ident">send_dst_counter</span> : Dict[int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.store"><code class="name">var <span class="ident">store</span> : torch.distributed.distributed_c10d.Store</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.world_size"><code class="name">var <span class="ident">world_size</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.all_gather_obj"><code class="name flex">
<span>def <span class="ident">all_gather_obj</span></span>(<span>self, obj: Any) ‑> list[typing.Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_gather_obj(self, obj: Any) -&gt; list[Any]:
    &#34;&#34;&#34;All gather an object from all ranks.&#34;&#34;&#34;
    gathered_objs = []
    for i in range(self.world_size):
        if i == self.rank:
            gathered_objs.append(obj)
            self.broadcast_obj(obj, src=self.rank)
        else:
            recv_obj = self.broadcast_obj(None, src=i)
            gathered_objs.append(recv_obj)
    return gathered_objs</code></pre>
</details>
<div class="desc"><p>All gather an object from all ranks.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.barrier"><code class="name flex">
<span>def <span class="ident">barrier</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def barrier(self):
    &#34;&#34;&#34;A barrier to synchronize all ranks.&#34;&#34;&#34;
    for i in range(self.world_size):
        if i == self.rank:
            self.broadcast_obj(None, src=self.rank)
        else:
            self.broadcast_obj(None, src=i)</code></pre>
</details>
<div class="desc"><p>A barrier to synchronize all ranks.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_obj"><code class="name flex">
<span>def <span class="ident">broadcast_obj</span></span>(<span>self, obj: Any | None, src: int) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast_obj(self, obj: Optional[Any], src: int) -&gt; Any:
    &#34;&#34;&#34;Broadcast an object from a source rank to all other ranks.
    It does not clean up after all ranks have received the object.
    Use it for limited times, e.g., for initialization.
    &#34;&#34;&#34;
    if self.rank == src:
        self.expire_data()
        key = f&#34;broadcast_from/{src}/&#34; f&#34;{self.broadcast_send_counter}&#34;
        self.store.set(key, pickle.dumps(obj))
        self.broadcast_send_counter += 1
        self.entries.append((key, time.perf_counter()))
        return obj
    else:
        key = f&#34;broadcast_from/{src}/&#34; f&#34;{self.broadcast_recv_src_counter[src]}&#34;
        recv_obj = pickle.loads(self.store.get(key))
        self.broadcast_recv_src_counter[src] += 1
        return recv_obj</code></pre>
</details>
<div class="desc"><p>Broadcast an object from a source rank to all other ranks.
It does not clean up after all ranks have received the object.
Use it for limited times, e.g., for initialization.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.expire_data"><code class="name flex">
<span>def <span class="ident">expire_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expire_data(self):
    &#34;&#34;&#34;Expire data that is older than `data_expiration_seconds` seconds.&#34;&#34;&#34;
    while self.entries:
        # check the oldest entry
        key, timestamp = self.entries[0]
        if time.perf_counter() - timestamp &gt; self.data_expiration_seconds:
            self.store.delete_key(key)
            self.entries.popleft()
        else:
            break</code></pre>
</details>
<div class="desc"><p>Expire data that is older than <code>data_expiration_seconds</code> seconds.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.recv_obj"><code class="name flex">
<span>def <span class="ident">recv_obj</span></span>(<span>self, src: int) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_obj(self, src: int) -&gt; Any:
    &#34;&#34;&#34;Receive an object from a source rank.&#34;&#34;&#34;
    obj = pickle.loads(
        self.store.get(f&#34;send_to/{self.rank}/{self.recv_src_counter[src]}&#34;)
    )
    self.recv_src_counter[src] += 1
    return obj</code></pre>
</details>
<div class="desc"><p>Receive an object from a source rank.</p></div>
</dd>
<dt id="sglang.srt.distributed.utils.StatelessProcessGroup.send_obj"><code class="name flex">
<span>def <span class="ident">send_obj</span></span>(<span>self, obj: Any, dst: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_obj(self, obj: Any, dst: int):
    &#34;&#34;&#34;Send an object to a destination rank.&#34;&#34;&#34;
    self.expire_data()
    key = f&#34;send_to/{dst}/{self.send_dst_counter[dst]}&#34;
    self.store.set(key, pickle.dumps(obj))
    self.send_dst_counter[dst] += 1
    self.entries.append((key, time.perf_counter()))</code></pre>
</details>
<div class="desc"><p>Send an object to a destination rank.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.distributed" href="index.html">sglang.srt.distributed</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sglang.srt.distributed.utils.divide" href="#sglang.srt.distributed.utils.divide">divide</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.ensure_divisibility" href="#sglang.srt.distributed.utils.ensure_divisibility">ensure_divisibility</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.get_pp_indices" href="#sglang.srt.distributed.utils.get_pp_indices">get_pp_indices</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.split_tensor_along_last_dim" href="#sglang.srt.distributed.utils.split_tensor_along_last_dim">split_tensor_along_last_dim</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup" href="#sglang.srt.distributed.utils.StatelessProcessGroup">StatelessProcessGroup</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.all_gather_obj" href="#sglang.srt.distributed.utils.StatelessProcessGroup.all_gather_obj">all_gather_obj</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.barrier" href="#sglang.srt.distributed.utils.StatelessProcessGroup.barrier">barrier</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_obj" href="#sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_obj">broadcast_obj</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_recv_src_counter" href="#sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_recv_src_counter">broadcast_recv_src_counter</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_send_counter" href="#sglang.srt.distributed.utils.StatelessProcessGroup.broadcast_send_counter">broadcast_send_counter</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.create" href="#sglang.srt.distributed.utils.StatelessProcessGroup.create">create</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.data_expiration_seconds" href="#sglang.srt.distributed.utils.StatelessProcessGroup.data_expiration_seconds">data_expiration_seconds</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.entries" href="#sglang.srt.distributed.utils.StatelessProcessGroup.entries">entries</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.expire_data" href="#sglang.srt.distributed.utils.StatelessProcessGroup.expire_data">expire_data</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.rank" href="#sglang.srt.distributed.utils.StatelessProcessGroup.rank">rank</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.recv_obj" href="#sglang.srt.distributed.utils.StatelessProcessGroup.recv_obj">recv_obj</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.recv_src_counter" href="#sglang.srt.distributed.utils.StatelessProcessGroup.recv_src_counter">recv_src_counter</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.send_dst_counter" href="#sglang.srt.distributed.utils.StatelessProcessGroup.send_dst_counter">send_dst_counter</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.send_obj" href="#sglang.srt.distributed.utils.StatelessProcessGroup.send_obj">send_obj</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.store" href="#sglang.srt.distributed.utils.StatelessProcessGroup.store">store</a></code></li>
<li><code><a title="sglang.srt.distributed.utils.StatelessProcessGroup.world_size" href="#sglang.srt.distributed.utils.StatelessProcessGroup.world_size">world_size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
