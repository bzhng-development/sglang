<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.layers.linear API documentation</title>
<meta name="description" content="Adapted from https://github.com/vllm-project/vllm/blob/v0.6.4.post1/vllm/model_executor/layers/linear.py">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.layers.linear</code></h1>
</header>
<section id="section-intro">
<p>Adapted from <a href="https://github.com/vllm-project/vllm/blob/v0.6.4.post1/vllm/model_executor/layers/linear.py">https://github.com/vllm-project/vllm/blob/v0.6.4.post1/vllm/model_executor/layers/linear.py</a></p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sglang.srt.layers.linear.adjust_bitsandbytes_4bit_shard"><code class="name flex">
<span>def <span class="ident">adjust_bitsandbytes_4bit_shard</span></span>(<span>param: Parameter,<br>shard_offsets: Dict[str, Tuple[int, int]],<br>loaded_shard_id: str) ‑> Tuple[int, int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_bitsandbytes_4bit_shard(
    param: Parameter, shard_offsets: Dict[str, Tuple[int, int]], loaded_shard_id: str
) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;Adjust the quantization offsets and sizes for BitsAndBytes sharding.&#34;&#34;&#34;

    total, _ = shard_offsets[&#34;total&#34;]
    orig_offset, orig_size = shard_offsets[loaded_shard_id]

    quantized_total = param.data.shape[0]
    quantized_offset = orig_offset * quantized_total // total
    quantized_size = orig_size * quantized_total // total

    return quantized_size, quantized_offset</code></pre>
</details>
<div class="desc"><p>Adjust the quantization offsets and sizes for BitsAndBytes sharding.</p></div>
</dd>
<dt id="sglang.srt.layers.linear.adjust_marlin_shard"><code class="name flex">
<span>def <span class="ident">adjust_marlin_shard</span></span>(<span>param, shard_size, shard_offset)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_marlin_shard(param, shard_size, shard_offset):
    marlin_tile_size = getattr(param, &#34;marlin_tile_size&#34;, None)
    if marlin_tile_size is None:
        return shard_size, shard_offset

    return shard_size * marlin_tile_size, shard_offset * marlin_tile_size</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.layers.linear.adjust_scalar_to_fused_array"><code class="name flex">
<span>def <span class="ident">adjust_scalar_to_fused_array</span></span>(<span>param, loaded_weight, shard_id)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_scalar_to_fused_array(param, loaded_weight, shard_id):
    &#34;&#34;&#34;For fused modules (QKV and MLP) we have an array of length
    N that holds 1 scale for each &#34;logical&#34; matrix. So the param
    is an array of length N. The loaded_weight corresponds to
    one of the shards on disk. Here, we slice the param based on
    the shard_id for loading.
    &#34;&#34;&#34;
    qkv_idxs = {&#34;q&#34;: 0, &#34;k&#34;: 1, &#34;v&#34;: 2}

    if isinstance(shard_id, str):
        shard_id = qkv_idxs[shard_id]
    elif not isinstance(shard_id, int):
        raise ValueError(f&#34;Unknown Shard Id {shard_id}&#34;)

    # AutoFP8 scales do not have a shape
    # compressed-tensors scales do have a shape
    if len(loaded_weight.shape) != 0:
        assert loaded_weight.shape[0] == 1
        loaded_weight = loaded_weight[0]

    return param[shard_id], loaded_weight</code></pre>
</details>
<div class="desc"><p>For fused modules (QKV and MLP) we have an array of length
N that holds 1 scale for each "logical" matrix. So the param
is an array of length N. The loaded_weight corresponds to
one of the shards on disk. Here, we slice the param based on
the shard_id for loading.</p></div>
</dd>
<dt id="sglang.srt.layers.linear.adjust_shard_offsets"><code class="name flex">
<span>def <span class="ident">adjust_shard_offsets</span></span>(<span>shard_offsets, loaded_weight, dim)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_shard_offsets(shard_offsets, loaded_weight, dim):
    actual_weight_size = loaded_weight.size(dim)
    target_weight_size = shard_offsets[-1][-1] + shard_offsets[-1][-2]
    if actual_weight_size != target_weight_size:
        new_shard_offsets = []
        new_offset = 0
        for shard_id, shard_offset, shard_size in shard_offsets:
            actual_shard_size = actual_weight_size * shard_size // target_weight_size
            new_shard_offsets.append((shard_id, new_offset, actual_shard_size))
            new_offset += actual_shard_size
        return new_shard_offsets
    return shard_offsets</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.layers.linear.ColumnParallelLinear"><code class="flex name class">
<span>class <span class="ident">ColumnParallelLinear</span></span>
<span>(</span><span>input_size: int,<br>output_size: int,<br>bias: bool = True,<br>gather_output: bool = False,<br>skip_bias_add: bool = False,<br>params_dtype: Optional[torch.dtype] = None,<br>quant_config: Optional[QuantizationConfig] = None,<br>output_sizes: Optional[List[int]] = None,<br>prefix: str = '',<br>tp_rank: Optional[int] = None,<br>tp_size: Optional[int] = None,<br>use_presharded_weights: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ColumnParallelLinear(LinearBase):
    &#34;&#34;&#34;Linear layer with column parallelism.

    The linear layer is defined as Y = XA + b. A is parallelized along
    its second dimension as A = [A_1, ..., A_p].

    Args:
        input_size: first dimension of matrix A.
        output_size: second dimension of matrix A.
        bias: If true, add bias.
        gather_output: If true, call all-gather on output and make Y available
                       to all GPUs, otherwise, every GPU will have its output
                       which is Y_i = XA_i
        skip_bias_add: This was added to enable performance optimizations where
                       bias can be fused with other element-wise operations. we
                       skip adding bias but instead return it.
        params_dtype: Data type for the parameters.
        quant_config: Quantization configure.
        output_sizes: list of output sizes packed into one output, like for QKV
                       the list would be size 3.
        prefix: The name of the layer in the state dict, including all parents
                        (e.g. model.layers.0.qkv_proj)
    &#34;&#34;&#34;

    def __init__(
        self,
        input_size: int,
        output_size: int,
        bias: bool = True,
        gather_output: bool = False,
        skip_bias_add: bool = False,
        params_dtype: Optional[torch.dtype] = None,
        quant_config: Optional[QuantizationConfig] = None,
        output_sizes: Optional[List[int]] = None,
        prefix: str = &#34;&#34;,
        tp_rank: Optional[int] = None,
        tp_size: Optional[int] = None,
        use_presharded_weights: bool = False,
    ):
        super().__init__(
            input_size, output_size, skip_bias_add, params_dtype, quant_config, prefix
        )

        self.gather_output = gather_output
        self.use_presharded_weights = use_presharded_weights

        # Divide the weight matrix along the last dimension.
        if tp_rank is None:
            tp_rank = get_tensor_model_parallel_rank()
        if tp_size is None:
            tp_size = get_tensor_model_parallel_world_size()
        self.tp_rank, self.tp_size = tp_rank, tp_size
        assert self.quant_method is not None
        self.output_size_per_partition = divide(self.output_size, tp_size)
        self.output_partition_sizes = [self.output_size_per_partition]
        # If QKV or MergedColumn, use output size of each partition.
        if hasattr(self, &#34;output_sizes&#34;):
            self.output_partition_sizes = [
                divide(output_size, tp_size) for output_size in self.output_sizes
            ]

        if output_sizes is None:
            output_sizes = [output_size]

        self.quant_method.create_weights(
            layer=self,
            input_size_per_partition=self.input_size,
            output_partition_sizes=self.output_partition_sizes,
            input_size=self.input_size,
            output_size=self.output_size,
            params_dtype=self.params_dtype,
            weight_loader=(
                self.weight_loader_v2
                if self.quant_method.__class__.__name__ in WEIGHT_LOADER_V2_SUPPORTED
                else self.weight_loader
            ),
        )
        if bias:
            self.bias = Parameter(
                torch.empty(self.output_size_per_partition, dtype=params_dtype)
            )
            set_weight_attrs(
                self.bias,
                {
                    &#34;output_dim&#34;: 0,
                    &#34;weight_loader&#34;: self.weight_loader,
                },
            )
        else:
            self.register_parameter(&#34;bias&#34;, None)

    def weight_loader(self, param: Parameter, loaded_weight: torch.Tensor):
        output_dim = getattr(param, &#34;output_dim&#34;, None)

        # Special case for GGUF
        is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
        is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
        if is_gguf_weight_type:
            param.weight_type = loaded_weight.item()

        # Materialize GGUF UninitializedParameter
        if is_gguf_weight and isinstance(param, UninitializedParameter):
            param.materialize(loaded_weight.shape, dtype=loaded_weight.dtype)

        use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)

        param_data = param.data
        # bitsandbytes loads the weights of the specific portion
        # no need to narrow here
        if output_dim is not None and not use_bitsandbytes_4bit:
            shard_size = param_data.shape[output_dim]
            start_idx = self.tp_rank * shard_size

            if _is_cpu:
                from sglang.srt.model_loader.weight_utils import (
                    narrow_padded_param_and_loaded_weight,
                )

                param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                    param_data,
                    loaded_weight,
                    0,  # param_data_start
                    start_idx,
                    output_dim,
                    shard_size,
                    not self.use_presharded_weights,
                )
            else:
                if not self.use_presharded_weights:
                    loaded_weight = loaded_weight.narrow(
                        output_dim, start_idx, shard_size
                    )

        # Special case for loading scales off disk, which often do not
        # have a shape (such as in the case of AutoFP8).
        if len(loaded_weight.shape) == 0:
            loaded_weight = loaded_weight.reshape(1)

        assert param_data.shape == loaded_weight.shape
        param_data.copy_(loaded_weight)

    def weight_loader_v2(self, param: Parameter, loaded_weight: torch.Tensor):
        # Special case for loading scales off disk, which often do not
        # have a shape (such as in the case of AutoFP8).
        if len(loaded_weight.shape) == 0:
            assert loaded_weight.numel() == 1
            loaded_weight = loaded_weight.reshape(1)

        if isinstance(param, _ColumnvLLMParameter):
            param.load_column_parallel_weight(
                loaded_weight,
                tp_rank=self.tp_rank,
                use_presharded_weights=self.use_presharded_weights,
            )
        else:
            # FIXME: This branch is needed to load deepseek v3 awq.
            # However, we should fix this and avoid the branching here.
            param.load_column_parallel_weight(loaded_weight)

    def forward(self, input_):
        bias = self.bias if not self.skip_bias_add else None

        # Matrix multiply.
        assert self.quant_method is not None
        output_parallel = self.quant_method.apply(self, input_, bias)
        if self.gather_output:
            # All-gather across the partitions.
            output = tensor_model_parallel_all_gather(output_parallel)
        else:
            output = output_parallel
        output_bias = self.bias if self.skip_bias_add else None
        return output, output_bias

    def extra_repr(self) -&gt; str:
        s = f&#34;in_features={self.input_size}&#34;
        s += f&#34;, output_features={self.output_size_per_partition}&#34;
        s += f&#34;, bias={self.bias is not None}&#34;
        s += f&#34;, tp_size={self.tp_size}&#34;
        s += f&#34;, gather_output={self.gather_output}&#34;
        return s</code></pre>
</details>
<div class="desc"><p>Linear layer with column parallelism.</p>
<p>The linear layer is defined as Y = XA + b. A is parallelized along
its second dimension as A = [A_1, &hellip;, A_p].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_size</code></strong></dt>
<dd>first dimension of matrix A.</dd>
<dt><strong><code>output_size</code></strong></dt>
<dd>second dimension of matrix A.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>If true, add bias.</dd>
<dt><strong><code>gather_output</code></strong></dt>
<dd>If true, call all-gather on output and make Y available
to all GPUs, otherwise, every GPU will have its output
which is Y_i = XA_i</dd>
<dt><strong><code>skip_bias_add</code></strong></dt>
<dd>This was added to enable performance optimizations where
bias can be fused with other element-wise operations. we
skip adding bias but instead return it.</dd>
<dt><strong><code>params_dtype</code></strong></dt>
<dd>Data type for the parameters.</dd>
<dt><strong><code>quant_config</code></strong></dt>
<dd>Quantization configure.</dd>
<dt><strong><code>output_sizes</code></strong></dt>
<dd>list of output sizes packed into one output, like for QKV
the list would be size 3.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The name of the layer in the state dict, including all parents
(e.g. model.layers.0.qkv_proj)</dd>
</dl>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.MergedColumnParallelLinear" href="#sglang.srt.layers.linear.MergedColumnParallelLinear">MergedColumnParallelLinear</a></li>
<li><a title="sglang.srt.layers.linear.QKVParallelLinear" href="#sglang.srt.layers.linear.QKVParallelLinear">QKVParallelLinear</a></li>
<li><a title="sglang.srt.models.transformers.HFColumnParallelLinear" href="../models/transformers.html#sglang.srt.models.transformers.HFColumnParallelLinear">HFColumnParallelLinear</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.layers.linear.ColumnParallelLinear.extra_repr"><code class="name flex">
<span>def <span class="ident">extra_repr</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extra_repr(self) -&gt; str:
    s = f&#34;in_features={self.input_size}&#34;
    s += f&#34;, output_features={self.output_size_per_partition}&#34;
    s += f&#34;, bias={self.bias is not None}&#34;
    s += f&#34;, tp_size={self.tp_size}&#34;
    s += f&#34;, gather_output={self.gather_output}&#34;
    return s</code></pre>
</details>
<div class="desc"><p>Return the extra representation of the module.</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p></div>
</dd>
<dt id="sglang.srt.layers.linear.ColumnParallelLinear.weight_loader"><code class="name flex">
<span>def <span class="ident">weight_loader</span></span>(<span>self, param: Parameter, loaded_weight: torch.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader(self, param: Parameter, loaded_weight: torch.Tensor):
    output_dim = getattr(param, &#34;output_dim&#34;, None)

    # Special case for GGUF
    is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
    is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
    if is_gguf_weight_type:
        param.weight_type = loaded_weight.item()

    # Materialize GGUF UninitializedParameter
    if is_gguf_weight and isinstance(param, UninitializedParameter):
        param.materialize(loaded_weight.shape, dtype=loaded_weight.dtype)

    use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)

    param_data = param.data
    # bitsandbytes loads the weights of the specific portion
    # no need to narrow here
    if output_dim is not None and not use_bitsandbytes_4bit:
        shard_size = param_data.shape[output_dim]
        start_idx = self.tp_rank * shard_size

        if _is_cpu:
            from sglang.srt.model_loader.weight_utils import (
                narrow_padded_param_and_loaded_weight,
            )

            param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                param_data,
                loaded_weight,
                0,  # param_data_start
                start_idx,
                output_dim,
                shard_size,
                not self.use_presharded_weights,
            )
        else:
            if not self.use_presharded_weights:
                loaded_weight = loaded_weight.narrow(
                    output_dim, start_idx, shard_size
                )

    # Special case for loading scales off disk, which often do not
    # have a shape (such as in the case of AutoFP8).
    if len(loaded_weight.shape) == 0:
        loaded_weight = loaded_weight.reshape(1)

    assert param_data.shape == loaded_weight.shape
    param_data.copy_(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.layers.linear.ColumnParallelLinear.weight_loader_v2"><code class="name flex">
<span>def <span class="ident">weight_loader_v2</span></span>(<span>self, param: Parameter, loaded_weight: torch.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader_v2(self, param: Parameter, loaded_weight: torch.Tensor):
    # Special case for loading scales off disk, which often do not
    # have a shape (such as in the case of AutoFP8).
    if len(loaded_weight.shape) == 0:
        assert loaded_weight.numel() == 1
        loaded_weight = loaded_weight.reshape(1)

    if isinstance(param, _ColumnvLLMParameter):
        param.load_column_parallel_weight(
            loaded_weight,
            tp_rank=self.tp_rank,
            use_presharded_weights=self.use_presharded_weights,
        )
    else:
        # FIXME: This branch is needed to load deepseek v3 awq.
        # However, we should fix this and avoid the branching here.
        param.load_column_parallel_weight(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.layers.linear.LinearBase.forward" href="#sglang.srt.layers.linear.LinearBase.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sglang.srt.layers.linear.LinearBase"><code class="flex name class">
<span>class <span class="ident">LinearBase</span></span>
<span>(</span><span>input_size: int,<br>output_size: int,<br>skip_bias_add: bool = False,<br>params_dtype: Optional[torch.dtype] = None,<br>quant_config: Optional[QuantizationConfig] = None,<br>prefix: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinearBase(torch.nn.Module):
    &#34;&#34;&#34;Base linear layer.

    Args:
        input_size: input dimension of the linear layer.
        output_size: output dimension of the linear layer.
        bias: If true, add bias.
        skip_bias_add: If true, skip adding bias but instead return it.
        params_dtype: Data type for the parameters.
        quant_config: Quantization configure.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_size: int,
        output_size: int,
        skip_bias_add: bool = False,
        params_dtype: Optional[torch.dtype] = None,
        quant_config: Optional[QuantizationConfig] = None,
        prefix: str = &#34;&#34;,
    ):
        super().__init__()

        # Keep input parameters
        self.input_size = input_size
        self.output_size = output_size
        self.skip_bias_add = skip_bias_add
        if params_dtype is None:
            params_dtype = torch.get_default_dtype()
        self.params_dtype = params_dtype
        if quant_config is None:
            self.quant_method: Optional[QuantizeMethodBase] = UnquantizedLinearMethod()
        else:
            self.quant_method = quant_config.get_quant_method(self, prefix=prefix)

    def forward(self, x: torch.Tensor) -&gt; torch.Tensor:
        raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Base linear layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_size</code></strong></dt>
<dd>input dimension of the linear layer.</dd>
<dt><strong><code>output_size</code></strong></dt>
<dd>output dimension of the linear layer.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>If true, add bias.</dd>
<dt><strong><code>skip_bias_add</code></strong></dt>
<dd>If true, skip adding bias but instead return it.</dd>
<dt><strong><code>params_dtype</code></strong></dt>
<dd>Data type for the parameters.</dd>
<dt><strong><code>quant_config</code></strong></dt>
<dd>Quantization configure.</dd>
</dl>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.ColumnParallelLinear" href="#sglang.srt.layers.linear.ColumnParallelLinear">ColumnParallelLinear</a></li>
<li><a title="sglang.srt.layers.linear.ReplicatedLinear" href="#sglang.srt.layers.linear.ReplicatedLinear">ReplicatedLinear</a></li>
<li><a title="sglang.srt.layers.linear.RowParallelLinear" href="#sglang.srt.layers.linear.RowParallelLinear">RowParallelLinear</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.layers.linear.LinearBase.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, x: torch.Tensor) ‑> torch.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, x: torch.Tensor) -&gt; torch.Tensor:
    raise NotImplementedError</code></pre>
</details>
<div class="desc"><p>Define the computation performed at every call.</p>
<p>Should be overridden by all subclasses.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although the recipe for forward pass needs to be defined within
this function, one should call the :class:<code>Module</code> instance afterwards
instead of this since the former takes care of running the
registered hooks while the latter silently ignores them.</p>
</div></div>
</dd>
</dl>
</dd>
<dt id="sglang.srt.layers.linear.MergedColumnParallelLinear"><code class="flex name class">
<span>class <span class="ident">MergedColumnParallelLinear</span></span>
<span>(</span><span>input_size: int,<br>output_sizes: List[int],<br>bias: bool = True,<br>gather_output: bool = False,<br>skip_bias_add: bool = False,<br>params_dtype: Optional[torch.dtype] = None,<br>quant_config: Optional[QuantizationConfig] = None,<br>prefix: str = '',<br>tp_rank: Optional[int] = None,<br>tp_size: Optional[int] = None,<br>use_presharded_weights: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MergedColumnParallelLinear(ColumnParallelLinear):
    &#34;&#34;&#34;Packed linear layers with column parallelism.

    Similar to ColumnParallelLinear, but the weight matrix is concatenated
    along the output dimension. When the weight matrix is loaded, the
    different partitions are sharded separately.

    Args:
        input_size: input dimension of the linear layer.
        output_sizes: list of output dimensions of the linear layer.
        bias: If true, add bias.
        gather_output: If true, call all-gather on output and make the output
                       available to all GPUs, otherwise, every GPU will have
                       its own output.
        skip_bias_add: This was added to enable performance optimizations where
                       bias can be fused with other element-wise operations. we
                       skip adding bias but instead return it.
        params_dtype: Data type for the parameters.
        quant_config: Quantization configure.
        prefix: The name of the layer in the state dict, including all parents
                        (e.g. model.layers.0.qkv_proj)
    &#34;&#34;&#34;

    def __init__(
        self,
        input_size: int,
        output_sizes: List[int],
        bias: bool = True,
        gather_output: bool = False,
        skip_bias_add: bool = False,
        params_dtype: Optional[torch.dtype] = None,
        quant_config: Optional[QuantizationConfig] = None,
        prefix: str = &#34;&#34;,
        tp_rank: Optional[int] = None,
        tp_size: Optional[int] = None,
        use_presharded_weights: bool = False,
    ):
        self.output_sizes = output_sizes
        if tp_rank is None:
            tp_rank = get_tensor_model_parallel_rank()
        if tp_size is None:
            tp_size = get_tensor_model_parallel_world_size()
        self.tp_rank, self.tp_size = tp_rank, tp_size
        assert all(output_size % tp_size == 0 for output_size in output_sizes)
        self.use_presharded_weights = use_presharded_weights
        super().__init__(
            input_size=input_size,
            output_size=sum(output_sizes),
            bias=bias,
            gather_output=gather_output,
            skip_bias_add=skip_bias_add,
            params_dtype=params_dtype,
            quant_config=quant_config,
            prefix=prefix,
            tp_rank=tp_rank,
            tp_size=tp_size,
            use_presharded_weights=use_presharded_weights,
        )
        self.prefix = prefix

    def weight_loader(
        self,
        param: Parameter,
        loaded_weight: torch.Tensor,
        loaded_shard_id: Optional[int] = None,
    ):

        # Special case for GGUF
        # initialize GGUF param after we know the quantize type
        is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
        is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
        if is_gguf_weight_type:
            param.data[loaded_shard_id].copy_(loaded_weight)
            param.shard_weight_type[loaded_shard_id] = loaded_weight.item()
            return

        if is_gguf_weight:
            output_dim = getattr(param, &#34;output_dim&#34;, None)
            shard_size = loaded_weight.size(output_dim) // self.tp_size
            start_idx = self.tp_rank * shard_size

            loaded_weight = loaded_weight.narrow(output_dim, start_idx, shard_size)

            param.shard_id.append(loaded_shard_id)
            param.shard_id_map[loaded_shard_id] = len(param.data_container)
            param.data_container.append(loaded_weight)
            return

        param_data = param.data
        output_dim = getattr(param, &#34;output_dim&#34;, None)
        # Special case for AQLM codebooks.
        is_metadata = getattr(param, &#34;is_metadata&#34;, False)
        # Special case for per-tensor scale to load scalar into fused array.
        needs_scalar_to_array = getattr(param, &#34;needs_scalar_to_array&#34;, False)

        if loaded_shard_id is None:
            # Loaded weight is already fused on disk (qkv/mlp).
            if output_dim is None:
                if needs_scalar_to_array:
                    param_data, loaded_weight = adjust_scalar_to_fused_array(
                        param_data, loaded_weight, 0
                    )

                assert param_data.shape == loaded_weight.shape
                param_data.copy_(loaded_weight)
                return
            current_shard_offset = 0
            shard_offsets: List[Tuple[int, int, int]] = []
            for i, output_size in enumerate(self.output_sizes):
                shard_offsets.append((i, current_shard_offset, output_size))
                current_shard_offset += output_size
            packed_dim = getattr(param, &#34;packed_dim&#34;, None)

            use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)
            if _is_cpu:
                shard_offsets = adjust_shard_offsets(
                    shard_offsets, loaded_weight, output_dim
                )

            for shard_id, shard_offset, shard_size in shard_offsets:
                # Special case for Quantization.
                # If quantized, we need to adjust the offset and size to account
                # for the packing.
                if packed_dim == output_dim:
                    shard_size = shard_size // param.pack_factor
                    shard_offset = shard_offset // param.pack_factor
                    # Special case for Marlin.
                    shard_size, shard_offset = adjust_marlin_shard(
                        param, shard_size, shard_offset
                    )

                if use_bitsandbytes_4bit:
                    index = list(itertools.accumulate([0] + self.output_sizes))
                    orig_offsets = {
                        str(i): (index[i], size)
                        for i, size in enumerate(self.output_sizes)
                    }
                    orig_offsets[&#34;total&#34;] = (self.output_size, 0)
                    shard_size, shard_offset = adjust_bitsandbytes_4bit_shard(
                        param, orig_offsets, str(shard_id)
                    )

                loaded_weight_shard = loaded_weight.narrow(
                    output_dim, shard_offset, shard_size
                )
                self.weight_loader(param, loaded_weight_shard, shard_id)
            return

        assert loaded_shard_id &lt; len(self.output_sizes)
        if output_dim is not None:
            shard_offset = sum(self.output_sizes[:loaded_shard_id]) // self.tp_size
            shard_size = self.output_sizes[loaded_shard_id] // self.tp_size
            # Special case for quantization.
            # If quantized, we need to adjust the offset and size to account
            # for the packing.
            packed_dim = getattr(param, &#34;packed_dim&#34;, None)
            if packed_dim == output_dim:
                shard_size = shard_size // param.pack_factor
                shard_offset = shard_offset // param.pack_factor
                # Special case for Marlin.
                shard_size, shard_offset = adjust_marlin_shard(
                    param, shard_size, shard_offset
                )

            use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)
            if use_bitsandbytes_4bit:
                shard_size = loaded_weight.shape[output_dim]
                shard_offset = loaded_weight.shape[output_dim] * loaded_shard_id

            param_data = param_data.narrow(output_dim, shard_offset, shard_size)
            start_idx = self.tp_rank * shard_size

            if _is_cpu:
                from sglang.srt.model_loader.weight_utils import (
                    narrow_padded_param_and_loaded_weight,
                )

                param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                    param_data,
                    loaded_weight,
                    0,  # param_data_start
                    start_idx,
                    output_dim,
                    shard_size,
                    not use_bitsandbytes_4bit and not self.use_presharded_weights,
                )
            else:
                # bitsandbytes loads the weights of the specific portion
                # no need to narrow here
                if not use_bitsandbytes_4bit and not self.use_presharded_weights:
                    loaded_weight = loaded_weight.narrow(
                        output_dim, start_idx, shard_size
                    )

        # Special case for AQLM codebooks.
        elif is_metadata:
            # metadata indicates fixed size concatenated along dim 0
            shard_size = loaded_weight.shape[0]
            shard_offset = loaded_shard_id * shard_size
            param_data = param_data.narrow(0, shard_offset, shard_size)

        # Special case for per-tensor scales in fused case.
        elif needs_scalar_to_array:
            param_data, loaded_weight = adjust_scalar_to_fused_array(
                param_data, loaded_weight, loaded_shard_id
            )

        else:
            ignore_warning = getattr(param, &#34;ignore_warning&#34;, False)
            if not ignore_warning:
                logger.warning(
                    &#34;Loading a weight without `output_dim` attribute in &#34;
                    &#34;MergedColumnParallelLinear, assume the weight is &#34;
                    &#34;the same for all partitions.&#34;
                )

        assert param_data.shape == loaded_weight.shape
        param_data.copy_(loaded_weight)

    def _load_fused_module_from_checkpoint(
        self, param: BasevLLMParameter, loaded_weight: torch.Tensor
    ):
        &#34;&#34;&#34;
        Handle special case for models where MLP layers are already
        fused on disk. In this case, we have no shard id. This function
        determmines the shard id by splitting these layers and then calls
        the weight loader using the shard id.

        An example of a model with these fused layers:
        https://huggingface.co/microsoft/Phi-3-mini-4k-instruct
        &#34;&#34;&#34;

        current_shard_offset = 0
        shard_offsets: List[Tuple[int, int, int]] = []
        for i, output_size in enumerate(self.output_sizes):
            shard_offsets.append((i, current_shard_offset, output_size))
            current_shard_offset += output_size

        for shard_id, shard_offset, shard_size in shard_offsets:
            # Special case for Quantization.
            # If quantized, we need to adjust the offset and size to account
            # for the packing.
            if (
                isinstance(param, (PackedColumnParameter, PackedvLLMParameter))
                and param.packed_dim == param.output_dim
            ):
                shard_size, shard_offset = param.adjust_shard_indexes_for_packing(
                    shard_size=shard_size, shard_offset=shard_offset
                )

            loaded_weight_shard = loaded_weight.narrow(
                param.output_dim, shard_offset, shard_size
            )
            self.weight_loader_v2(param, loaded_weight_shard, shard_id)

    def weight_loader_v2(
        self,
        param: BasevLLMParameter,
        loaded_weight: torch.Tensor,
        loaded_shard_id: Optional[int] = None,
    ):
        if loaded_shard_id is None:
            if isinstance(param, PerTensorScaleParameter):
                param.load_merged_column_weight(
                    loaded_weight=loaded_weight,
                    shard_id=0,
                    tp_rank=self.tp_rank,
                    tp_size=self.tp_size,
                )
                return
            elif type(param) in (RowvLLMParameter, BasevLLMParameter):
                param.load_merged_column_weight(
                    loaded_weight=loaded_weight,
                    tp_rank=self.tp_rank,
                    tp_size=self.tp_size,
                )
                return
            # TODO: @dsikka - move to parameter.py
            self._load_fused_module_from_checkpoint(param, loaded_weight)
            return

        assert loaded_shard_id &lt; len(self.output_sizes)

        if isinstance(param, BlockQuantScaleParameter):
            weight_block_size = self.quant_method.quant_config.weight_block_size
            block_n, _ = weight_block_size[0], weight_block_size[1]
            shard_offset = (
                (sum(self.output_sizes[:loaded_shard_id]) + block_n - 1) // block_n
            ) // self.tp_size
            shard_size = (
                (self.output_sizes[loaded_shard_id] + block_n - 1)
                // block_n
                // self.tp_size
            )
        else:
            shard_offset = sum(self.output_sizes[:loaded_shard_id]) // self.tp_size
            shard_size = self.output_sizes[loaded_shard_id] // self.tp_size

        param.load_merged_column_weight(
            loaded_weight=loaded_weight,
            shard_id=loaded_shard_id,
            shard_offset=shard_offset,
            shard_size=shard_size,
            use_presharded_weights=self.use_presharded_weights,
            tp_rank=self.tp_rank,
            tp_size=self.tp_size,
        )</code></pre>
</details>
<div class="desc"><p>Packed linear layers with column parallelism.</p>
<p>Similar to ColumnParallelLinear, but the weight matrix is concatenated
along the output dimension. When the weight matrix is loaded, the
different partitions are sharded separately.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_size</code></strong></dt>
<dd>input dimension of the linear layer.</dd>
<dt><strong><code>output_sizes</code></strong></dt>
<dd>list of output dimensions of the linear layer.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>If true, add bias.</dd>
<dt><strong><code>gather_output</code></strong></dt>
<dd>If true, call all-gather on output and make the output
available to all GPUs, otherwise, every GPU will have
its own output.</dd>
<dt><strong><code>skip_bias_add</code></strong></dt>
<dd>This was added to enable performance optimizations where
bias can be fused with other element-wise operations. we
skip adding bias but instead return it.</dd>
<dt><strong><code>params_dtype</code></strong></dt>
<dd>Data type for the parameters.</dd>
<dt><strong><code>quant_config</code></strong></dt>
<dd>Quantization configure.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The name of the layer in the state dict, including all parents
(e.g. model.layers.0.qkv_proj)</dd>
</dl>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.ColumnParallelLinear" href="#sglang.srt.layers.linear.ColumnParallelLinear">ColumnParallelLinear</a></li>
<li><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.layers.linear.MergedColumnParallelLinear.weight_loader"><code class="name flex">
<span>def <span class="ident">weight_loader</span></span>(<span>self,<br>param: Parameter,<br>loaded_weight: torch.Tensor,<br>loaded_shard_id: Optional[int] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader(
    self,
    param: Parameter,
    loaded_weight: torch.Tensor,
    loaded_shard_id: Optional[int] = None,
):

    # Special case for GGUF
    # initialize GGUF param after we know the quantize type
    is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
    is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
    if is_gguf_weight_type:
        param.data[loaded_shard_id].copy_(loaded_weight)
        param.shard_weight_type[loaded_shard_id] = loaded_weight.item()
        return

    if is_gguf_weight:
        output_dim = getattr(param, &#34;output_dim&#34;, None)
        shard_size = loaded_weight.size(output_dim) // self.tp_size
        start_idx = self.tp_rank * shard_size

        loaded_weight = loaded_weight.narrow(output_dim, start_idx, shard_size)

        param.shard_id.append(loaded_shard_id)
        param.shard_id_map[loaded_shard_id] = len(param.data_container)
        param.data_container.append(loaded_weight)
        return

    param_data = param.data
    output_dim = getattr(param, &#34;output_dim&#34;, None)
    # Special case for AQLM codebooks.
    is_metadata = getattr(param, &#34;is_metadata&#34;, False)
    # Special case for per-tensor scale to load scalar into fused array.
    needs_scalar_to_array = getattr(param, &#34;needs_scalar_to_array&#34;, False)

    if loaded_shard_id is None:
        # Loaded weight is already fused on disk (qkv/mlp).
        if output_dim is None:
            if needs_scalar_to_array:
                param_data, loaded_weight = adjust_scalar_to_fused_array(
                    param_data, loaded_weight, 0
                )

            assert param_data.shape == loaded_weight.shape
            param_data.copy_(loaded_weight)
            return
        current_shard_offset = 0
        shard_offsets: List[Tuple[int, int, int]] = []
        for i, output_size in enumerate(self.output_sizes):
            shard_offsets.append((i, current_shard_offset, output_size))
            current_shard_offset += output_size
        packed_dim = getattr(param, &#34;packed_dim&#34;, None)

        use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)
        if _is_cpu:
            shard_offsets = adjust_shard_offsets(
                shard_offsets, loaded_weight, output_dim
            )

        for shard_id, shard_offset, shard_size in shard_offsets:
            # Special case for Quantization.
            # If quantized, we need to adjust the offset and size to account
            # for the packing.
            if packed_dim == output_dim:
                shard_size = shard_size // param.pack_factor
                shard_offset = shard_offset // param.pack_factor
                # Special case for Marlin.
                shard_size, shard_offset = adjust_marlin_shard(
                    param, shard_size, shard_offset
                )

            if use_bitsandbytes_4bit:
                index = list(itertools.accumulate([0] + self.output_sizes))
                orig_offsets = {
                    str(i): (index[i], size)
                    for i, size in enumerate(self.output_sizes)
                }
                orig_offsets[&#34;total&#34;] = (self.output_size, 0)
                shard_size, shard_offset = adjust_bitsandbytes_4bit_shard(
                    param, orig_offsets, str(shard_id)
                )

            loaded_weight_shard = loaded_weight.narrow(
                output_dim, shard_offset, shard_size
            )
            self.weight_loader(param, loaded_weight_shard, shard_id)
        return

    assert loaded_shard_id &lt; len(self.output_sizes)
    if output_dim is not None:
        shard_offset = sum(self.output_sizes[:loaded_shard_id]) // self.tp_size
        shard_size = self.output_sizes[loaded_shard_id] // self.tp_size
        # Special case for quantization.
        # If quantized, we need to adjust the offset and size to account
        # for the packing.
        packed_dim = getattr(param, &#34;packed_dim&#34;, None)
        if packed_dim == output_dim:
            shard_size = shard_size // param.pack_factor
            shard_offset = shard_offset // param.pack_factor
            # Special case for Marlin.
            shard_size, shard_offset = adjust_marlin_shard(
                param, shard_size, shard_offset
            )

        use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)
        if use_bitsandbytes_4bit:
            shard_size = loaded_weight.shape[output_dim]
            shard_offset = loaded_weight.shape[output_dim] * loaded_shard_id

        param_data = param_data.narrow(output_dim, shard_offset, shard_size)
        start_idx = self.tp_rank * shard_size

        if _is_cpu:
            from sglang.srt.model_loader.weight_utils import (
                narrow_padded_param_and_loaded_weight,
            )

            param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                param_data,
                loaded_weight,
                0,  # param_data_start
                start_idx,
                output_dim,
                shard_size,
                not use_bitsandbytes_4bit and not self.use_presharded_weights,
            )
        else:
            # bitsandbytes loads the weights of the specific portion
            # no need to narrow here
            if not use_bitsandbytes_4bit and not self.use_presharded_weights:
                loaded_weight = loaded_weight.narrow(
                    output_dim, start_idx, shard_size
                )

    # Special case for AQLM codebooks.
    elif is_metadata:
        # metadata indicates fixed size concatenated along dim 0
        shard_size = loaded_weight.shape[0]
        shard_offset = loaded_shard_id * shard_size
        param_data = param_data.narrow(0, shard_offset, shard_size)

    # Special case for per-tensor scales in fused case.
    elif needs_scalar_to_array:
        param_data, loaded_weight = adjust_scalar_to_fused_array(
            param_data, loaded_weight, loaded_shard_id
        )

    else:
        ignore_warning = getattr(param, &#34;ignore_warning&#34;, False)
        if not ignore_warning:
            logger.warning(
                &#34;Loading a weight without `output_dim` attribute in &#34;
                &#34;MergedColumnParallelLinear, assume the weight is &#34;
                &#34;the same for all partitions.&#34;
            )

    assert param_data.shape == loaded_weight.shape
    param_data.copy_(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.layers.linear.MergedColumnParallelLinear.weight_loader_v2"><code class="name flex">
<span>def <span class="ident">weight_loader_v2</span></span>(<span>self,<br>param: BasevLLMParameter,<br>loaded_weight: torch.Tensor,<br>loaded_shard_id: Optional[int] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader_v2(
    self,
    param: BasevLLMParameter,
    loaded_weight: torch.Tensor,
    loaded_shard_id: Optional[int] = None,
):
    if loaded_shard_id is None:
        if isinstance(param, PerTensorScaleParameter):
            param.load_merged_column_weight(
                loaded_weight=loaded_weight,
                shard_id=0,
                tp_rank=self.tp_rank,
                tp_size=self.tp_size,
            )
            return
        elif type(param) in (RowvLLMParameter, BasevLLMParameter):
            param.load_merged_column_weight(
                loaded_weight=loaded_weight,
                tp_rank=self.tp_rank,
                tp_size=self.tp_size,
            )
            return
        # TODO: @dsikka - move to parameter.py
        self._load_fused_module_from_checkpoint(param, loaded_weight)
        return

    assert loaded_shard_id &lt; len(self.output_sizes)

    if isinstance(param, BlockQuantScaleParameter):
        weight_block_size = self.quant_method.quant_config.weight_block_size
        block_n, _ = weight_block_size[0], weight_block_size[1]
        shard_offset = (
            (sum(self.output_sizes[:loaded_shard_id]) + block_n - 1) // block_n
        ) // self.tp_size
        shard_size = (
            (self.output_sizes[loaded_shard_id] + block_n - 1)
            // block_n
            // self.tp_size
        )
    else:
        shard_offset = sum(self.output_sizes[:loaded_shard_id]) // self.tp_size
        shard_size = self.output_sizes[loaded_shard_id] // self.tp_size

    param.load_merged_column_weight(
        loaded_weight=loaded_weight,
        shard_id=loaded_shard_id,
        shard_offset=shard_offset,
        shard_size=shard_size,
        use_presharded_weights=self.use_presharded_weights,
        tp_rank=self.tp_rank,
        tp_size=self.tp_size,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.layers.linear.ColumnParallelLinear" href="#sglang.srt.layers.linear.ColumnParallelLinear">ColumnParallelLinear</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.extra_repr" href="#sglang.srt.layers.linear.ColumnParallelLinear.extra_repr">extra_repr</a></code></li>
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.forward" href="#sglang.srt.layers.linear.LinearBase.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sglang.srt.layers.linear.QKVParallelLinear"><code class="flex name class">
<span>class <span class="ident">QKVParallelLinear</span></span>
<span>(</span><span>hidden_size: int,<br>head_size: int,<br>total_num_heads: int,<br>total_num_kv_heads: Optional[int] = None,<br>bias: bool = True,<br>skip_bias_add: bool = False,<br>params_dtype: Optional[torch.dtype] = None,<br>quant_config: Optional[QuantizationConfig] = None,<br>prefix: str = '',<br>tp_rank: Optional[int] = None,<br>tp_size: Optional[int] = None,<br>load_presharded_attn: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QKVParallelLinear(ColumnParallelLinear):
    &#34;&#34;&#34;Linear layers for the attention&#39;s QKV transformation.

    Linear layers for the linear transformation of the query, key, and value
    vectors in the attention layer. The weight matrix is concatenated along
    the output dimension. The layer is parallelized along the head dimension.
    When the number of key/value heads is smaller than the number of query
    heads (e.g., multi-query/grouped-query attention), the key/value head may
    be replicated while the query heads are partitioned.

    Args:
        hidden_size: input hidden state size of the transformer.
        head_size: size of each attention head.
        total_num_heads: total number of attention query heads.
        total_num_kv_heads: total number of attention key/value heads. If
                            None, assume total_num_kv_heads = total_num_heads.
        bias: If true, add bias.
        skip_bias_add: This was added to enable performance optimizations where
                       bias can be fused with other element-wise operations. we
                       skip adding bias but instead return it.
        params_dtype: Data type for the parameters.
        quant_config: Quantization configure.
        prefix: The name of the layer in the state dict, including all parents
                        (e.g. model.layers.0.qkv_proj)
    &#34;&#34;&#34;

    def __init__(
        self,
        hidden_size: int,
        head_size: int,
        total_num_heads: int,
        total_num_kv_heads: Optional[int] = None,
        bias: bool = True,
        skip_bias_add: bool = False,
        params_dtype: Optional[torch.dtype] = None,
        quant_config: Optional[QuantizationConfig] = None,
        prefix: str = &#34;&#34;,
        tp_rank: Optional[int] = None,
        tp_size: Optional[int] = None,
        load_presharded_attn: bool = False,
    ):
        self.hidden_size = hidden_size
        self.head_size = head_size
        self.total_num_heads = total_num_heads
        if total_num_kv_heads is None:
            total_num_kv_heads = total_num_heads
        self.total_num_kv_heads = total_num_kv_heads
        # Divide the weight matrix along the last dimension.
        if tp_rank is None:
            tp_rank = get_tensor_model_parallel_rank()
        if tp_size is None:
            tp_size = get_tensor_model_parallel_world_size()
        self.tp_rank, self.tp_size = tp_rank, tp_size
        self.num_heads = divide(self.total_num_heads, tp_size)
        if tp_size &gt;= self.total_num_kv_heads:
            self.num_kv_heads = 1
            self.num_kv_head_replicas = divide(tp_size, self.total_num_kv_heads)
        else:
            self.num_kv_heads = divide(self.total_num_kv_heads, tp_size)
            self.num_kv_head_replicas = 1
        self.q_proj_shard_size = self.num_heads * self.head_size
        self.kv_proj_shard_size = self.num_kv_heads * self.head_size
        input_size = self.hidden_size
        output_size = (
            (self.num_heads + 2 * self.num_kv_heads) * tp_size * self.head_size
        )
        self.output_sizes = [
            self.num_heads * self.head_size * tp_size,  # q_proj
            self.num_kv_heads * self.head_size * tp_size,  # k_proj
            self.num_kv_heads * self.head_size * tp_size,  # v_proj
        ]
        self.use_presharded_weights = load_presharded_attn

        super().__init__(
            input_size=input_size,
            output_size=output_size,
            bias=bias,
            gather_output=False,
            skip_bias_add=skip_bias_add,
            params_dtype=params_dtype,
            quant_config=quant_config,
            prefix=prefix,
            tp_rank=tp_rank,
            tp_size=tp_size,
            use_presharded_weights=self.use_presharded_weights,
        )

    def _get_shard_offset_mapping(self, loaded_shard_id: str):
        shard_offset_mapping = {
            &#34;q&#34;: 0,
            &#34;k&#34;: self.num_heads * self.head_size,
            &#34;v&#34;: (self.num_heads + self.num_kv_heads) * self.head_size,
            &#34;total&#34;: (self.num_heads + 2 * self.num_kv_heads) * self.head_size,
        }
        return shard_offset_mapping.get(loaded_shard_id)

    def _get_shard_size_mapping(self, loaded_shard_id: str):
        shard_size_mapping = {
            &#34;q&#34;: self.num_heads * self.head_size,
            &#34;k&#34;: self.num_kv_heads * self.head_size,
            &#34;v&#34;: self.num_kv_heads * self.head_size,
        }
        return shard_size_mapping.get(loaded_shard_id)

    def _load_fused_module_from_checkpoint(
        self, param: BasevLLMParameter, loaded_weight: torch.Tensor
    ):
        &#34;&#34;&#34;
        Handle special case for models where QKV layers are already
        fused on disk. In this case, we have no shard id. This function
        determmines the shard id by splitting these layers and then calls
        the weight loader using the shard id.

        An example of a model with these fused layers:
        https://huggingface.co/microsoft/Phi-3-mini-4k-instruct
        &#34;&#34;&#34;
        shard_offsets = [
            # (shard_id, shard_offset, shard_size)
            (&#34;q&#34;, 0, self.total_num_heads * self.head_size),
            (
                &#34;k&#34;,
                self.total_num_heads * self.head_size,
                self.total_num_kv_heads * self.head_size,
            ),
            (
                &#34;v&#34;,
                (self.total_num_heads + self.total_num_kv_heads) * self.head_size,
                self.total_num_kv_heads * self.head_size,
            ),
        ]

        for shard_id, shard_offset, shard_size in shard_offsets:
            # Special case for Quantization.
            # If quantized, we need to adjust the offset and size to account
            # for the packing.
            if (
                isinstance(param, (PackedColumnParameter, PackedvLLMParameter))
                and param.packed_dim == param.output_dim
            ):
                shard_size, shard_offset = param.adjust_shard_indexes_for_packing(
                    shard_size=shard_size, shard_offset=shard_offset
                )

            if not self.use_presharded_weights:
                loaded_weight_shard = loaded_weight.narrow(
                    param.output_dim, shard_offset, shard_size
                )
            self.weight_loader_v2(param, loaded_weight_shard, shard_id)

    def weight_loader_v2(
        self,
        param: BasevLLMParameter,
        loaded_weight: torch.Tensor,
        loaded_shard_id: Optional[str] = None,
    ):
        if loaded_shard_id is None:  # special case for certain models
            if isinstance(param, PerTensorScaleParameter):
                param.load_qkv_weight(loaded_weight=loaded_weight, shard_id=0)
                return
            elif type(param) in (RowvLLMParameter, BasevLLMParameter):
                param.load_qkv_weight(loaded_weight=loaded_weight)
                return
            # TODO: @dsikka - move to parameter.py
            self._load_fused_module_from_checkpoint(param, loaded_weight)
            return

        assert loaded_shard_id in [&#34;q&#34;, &#34;k&#34;, &#34;v&#34;]

        shard_offset = self._get_shard_offset_mapping(loaded_shard_id)
        shard_size = self._get_shard_size_mapping(loaded_shard_id)

        if isinstance(param, BlockQuantScaleParameter):
            weight_block_size = self.quant_method.quant_config.weight_block_size
            block_n, _ = weight_block_size[0], weight_block_size[1]
            shard_offset = (shard_offset + block_n - 1) // block_n
            shard_size = (shard_size + block_n - 1) // block_n

        param.load_qkv_weight(
            loaded_weight=loaded_weight,
            num_heads=self.num_kv_head_replicas,
            shard_id=loaded_shard_id,
            shard_offset=shard_offset,
            shard_size=shard_size,
            tp_rank=self.tp_rank,
            use_presharded_weights=self.use_presharded_weights,
        )

    def weight_loader(
        self,
        param: Parameter,
        loaded_weight: torch.Tensor,
        loaded_shard_id: Optional[str] = None,
    ):

        # Special case for GGUF
        # initialize GGUF param after we know the quantize type
        is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
        is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
        if is_gguf_weight_type and loaded_shard_id is not None:
            idx_map = {&#34;q&#34;: 0, &#34;k&#34;: 1, &#34;v&#34;: 2}
            param.data[idx_map[loaded_shard_id]].copy_(loaded_weight)
            param.shard_weight_type[loaded_shard_id] = loaded_weight.item()
            return

        if is_gguf_weight:
            output_dim = getattr(param, &#34;output_dim&#34;, None)
            shard_size = loaded_weight.size(output_dim) // self.tp_size
            start_idx = self.tp_rank * shard_size

            loaded_weight = loaded_weight.narrow(output_dim, start_idx, shard_size)

            param.shard_id.append(loaded_shard_id)
            param.shard_id_map[loaded_shard_id] = len(param.data_container)
            param.data_container.append(loaded_weight)
            return

        param_data = param.data
        output_dim = getattr(param, &#34;output_dim&#34;, None)
        # Special case for AQLM codebooks.
        is_metadata = getattr(param, &#34;is_metadata&#34;, False)

        # Special case for per-tensor scales in fused case.
        needs_scalar_to_array = getattr(param, &#34;needs_scalar_to_array&#34;, False)

        if loaded_shard_id is None:
            # Loaded weight is already fused on disk (qkv/mlp).
            if output_dim is None:
                if needs_scalar_to_array:
                    param_data, loaded_weight = adjust_scalar_to_fused_array(
                        param_data, loaded_weight, 0
                    )

                assert param_data.shape == loaded_weight.shape
                param_data.copy_(loaded_weight)
                return
            shard_offsets = [
                # (shard_id, shard_offset, shard_size)
                (&#34;q&#34;, 0, self.total_num_heads * self.head_size),
                (
                    &#34;k&#34;,
                    self.total_num_heads * self.head_size,
                    self.total_num_kv_heads * self.head_size,
                ),
                (
                    &#34;v&#34;,
                    (self.total_num_heads + self.total_num_kv_heads) * self.head_size,
                    self.total_num_kv_heads * self.head_size,
                ),
            ]
            use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)

            packed_dim = getattr(param, &#34;packed_dim&#34;, None)
            if _is_cpu:
                shard_offsets = adjust_shard_offsets(
                    shard_offsets, loaded_weight, output_dim
                )

            for shard_id, shard_offset, shard_size in shard_offsets:
                # Special case for Quantized Weights.
                # If quantized, we need to adjust the offset and size to account
                # for the packing.
                if packed_dim == output_dim:
                    shard_size = shard_size // param.pack_factor
                    shard_offset = shard_offset // param.pack_factor

                    # Special case for Marlin.
                    shard_size, shard_offset = adjust_marlin_shard(
                        param, shard_size, shard_offset
                    )

                if use_bitsandbytes_4bit:
                    orig_qkv_offsets = {
                        &#34;q&#34;: (0, self.total_num_heads * self.head_size),
                        &#34;k&#34;: (
                            self.total_num_heads * self.head_size,
                            self.total_num_kv_heads * self.head_size,
                        ),
                        &#34;v&#34;: (
                            (self.total_num_heads + self.total_num_kv_heads)
                            * self.head_size,
                            self.total_num_kv_heads * self.head_size,
                        ),
                        &#34;total&#34;: (
                            (self.total_num_heads + 2 * self.total_num_kv_heads)
                            * self.head_size,
                            0,
                        ),
                    }

                    shard_size, shard_offset = adjust_bitsandbytes_4bit_shard(
                        param, orig_qkv_offsets, shard_id
                    )

                if not self.use_presharded_weights:
                    loaded_weight_shard = loaded_weight.narrow(
                        output_dim, shard_offset, shard_size
                    )
                self.weight_loader(param, loaded_weight_shard, shard_id)
            return

        assert loaded_shard_id in [&#34;q&#34;, &#34;k&#34;, &#34;v&#34;]

        # If output dim is defined, use the default loading process.
        if output_dim is not None:
            if loaded_shard_id == &#34;q&#34;:
                shard_offset = 0
                shard_size = self.num_heads * self.head_size
            elif loaded_shard_id == &#34;k&#34;:
                shard_offset = self.num_heads * self.head_size
                shard_size = self.num_kv_heads * self.head_size
            elif loaded_shard_id == &#34;v&#34;:
                shard_offset = (self.num_heads + self.num_kv_heads) * self.head_size
                shard_size = self.num_kv_heads * self.head_size
            # Special case for Quantized Weights.
            # If quantized, we need to adjust the offset and size to account
            # for the packing.
            packed_dim = getattr(param, &#34;packed_dim&#34;, None)
            if packed_dim == output_dim:
                shard_size = shard_size // param.pack_factor
                shard_offset = shard_offset // param.pack_factor

                # Special case for Marlin.
                shard_size, shard_offset = adjust_marlin_shard(
                    param, shard_size, shard_offset
                )

            use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)
            if use_bitsandbytes_4bit:
                orig_qkv_offsets = {
                    &#34;q&#34;: (0, self.num_heads * self.head_size),
                    &#34;k&#34;: (
                        self.num_heads * self.head_size,
                        self.num_kv_heads * self.head_size,
                    ),
                    &#34;v&#34;: (
                        (self.num_heads + self.num_kv_heads) * self.head_size,
                        self.num_kv_heads * self.head_size,
                    ),
                    &#34;total&#34;: (
                        (self.num_heads + 2 * self.num_kv_heads) * self.head_size,
                        0,
                    ),
                }
                shard_size, shard_offset = adjust_bitsandbytes_4bit_shard(
                    param, orig_qkv_offsets, loaded_shard_id
                )

            param_data = param_data.narrow(output_dim, shard_offset, shard_size)
            if loaded_shard_id == &#34;q&#34;:
                shard_id = self.tp_rank
            else:
                shard_id = self.tp_rank // self.num_kv_head_replicas
            start_idx = shard_id * shard_size

            if _is_cpu:
                from sglang.srt.model_loader.weight_utils import (
                    narrow_padded_param_and_loaded_weight,
                )

                param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                    param_data,
                    loaded_weight,
                    0,  # param_data_start
                    start_idx,
                    output_dim,
                    shard_size,
                    not use_bitsandbytes_4bit and not self.use_presharded_weights,
                )
            else:
                # bitsandbytes loads the weights of the specific portion
                # no need to narrow here
                if not use_bitsandbytes_4bit and not self.use_presharded_weights:
                    loaded_weight = loaded_weight.narrow(
                        output_dim, start_idx, shard_size
                    )

        # Special case for for AQLM codebooks.
        elif is_metadata:
            # metadata indicates fixed size concatenated along dim 0
            shard_size = loaded_weight.shape[0]
            shard_index = [&#34;q&#34;, &#34;k&#34;, &#34;v&#34;].index(loaded_shard_id)
            param_data = param_data.narrow(0, shard_index * shard_size, shard_size)
        # Special case for per-tensor scales in fused case.
        elif needs_scalar_to_array:
            param_data, loaded_weight = adjust_scalar_to_fused_array(
                param_data, loaded_weight, loaded_shard_id
            )
        else:
            ignore_warning = getattr(param, &#34;ignore_warning&#34;, False)
            if not ignore_warning:
                logger.warning(
                    &#34;Loading a weight without `output_dim` attribute in &#34;
                    &#34;QKVParallelLinear, assume the weight is the same &#34;
                    &#34;for all partitions.&#34;
                )

        assert param_data.shape == loaded_weight.shape
        param_data.copy_(loaded_weight)</code></pre>
</details>
<div class="desc"><p>Linear layers for the attention's QKV transformation.</p>
<p>Linear layers for the linear transformation of the query, key, and value
vectors in the attention layer. The weight matrix is concatenated along
the output dimension. The layer is parallelized along the head dimension.
When the number of key/value heads is smaller than the number of query
heads (e.g., multi-query/grouped-query attention), the key/value head may
be replicated while the query heads are partitioned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hidden_size</code></strong></dt>
<dd>input hidden state size of the transformer.</dd>
<dt><strong><code>head_size</code></strong></dt>
<dd>size of each attention head.</dd>
<dt><strong><code>total_num_heads</code></strong></dt>
<dd>total number of attention query heads.</dd>
<dt><strong><code>total_num_kv_heads</code></strong></dt>
<dd>total number of attention key/value heads. If
None, assume total_num_kv_heads = total_num_heads.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>If true, add bias.</dd>
<dt><strong><code>skip_bias_add</code></strong></dt>
<dd>This was added to enable performance optimizations where
bias can be fused with other element-wise operations. we
skip adding bias but instead return it.</dd>
<dt><strong><code>params_dtype</code></strong></dt>
<dd>Data type for the parameters.</dd>
<dt><strong><code>quant_config</code></strong></dt>
<dd>Quantization configure.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The name of the layer in the state dict, including all parents
(e.g. model.layers.0.qkv_proj)</dd>
</dl>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.ColumnParallelLinear" href="#sglang.srt.layers.linear.ColumnParallelLinear">ColumnParallelLinear</a></li>
<li><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.layers.linear.QKVParallelLinear.weight_loader"><code class="name flex">
<span>def <span class="ident">weight_loader</span></span>(<span>self,<br>param: Parameter,<br>loaded_weight: torch.Tensor,<br>loaded_shard_id: Optional[str] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader(
    self,
    param: Parameter,
    loaded_weight: torch.Tensor,
    loaded_shard_id: Optional[str] = None,
):

    # Special case for GGUF
    # initialize GGUF param after we know the quantize type
    is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
    is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
    if is_gguf_weight_type and loaded_shard_id is not None:
        idx_map = {&#34;q&#34;: 0, &#34;k&#34;: 1, &#34;v&#34;: 2}
        param.data[idx_map[loaded_shard_id]].copy_(loaded_weight)
        param.shard_weight_type[loaded_shard_id] = loaded_weight.item()
        return

    if is_gguf_weight:
        output_dim = getattr(param, &#34;output_dim&#34;, None)
        shard_size = loaded_weight.size(output_dim) // self.tp_size
        start_idx = self.tp_rank * shard_size

        loaded_weight = loaded_weight.narrow(output_dim, start_idx, shard_size)

        param.shard_id.append(loaded_shard_id)
        param.shard_id_map[loaded_shard_id] = len(param.data_container)
        param.data_container.append(loaded_weight)
        return

    param_data = param.data
    output_dim = getattr(param, &#34;output_dim&#34;, None)
    # Special case for AQLM codebooks.
    is_metadata = getattr(param, &#34;is_metadata&#34;, False)

    # Special case for per-tensor scales in fused case.
    needs_scalar_to_array = getattr(param, &#34;needs_scalar_to_array&#34;, False)

    if loaded_shard_id is None:
        # Loaded weight is already fused on disk (qkv/mlp).
        if output_dim is None:
            if needs_scalar_to_array:
                param_data, loaded_weight = adjust_scalar_to_fused_array(
                    param_data, loaded_weight, 0
                )

            assert param_data.shape == loaded_weight.shape
            param_data.copy_(loaded_weight)
            return
        shard_offsets = [
            # (shard_id, shard_offset, shard_size)
            (&#34;q&#34;, 0, self.total_num_heads * self.head_size),
            (
                &#34;k&#34;,
                self.total_num_heads * self.head_size,
                self.total_num_kv_heads * self.head_size,
            ),
            (
                &#34;v&#34;,
                (self.total_num_heads + self.total_num_kv_heads) * self.head_size,
                self.total_num_kv_heads * self.head_size,
            ),
        ]
        use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)

        packed_dim = getattr(param, &#34;packed_dim&#34;, None)
        if _is_cpu:
            shard_offsets = adjust_shard_offsets(
                shard_offsets, loaded_weight, output_dim
            )

        for shard_id, shard_offset, shard_size in shard_offsets:
            # Special case for Quantized Weights.
            # If quantized, we need to adjust the offset and size to account
            # for the packing.
            if packed_dim == output_dim:
                shard_size = shard_size // param.pack_factor
                shard_offset = shard_offset // param.pack_factor

                # Special case for Marlin.
                shard_size, shard_offset = adjust_marlin_shard(
                    param, shard_size, shard_offset
                )

            if use_bitsandbytes_4bit:
                orig_qkv_offsets = {
                    &#34;q&#34;: (0, self.total_num_heads * self.head_size),
                    &#34;k&#34;: (
                        self.total_num_heads * self.head_size,
                        self.total_num_kv_heads * self.head_size,
                    ),
                    &#34;v&#34;: (
                        (self.total_num_heads + self.total_num_kv_heads)
                        * self.head_size,
                        self.total_num_kv_heads * self.head_size,
                    ),
                    &#34;total&#34;: (
                        (self.total_num_heads + 2 * self.total_num_kv_heads)
                        * self.head_size,
                        0,
                    ),
                }

                shard_size, shard_offset = adjust_bitsandbytes_4bit_shard(
                    param, orig_qkv_offsets, shard_id
                )

            if not self.use_presharded_weights:
                loaded_weight_shard = loaded_weight.narrow(
                    output_dim, shard_offset, shard_size
                )
            self.weight_loader(param, loaded_weight_shard, shard_id)
        return

    assert loaded_shard_id in [&#34;q&#34;, &#34;k&#34;, &#34;v&#34;]

    # If output dim is defined, use the default loading process.
    if output_dim is not None:
        if loaded_shard_id == &#34;q&#34;:
            shard_offset = 0
            shard_size = self.num_heads * self.head_size
        elif loaded_shard_id == &#34;k&#34;:
            shard_offset = self.num_heads * self.head_size
            shard_size = self.num_kv_heads * self.head_size
        elif loaded_shard_id == &#34;v&#34;:
            shard_offset = (self.num_heads + self.num_kv_heads) * self.head_size
            shard_size = self.num_kv_heads * self.head_size
        # Special case for Quantized Weights.
        # If quantized, we need to adjust the offset and size to account
        # for the packing.
        packed_dim = getattr(param, &#34;packed_dim&#34;, None)
        if packed_dim == output_dim:
            shard_size = shard_size // param.pack_factor
            shard_offset = shard_offset // param.pack_factor

            # Special case for Marlin.
            shard_size, shard_offset = adjust_marlin_shard(
                param, shard_size, shard_offset
            )

        use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)
        if use_bitsandbytes_4bit:
            orig_qkv_offsets = {
                &#34;q&#34;: (0, self.num_heads * self.head_size),
                &#34;k&#34;: (
                    self.num_heads * self.head_size,
                    self.num_kv_heads * self.head_size,
                ),
                &#34;v&#34;: (
                    (self.num_heads + self.num_kv_heads) * self.head_size,
                    self.num_kv_heads * self.head_size,
                ),
                &#34;total&#34;: (
                    (self.num_heads + 2 * self.num_kv_heads) * self.head_size,
                    0,
                ),
            }
            shard_size, shard_offset = adjust_bitsandbytes_4bit_shard(
                param, orig_qkv_offsets, loaded_shard_id
            )

        param_data = param_data.narrow(output_dim, shard_offset, shard_size)
        if loaded_shard_id == &#34;q&#34;:
            shard_id = self.tp_rank
        else:
            shard_id = self.tp_rank // self.num_kv_head_replicas
        start_idx = shard_id * shard_size

        if _is_cpu:
            from sglang.srt.model_loader.weight_utils import (
                narrow_padded_param_and_loaded_weight,
            )

            param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                param_data,
                loaded_weight,
                0,  # param_data_start
                start_idx,
                output_dim,
                shard_size,
                not use_bitsandbytes_4bit and not self.use_presharded_weights,
            )
        else:
            # bitsandbytes loads the weights of the specific portion
            # no need to narrow here
            if not use_bitsandbytes_4bit and not self.use_presharded_weights:
                loaded_weight = loaded_weight.narrow(
                    output_dim, start_idx, shard_size
                )

    # Special case for for AQLM codebooks.
    elif is_metadata:
        # metadata indicates fixed size concatenated along dim 0
        shard_size = loaded_weight.shape[0]
        shard_index = [&#34;q&#34;, &#34;k&#34;, &#34;v&#34;].index(loaded_shard_id)
        param_data = param_data.narrow(0, shard_index * shard_size, shard_size)
    # Special case for per-tensor scales in fused case.
    elif needs_scalar_to_array:
        param_data, loaded_weight = adjust_scalar_to_fused_array(
            param_data, loaded_weight, loaded_shard_id
        )
    else:
        ignore_warning = getattr(param, &#34;ignore_warning&#34;, False)
        if not ignore_warning:
            logger.warning(
                &#34;Loading a weight without `output_dim` attribute in &#34;
                &#34;QKVParallelLinear, assume the weight is the same &#34;
                &#34;for all partitions.&#34;
            )

    assert param_data.shape == loaded_weight.shape
    param_data.copy_(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.layers.linear.QKVParallelLinear.weight_loader_v2"><code class="name flex">
<span>def <span class="ident">weight_loader_v2</span></span>(<span>self,<br>param: BasevLLMParameter,<br>loaded_weight: torch.Tensor,<br>loaded_shard_id: Optional[str] = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader_v2(
    self,
    param: BasevLLMParameter,
    loaded_weight: torch.Tensor,
    loaded_shard_id: Optional[str] = None,
):
    if loaded_shard_id is None:  # special case for certain models
        if isinstance(param, PerTensorScaleParameter):
            param.load_qkv_weight(loaded_weight=loaded_weight, shard_id=0)
            return
        elif type(param) in (RowvLLMParameter, BasevLLMParameter):
            param.load_qkv_weight(loaded_weight=loaded_weight)
            return
        # TODO: @dsikka - move to parameter.py
        self._load_fused_module_from_checkpoint(param, loaded_weight)
        return

    assert loaded_shard_id in [&#34;q&#34;, &#34;k&#34;, &#34;v&#34;]

    shard_offset = self._get_shard_offset_mapping(loaded_shard_id)
    shard_size = self._get_shard_size_mapping(loaded_shard_id)

    if isinstance(param, BlockQuantScaleParameter):
        weight_block_size = self.quant_method.quant_config.weight_block_size
        block_n, _ = weight_block_size[0], weight_block_size[1]
        shard_offset = (shard_offset + block_n - 1) // block_n
        shard_size = (shard_size + block_n - 1) // block_n

    param.load_qkv_weight(
        loaded_weight=loaded_weight,
        num_heads=self.num_kv_head_replicas,
        shard_id=loaded_shard_id,
        shard_offset=shard_offset,
        shard_size=shard_size,
        tp_rank=self.tp_rank,
        use_presharded_weights=self.use_presharded_weights,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.layers.linear.ColumnParallelLinear" href="#sglang.srt.layers.linear.ColumnParallelLinear">ColumnParallelLinear</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.extra_repr" href="#sglang.srt.layers.linear.ColumnParallelLinear.extra_repr">extra_repr</a></code></li>
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.forward" href="#sglang.srt.layers.linear.LinearBase.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sglang.srt.layers.linear.ReplicatedLinear"><code class="flex name class">
<span>class <span class="ident">ReplicatedLinear</span></span>
<span>(</span><span>input_size: int,<br>output_size: int,<br>bias: bool = True,<br>skip_bias_add: bool = False,<br>params_dtype: Optional[torch.dtype] = None,<br>quant_config: Optional[QuantizationConfig] = None,<br>prefix: str = '')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplicatedLinear(LinearBase):
    &#34;&#34;&#34;Replicated linear layer.

    Args:
        input_size: input dimension of the linear layer.
        output_size: output dimension of the linear layer.
        bias: If true, add bias.
        skip_bias_add: If true, skip adding bias but instead return it.
        params_dtype: Data type for the parameters.
        quant_config: Quantization configure.
        prefix: The name of the layer in the state dict, including all parents
                        (e.g. model.layers.0.qkv_proj)
    &#34;&#34;&#34;

    def __init__(
        self,
        input_size: int,
        output_size: int,
        bias: bool = True,
        skip_bias_add: bool = False,
        params_dtype: Optional[torch.dtype] = None,
        quant_config: Optional[QuantizationConfig] = None,
        prefix: str = &#34;&#34;,
    ):
        super().__init__(
            input_size,
            output_size,
            skip_bias_add,
            params_dtype,
            quant_config,
            prefix=prefix,
        )

        # All the linear layer supports quant method.
        assert self.quant_method is not None
        self.quant_method.create_weights(
            self,
            self.input_size,
            [self.output_size],
            self.input_size,
            self.output_size,
            self.params_dtype,
            weight_loader=self.weight_loader,
        )

        if bias:
            self.bias = Parameter(
                torch.empty(self.output_size, dtype=self.params_dtype)
            )
            set_weight_attrs(
                self.bias,
                {
                    &#34;output_dim&#34;: 0,
                    &#34;weight_loader&#34;: self.weight_loader,
                },
            )
        else:
            self.register_parameter(&#34;bias&#34;, None)

    def weight_loader(self, param: Parameter, loaded_weight: torch.Tensor):
        # If the weight on disk does not have a shape, give it one
        # (such scales for AutoFp8).
        if len(loaded_weight.shape) == 0:
            loaded_weight = loaded_weight.reshape(1)

        # The per-tensor quant-scale must be 1 dimension
        if _is_npu:
            if param.size() != loaded_weight.size() and param.size(0) == 1:
                if torch.allclose(loaded_weight, loaded_weight[0]):
                    loaded_weight = loaded_weight[:1]
                else:
                    raise ValueError(f&#34;{loaded_weight} are not all equal&#34;)
        assert (
            param.size() == loaded_weight.size()
        ), f&#34;Loading weight error:  param: {param.size()}, loaded_weight: {loaded_weight.size()}&#34;
        param.data.copy_(loaded_weight)

    def forward(self, x: torch.Tensor) -&gt; Tuple[torch.Tensor, Optional[torch.Tensor]]:
        bias = self.bias if not self.skip_bias_add else None
        assert self.quant_method is not None
        output = self.quant_method.apply(self, x, bias)
        output_bias = self.bias if self.skip_bias_add else None
        return output, output_bias

    def extra_repr(self) -&gt; str:
        s = f&#34;in_features={self.input_size}&#34;
        s += f&#34;, output_features={self.output_size}&#34;
        s += f&#34;, bias={self.bias is not None}&#34;
        return s</code></pre>
</details>
<div class="desc"><p>Replicated linear layer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>input_size</code></strong></dt>
<dd>input dimension of the linear layer.</dd>
<dt><strong><code>output_size</code></strong></dt>
<dd>output dimension of the linear layer.</dd>
<dt><strong><code>bias</code></strong></dt>
<dd>If true, add bias.</dd>
<dt><strong><code>skip_bias_add</code></strong></dt>
<dd>If true, skip adding bias but instead return it.</dd>
<dt><strong><code>params_dtype</code></strong></dt>
<dd>Data type for the parameters.</dd>
<dt><strong><code>quant_config</code></strong></dt>
<dd>Quantization configure.</dd>
<dt><strong><code>prefix</code></strong></dt>
<dd>The name of the layer in the state dict, including all parents
(e.g. model.layers.0.qkv_proj)</dd>
</dl>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.layers.linear.ReplicatedLinear.extra_repr"><code class="name flex">
<span>def <span class="ident">extra_repr</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extra_repr(self) -&gt; str:
    s = f&#34;in_features={self.input_size}&#34;
    s += f&#34;, output_features={self.output_size}&#34;
    s += f&#34;, bias={self.bias is not None}&#34;
    return s</code></pre>
</details>
<div class="desc"><p>Return the extra representation of the module.</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p></div>
</dd>
<dt id="sglang.srt.layers.linear.ReplicatedLinear.weight_loader"><code class="name flex">
<span>def <span class="ident">weight_loader</span></span>(<span>self, param: Parameter, loaded_weight: torch.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader(self, param: Parameter, loaded_weight: torch.Tensor):
    # If the weight on disk does not have a shape, give it one
    # (such scales for AutoFp8).
    if len(loaded_weight.shape) == 0:
        loaded_weight = loaded_weight.reshape(1)

    # The per-tensor quant-scale must be 1 dimension
    if _is_npu:
        if param.size() != loaded_weight.size() and param.size(0) == 1:
            if torch.allclose(loaded_weight, loaded_weight[0]):
                loaded_weight = loaded_weight[:1]
            else:
                raise ValueError(f&#34;{loaded_weight} are not all equal&#34;)
    assert (
        param.size() == loaded_weight.size()
    ), f&#34;Loading weight error:  param: {param.size()}, loaded_weight: {loaded_weight.size()}&#34;
    param.data.copy_(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.layers.linear.LinearBase.forward" href="#sglang.srt.layers.linear.LinearBase.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sglang.srt.layers.linear.RowParallelLinear"><code class="flex name class">
<span>class <span class="ident">RowParallelLinear</span></span>
<span>(</span><span>input_size: int,<br>output_size: int,<br>bias: bool = True,<br>input_is_parallel: bool = True,<br>skip_bias_add: bool = False,<br>params_dtype: Optional[torch.dtype] = None,<br>reduce_results: bool = True,<br>quant_config: Optional[QuantizationConfig] = None,<br>prefix: str = '',<br>tp_rank: Optional[int] = None,<br>tp_size: Optional[int] = None,<br>use_presharded_weights: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RowParallelLinear(LinearBase):
    &#34;&#34;&#34;Linear layer with row parallelism.

    The linear layer is defined as Y = XA + b. A is parallelized along
    its first dimension and X along its second dimension as:
               -   -
              | A_1 |
              | .   |
          A = | .   |        X = [X_1, ..., X_p]
              | .   |
              | A_p |
               -   -
    Arguments:
        input_size: first dimension of matrix A.
        output_size: second dimension of matrix A.
        bias: If true, add bias. Note that bias is not parallelized.
        input_is_parallel: If true, we assume that the input is already
                           split across the GPUs and we do not split
                           again.
        skip_bias_add: This was added to enable performance optimization where
                       bias can be fused with other element-wise operations.
                       We skip adding bias but instead return it.
        params_dtype: Data type for the parameters.
        quant_config: Quantization configure.
    &#34;&#34;&#34;

    def __init__(
        self,
        input_size: int,
        output_size: int,
        bias: bool = True,
        input_is_parallel: bool = True,
        skip_bias_add: bool = False,
        params_dtype: Optional[torch.dtype] = None,
        reduce_results: bool = True,
        quant_config: Optional[QuantizationConfig] = None,
        prefix: str = &#34;&#34;,
        tp_rank: Optional[int] = None,
        tp_size: Optional[int] = None,
        use_presharded_weights: bool = False,
    ):
        super().__init__(
            input_size, output_size, skip_bias_add, params_dtype, quant_config, prefix
        )

        self.input_is_parallel = input_is_parallel
        self.reduce_results = reduce_results

        # Divide the weight matrix along the last dimension.
        if tp_rank is None:
            tp_rank = get_tensor_model_parallel_rank()
        if tp_size is None:
            tp_size = get_tensor_model_parallel_world_size()
        self.tp_rank, self.tp_size = tp_rank, tp_size
        self.input_size_per_partition = divide(input_size, self.tp_size)
        assert self.quant_method is not None
        self.use_presharded_weights = use_presharded_weights

        self.quant_method.create_weights(
            layer=self,
            input_size_per_partition=self.input_size_per_partition,
            output_partition_sizes=[self.output_size],
            input_size=self.input_size,
            output_size=self.output_size,
            params_dtype=self.params_dtype,
            weight_loader=(
                self.weight_loader_v2
                if self.quant_method.__class__.__name__ in WEIGHT_LOADER_V2_SUPPORTED
                else self.weight_loader
            ),
        )

        if bias:
            self.bias = Parameter(torch.empty(self.output_size, dtype=params_dtype))
            set_weight_attrs(
                self.bias,
                {
                    &#34;output_dim&#34;: 0,
                    &#34;weight_loader&#34;: self.weight_loader,
                },
            )
        else:
            self.register_parameter(&#34;bias&#34;, None)

    def weight_loader(self, param: Parameter, loaded_weight: torch.Tensor):
        input_dim = getattr(param, &#34;input_dim&#34;, None)
        use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)

        # Special case for GGUF
        is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
        is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
        if is_gguf_weight_type:
            param.weight_type = loaded_weight.item()

        # Materialize GGUF UninitializedParameter
        if is_gguf_weight and isinstance(param, UninitializedParameter):
            weight_shape = list(loaded_weight.shape)
            if input_dim:
                weight_shape[input_dim] = weight_shape[input_dim] // self.tp_size
            param.materialize(tuple(weight_shape), dtype=loaded_weight.dtype)

        param_data = param.data
        # bitsandbytes loads the weights of the specific portion
        # no need to narrow here
        if (
            input_dim is not None
            and not use_bitsandbytes_4bit
            and not self.use_presharded_weights
        ):
            shard_size = param_data.shape[input_dim]
            start_idx = self.tp_rank * shard_size

            if _is_cpu:
                from sglang.srt.model_loader.weight_utils import (
                    narrow_padded_param_and_loaded_weight,
                )

                param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                    param_data,
                    loaded_weight,
                    0,  # param_data_start
                    start_idx,
                    input_dim,
                    shard_size,
                )
            else:
                loaded_weight = loaded_weight.narrow(input_dim, start_idx, shard_size)

        # Special case for loading scales off disk, which often do not
        # have a shape (such as in the case of AutoFP8).
        if len(loaded_weight.shape) == 0:
            loaded_weight = loaded_weight.reshape(1)

        assert param_data.shape == loaded_weight.shape
        param_data.copy_(loaded_weight)

    def weight_loader_v2(self, param: BasevLLMParameter, loaded_weight: torch.Tensor):

        # Special case for loading scales off disk, which often do not
        # have a shape (such as in the case of AutoFP8).
        if len(loaded_weight.shape) == 0:
            assert loaded_weight.numel() == 1
            loaded_weight = loaded_weight.reshape(1)

        if isinstance(param, RowvLLMParameter):
            # This `BasevLLMParameter` is defined in sglang/srt/layers/parameter.py,
            # It supports additional parameters like tp_rank and use_presharded_weights.
            param.load_row_parallel_weight(
                loaded_weight,
                tp_rank=self.tp_rank,
                use_presharded_weights=self.use_presharded_weights,
            )
        else:
            # `params` is defined in `vllm/model_executor/parameter.py`,
            # It does not support additional parameters.
            param.load_row_parallel_weight(loaded_weight)

    def forward(self, input_, skip_all_reduce=False):
        if self.input_is_parallel:
            input_parallel = input_
        else:
            splitted_input = split_tensor_along_last_dim(
                input_, num_partitions=self.tp_size
            )
            input_parallel = splitted_input[self.tp_rank].contiguous()

        # Matrix multiply.
        assert self.quant_method is not None
        # Only fuse bias add into GEMM for rank 0 (this ensures that
        # bias will not get added more than once in TP&gt;1 case)
        bias_ = None if (self.tp_rank &gt; 0 or self.skip_bias_add) else self.bias
        with use_symmetric_memory(parallel_state.get_tp_group()) as sm:
            output_parallel = self.quant_method.apply(self, input_parallel, bias=bias_)
            sm.tag(output_parallel)

        if self.reduce_results and self.tp_size &gt; 1 and not skip_all_reduce:
            output = tensor_model_parallel_all_reduce(output_parallel)
        else:
            output = output_parallel

        output_bias = self.bias if self.skip_bias_add else None

        return output, output_bias

    def extra_repr(self) -&gt; str:
        s = f&#34;input_features={self.input_size_per_partition}&#34;
        s += f&#34;, output_features={self.output_size}&#34;
        s += f&#34;, bias={self.bias is not None}&#34;
        s += f&#34;, tp_size={self.tp_size}&#34;
        s += f&#34;, reduce_results={self.reduce_results}&#34;
        return s</code></pre>
</details>
<div class="desc"><p>Linear layer with row parallelism.</p>
<p>The linear layer is defined as Y = XA + b. A is parallelized along
its first dimension and X along its second dimension as:
-
-
| A_1 |
| .
|
A = | .
|
X = [X_1, &hellip;, X_p]
| .
|
| A_p |
-
-</p>
<h2 id="arguments">Arguments</h2>
<p>input_size: first dimension of matrix A.
output_size: second dimension of matrix A.
bias: If true, add bias. Note that bias is not parallelized.
input_is_parallel: If true, we assume that the input is already
split across the GPUs and we do not split
again.
skip_bias_add: This was added to enable performance optimization where
bias can be fused with other element-wise operations.
We skip adding bias but instead return it.
params_dtype: Data type for the parameters.
quant_config: Quantization configure.</p>
<p>Initialize internal Module state, shared by both nn.Module and ScriptModule.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sglang.srt.models.transformers.HFRowParallelLinear" href="../models/transformers.html#sglang.srt.models.transformers.HFRowParallelLinear">HFRowParallelLinear</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.layers.linear.RowParallelLinear.extra_repr"><code class="name flex">
<span>def <span class="ident">extra_repr</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extra_repr(self) -&gt; str:
    s = f&#34;input_features={self.input_size_per_partition}&#34;
    s += f&#34;, output_features={self.output_size}&#34;
    s += f&#34;, bias={self.bias is not None}&#34;
    s += f&#34;, tp_size={self.tp_size}&#34;
    s += f&#34;, reduce_results={self.reduce_results}&#34;
    return s</code></pre>
</details>
<div class="desc"><p>Return the extra representation of the module.</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p></div>
</dd>
<dt id="sglang.srt.layers.linear.RowParallelLinear.weight_loader"><code class="name flex">
<span>def <span class="ident">weight_loader</span></span>(<span>self, param: Parameter, loaded_weight: torch.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader(self, param: Parameter, loaded_weight: torch.Tensor):
    input_dim = getattr(param, &#34;input_dim&#34;, None)
    use_bitsandbytes_4bit = getattr(param, &#34;use_bitsandbytes_4bit&#34;, False)

    # Special case for GGUF
    is_gguf_weight = getattr(param, &#34;is_gguf_weight&#34;, False)
    is_gguf_weight_type = getattr(param, &#34;is_gguf_weight_type&#34;, False)
    if is_gguf_weight_type:
        param.weight_type = loaded_weight.item()

    # Materialize GGUF UninitializedParameter
    if is_gguf_weight and isinstance(param, UninitializedParameter):
        weight_shape = list(loaded_weight.shape)
        if input_dim:
            weight_shape[input_dim] = weight_shape[input_dim] // self.tp_size
        param.materialize(tuple(weight_shape), dtype=loaded_weight.dtype)

    param_data = param.data
    # bitsandbytes loads the weights of the specific portion
    # no need to narrow here
    if (
        input_dim is not None
        and not use_bitsandbytes_4bit
        and not self.use_presharded_weights
    ):
        shard_size = param_data.shape[input_dim]
        start_idx = self.tp_rank * shard_size

        if _is_cpu:
            from sglang.srt.model_loader.weight_utils import (
                narrow_padded_param_and_loaded_weight,
            )

            param_data, loaded_weight = narrow_padded_param_and_loaded_weight(
                param_data,
                loaded_weight,
                0,  # param_data_start
                start_idx,
                input_dim,
                shard_size,
            )
        else:
            loaded_weight = loaded_weight.narrow(input_dim, start_idx, shard_size)

    # Special case for loading scales off disk, which often do not
    # have a shape (such as in the case of AutoFP8).
    if len(loaded_weight.shape) == 0:
        loaded_weight = loaded_weight.reshape(1)

    assert param_data.shape == loaded_weight.shape
    param_data.copy_(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.layers.linear.RowParallelLinear.weight_loader_v2"><code class="name flex">
<span>def <span class="ident">weight_loader_v2</span></span>(<span>self, param: BasevLLMParameter, loaded_weight: torch.Tensor)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_loader_v2(self, param: BasevLLMParameter, loaded_weight: torch.Tensor):

    # Special case for loading scales off disk, which often do not
    # have a shape (such as in the case of AutoFP8).
    if len(loaded_weight.shape) == 0:
        assert loaded_weight.numel() == 1
        loaded_weight = loaded_weight.reshape(1)

    if isinstance(param, RowvLLMParameter):
        # This `BasevLLMParameter` is defined in sglang/srt/layers/parameter.py,
        # It supports additional parameters like tp_rank and use_presharded_weights.
        param.load_row_parallel_weight(
            loaded_weight,
            tp_rank=self.tp_rank,
            use_presharded_weights=self.use_presharded_weights,
        )
    else:
        # `params` is defined in `vllm/model_executor/parameter.py`,
        # It does not support additional parameters.
        param.load_row_parallel_weight(loaded_weight)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.layers.linear.LinearBase.forward" href="#sglang.srt.layers.linear.LinearBase.forward">forward</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.layers" href="index.html">sglang.srt.layers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.adjust_bitsandbytes_4bit_shard" href="#sglang.srt.layers.linear.adjust_bitsandbytes_4bit_shard">adjust_bitsandbytes_4bit_shard</a></code></li>
<li><code><a title="sglang.srt.layers.linear.adjust_marlin_shard" href="#sglang.srt.layers.linear.adjust_marlin_shard">adjust_marlin_shard</a></code></li>
<li><code><a title="sglang.srt.layers.linear.adjust_scalar_to_fused_array" href="#sglang.srt.layers.linear.adjust_scalar_to_fused_array">adjust_scalar_to_fused_array</a></code></li>
<li><code><a title="sglang.srt.layers.linear.adjust_shard_offsets" href="#sglang.srt.layers.linear.adjust_shard_offsets">adjust_shard_offsets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.layers.linear.ColumnParallelLinear" href="#sglang.srt.layers.linear.ColumnParallelLinear">ColumnParallelLinear</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.extra_repr" href="#sglang.srt.layers.linear.ColumnParallelLinear.extra_repr">extra_repr</a></code></li>
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.weight_loader" href="#sglang.srt.layers.linear.ColumnParallelLinear.weight_loader">weight_loader</a></code></li>
<li><code><a title="sglang.srt.layers.linear.ColumnParallelLinear.weight_loader_v2" href="#sglang.srt.layers.linear.ColumnParallelLinear.weight_loader_v2">weight_loader_v2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.layers.linear.LinearBase" href="#sglang.srt.layers.linear.LinearBase">LinearBase</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.LinearBase.forward" href="#sglang.srt.layers.linear.LinearBase.forward">forward</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.layers.linear.MergedColumnParallelLinear" href="#sglang.srt.layers.linear.MergedColumnParallelLinear">MergedColumnParallelLinear</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.MergedColumnParallelLinear.weight_loader" href="#sglang.srt.layers.linear.MergedColumnParallelLinear.weight_loader">weight_loader</a></code></li>
<li><code><a title="sglang.srt.layers.linear.MergedColumnParallelLinear.weight_loader_v2" href="#sglang.srt.layers.linear.MergedColumnParallelLinear.weight_loader_v2">weight_loader_v2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.layers.linear.QKVParallelLinear" href="#sglang.srt.layers.linear.QKVParallelLinear">QKVParallelLinear</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.QKVParallelLinear.weight_loader" href="#sglang.srt.layers.linear.QKVParallelLinear.weight_loader">weight_loader</a></code></li>
<li><code><a title="sglang.srt.layers.linear.QKVParallelLinear.weight_loader_v2" href="#sglang.srt.layers.linear.QKVParallelLinear.weight_loader_v2">weight_loader_v2</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.layers.linear.ReplicatedLinear" href="#sglang.srt.layers.linear.ReplicatedLinear">ReplicatedLinear</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.ReplicatedLinear.extra_repr" href="#sglang.srt.layers.linear.ReplicatedLinear.extra_repr">extra_repr</a></code></li>
<li><code><a title="sglang.srt.layers.linear.ReplicatedLinear.weight_loader" href="#sglang.srt.layers.linear.ReplicatedLinear.weight_loader">weight_loader</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.layers.linear.RowParallelLinear" href="#sglang.srt.layers.linear.RowParallelLinear">RowParallelLinear</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.layers.linear.RowParallelLinear.extra_repr" href="#sglang.srt.layers.linear.RowParallelLinear.extra_repr">extra_repr</a></code></li>
<li><code><a title="sglang.srt.layers.linear.RowParallelLinear.weight_loader" href="#sglang.srt.layers.linear.RowParallelLinear.weight_loader">weight_loader</a></code></li>
<li><code><a title="sglang.srt.layers.linear.RowParallelLinear.weight_loader_v2" href="#sglang.srt.layers.linear.RowParallelLinear.weight_loader_v2">weight_loader_v2</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
