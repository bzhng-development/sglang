<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.managers.scheduler API documentation</title>
<meta name="description" content="A scheduler that manages a tensor parallel GPU worker.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.managers.scheduler</code></h1>
</header>
<section id="section-intro">
<p>A scheduler that manages a tensor parallel GPU worker.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sglang.srt.managers.scheduler.is_health_check_generate_req"><code class="name flex">
<span>def <span class="ident">is_health_check_generate_req</span></span>(<span>recv_req)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_health_check_generate_req(recv_req):
    return getattr(recv_req, &#34;rid&#34;, &#34;&#34;).startswith(&#34;HEALTH_CHECK&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.is_work_request"><code class="name flex">
<span>def <span class="ident">is_work_request</span></span>(<span>recv_req)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_work_request(recv_req):
    return isinstance(
        recv_req,
        (
            TokenizedGenerateReqInput,
            TokenizedEmbeddingReqInput,
            BatchTokenizedGenerateReqInput,
            BatchTokenizedEmbeddingReqInput,
        ),
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.run_scheduler_process"><code class="name flex">
<span>def <span class="ident">run_scheduler_process</span></span>(<span>server_args: <a title="sglang.srt.server_args.ServerArgs" href="../server_args.html#sglang.srt.server_args.ServerArgs">ServerArgs</a>,<br>port_args: <a title="sglang.srt.server_args.PortArgs" href="../server_args.html#sglang.srt.server_args.PortArgs">PortArgs</a>,<br>gpu_id: int,<br>tp_rank: int,<br>moe_ep_rank: int,<br>pp_rank: int,<br>dp_rank: int | None,<br>pipe_writer,<br>balance_meta: <a title="sglang.srt.managers.utils.DPBalanceMeta" href="utils.html#sglang.srt.managers.utils.DPBalanceMeta">DPBalanceMeta</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_scheduler_process(
    server_args: ServerArgs,
    port_args: PortArgs,
    gpu_id: int,
    tp_rank: int,
    moe_ep_rank: int,
    pp_rank: int,
    dp_rank: Optional[int],
    pipe_writer,
    balance_meta: Optional[DPBalanceMeta] = None,
):
    # Generate the prefix
    prefix = &#34;&#34;
    if dp_rank is not None:
        prefix += f&#34; DP{dp_rank}&#34;
    if server_args.tp_size &gt; 1:
        prefix += f&#34; TP{tp_rank}&#34;
    if server_args.ep_size &gt; 1:
        prefix += f&#34; EP{moe_ep_rank}&#34;
    if server_args.pp_size &gt; 1:
        prefix += f&#34; PP{pp_rank}&#34;

    # Config the process
    setproctitle.setproctitle(f&#34;sglang::scheduler{prefix.replace(&#39; &#39;, &#39;_&#39;)}&#34;)
    faulthandler.enable()
    kill_itself_when_parent_died()
    parent_process = psutil.Process().parent()

    # [For Router] if env var &#34;SGLANG_DP_RANK&#34; exist, set dp_rank to the value of the env var
    if dp_rank is None and &#34;SGLANG_DP_RANK&#34; in os.environ:
        dp_rank = int(os.environ[&#34;SGLANG_DP_RANK&#34;])

    # Configure the logger
    configure_logger(server_args, prefix=prefix)
    suppress_other_loggers()

    # Set cpu affinity to this gpu process
    if get_bool_env_var(&#34;SGLANG_SET_CPU_AFFINITY&#34;):
        set_gpu_proc_affinity(server_args.tp_size, server_args.nnodes, gpu_id)

    # Create a scheduler and run the event loop
    try:
        scheduler = Scheduler(
            server_args,
            port_args,
            gpu_id,
            tp_rank,
            moe_ep_rank,
            pp_rank,
            dp_rank,
            dp_balance_meta=balance_meta,
        )
        pipe_writer.send(
            {
                &#34;status&#34;: &#34;ready&#34;,
                &#34;max_total_num_tokens&#34;: scheduler.max_total_num_tokens,
                &#34;max_req_input_len&#34;: scheduler.max_req_input_len,
            }
        )

        disaggregation_mode: DisaggregationMode = scheduler.disaggregation_mode
        if disaggregation_mode == DisaggregationMode.NULL:
            if server_args.pp_size &gt; 1:
                scheduler.event_loop_pp()
            elif scheduler.enable_overlap:
                scheduler.event_loop_overlap()
            else:
                scheduler.event_loop_normal()
        elif disaggregation_mode == DisaggregationMode.PREFILL:
            if scheduler.enable_overlap:
                scheduler.event_loop_overlap_disagg_prefill()
            else:
                if server_args.pp_size &gt; 1:
                    scheduler.event_loop_pp_disagg_prefill()
                else:
                    scheduler.event_loop_normal_disagg_prefill()

        elif disaggregation_mode == DisaggregationMode.DECODE:
            if scheduler.enable_overlap:
                scheduler.event_loop_overlap_disagg_decode()
            else:
                scheduler.event_loop_normal_disagg_decode()

    except Exception:
        traceback = get_exception_traceback()
        logger.error(f&#34;Scheduler hit an exception: {traceback}&#34;)
        parent_process.send_signal(signal.SIGQUIT)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.managers.scheduler.EmbeddingBatchResult"><code class="flex name class">
<span>class <span class="ident">EmbeddingBatchResult</span></span>
<span>(</span><span>embeddings: torch.Tensor, bid: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class EmbeddingBatchResult:
    embeddings: torch.Tensor
    bid: int</code></pre>
</details>
<div class="desc"><p>EmbeddingBatchResult(embeddings: torch.Tensor, bid: int)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sglang.srt.managers.scheduler.EmbeddingBatchResult.bid"><code class="name">var <span class="ident">bid</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.EmbeddingBatchResult.embeddings"><code class="name">var <span class="ident">embeddings</span> : torch.Tensor</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult"><code class="flex name class">
<span>class <span class="ident">GenerationBatchResult</span></span>
<span>(</span><span>logits_output: <a title="sglang.srt.layers.logits_processor.LogitsProcessorOutput" href="../layers/logits_processor.html#sglang.srt.layers.logits_processor.LogitsProcessorOutput">LogitsProcessorOutput</a> | None,<br>pp_hidden_states_proxy_tensors: torch.Tensor | None,<br>next_token_ids: List[int] | None,<br>extend_input_len_per_req: List[int],<br>extend_logprob_start_len_per_req: List[int],<br>bid: int,<br>can_run_cuda_graph: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class GenerationBatchResult:
    logits_output: Optional[LogitsProcessorOutput]
    pp_hidden_states_proxy_tensors: Optional[torch.Tensor]
    next_token_ids: Optional[List[int]]
    extend_input_len_per_req: List[int]
    extend_logprob_start_len_per_req: List[int]
    bid: int
    can_run_cuda_graph: bool</code></pre>
</details>
<div class="desc"><p>GenerationBatchResult(logits_output: Optional[sglang.srt.layers.logits_processor.LogitsProcessorOutput], pp_hidden_states_proxy_tensors: Optional[torch.Tensor], next_token_ids: Optional[List[int]], extend_input_len_per_req: List[int], extend_logprob_start_len_per_req: List[int], bid: int, can_run_cuda_graph: bool)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.bid"><code class="name">var <span class="ident">bid</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.can_run_cuda_graph"><code class="name">var <span class="ident">can_run_cuda_graph</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.extend_input_len_per_req"><code class="name">var <span class="ident">extend_input_len_per_req</span> : List[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.extend_logprob_start_len_per_req"><code class="name">var <span class="ident">extend_logprob_start_len_per_req</span> : List[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.logits_output"><code class="name">var <span class="ident">logits_output</span> : <a title="sglang.srt.layers.logits_processor.LogitsProcessorOutput" href="../layers/logits_processor.html#sglang.srt.layers.logits_processor.LogitsProcessorOutput">LogitsProcessorOutput</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.next_token_ids"><code class="name">var <span class="ident">next_token_ids</span> : List[int] | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.GenerationBatchResult.pp_hidden_states_proxy_tensors"><code class="name">var <span class="ident">pp_hidden_states_proxy_tensors</span> : torch.Tensor | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sglang.srt.managers.scheduler.IdleSleeper"><code class="flex name class">
<span>class <span class="ident">IdleSleeper</span></span>
<span>(</span><span>sockets)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdleSleeper:
    &#34;&#34;&#34;
    In setups which have long inactivity periods it is desirable to reduce
    system power consumption when sglang does nothing. This would lead not only
    to power savings, but also to more CPU thermal headroom when a request
    eventually comes. This is important in cases when multiple GPUs are connected
    as each GPU would otherwise pin one thread at 100% CPU usage.

    The simplest solution is to use zmq.Poller on all sockets that may receive
    data that needs handling immediately.
    &#34;&#34;&#34;

    def __init__(self, sockets):
        self.poller = zmq.Poller()
        self.last_empty_time = time.time()
        for s in sockets:
            self.poller.register(s, zmq.POLLIN)

    def maybe_sleep(self):
        self.poller.poll(1000)
        if (
            global_config.torch_empty_cache_interval &gt; 0
            and time.time() - self.last_empty_time
            &gt; global_config.torch_empty_cache_interval
        ):
            self.last_empty_time = time.time()
            torch.cuda.empty_cache()</code></pre>
</details>
<div class="desc"><p>In setups which have long inactivity periods it is desirable to reduce
system power consumption when sglang does nothing. This would lead not only
to power savings, but also to more CPU thermal headroom when a request
eventually comes. This is important in cases when multiple GPUs are connected
as each GPU would otherwise pin one thread at 100% CPU usage.</p>
<p>The simplest solution is to use zmq.Poller on all sockets that may receive
data that needs handling immediately.</p></div>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.managers.scheduler.IdleSleeper.maybe_sleep"><code class="name flex">
<span>def <span class="ident">maybe_sleep</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maybe_sleep(self):
    self.poller.poll(1000)
    if (
        global_config.torch_empty_cache_interval &gt; 0
        and time.time() - self.last_empty_time
        &gt; global_config.torch_empty_cache_interval
    ):
        self.last_empty_time = time.time()
        torch.cuda.empty_cache()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler"><code class="flex name class">
<span>class <span class="ident">Scheduler</span></span>
<span>(</span><span>server_args: <a title="sglang.srt.server_args.ServerArgs" href="../server_args.html#sglang.srt.server_args.ServerArgs">ServerArgs</a>,<br>port_args: <a title="sglang.srt.server_args.PortArgs" href="../server_args.html#sglang.srt.server_args.PortArgs">PortArgs</a>,<br>gpu_id: int,<br>tp_rank: int,<br>moe_ep_rank: int,<br>pp_rank: int,<br>dp_rank: int | None,<br>dp_balance_meta: <a title="sglang.srt.managers.utils.DPBalanceMeta" href="utils.html#sglang.srt.managers.utils.DPBalanceMeta">DPBalanceMeta</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scheduler(
    SchedulerOutputProcessorMixin,
    SchedulerUpdateWeightsMixin,
    SchedulerProfilerMixin,
    SchedulerMetricsMixin,
    SchedulerDisaggregationDecodeMixin,
    SchedulerDisaggregationPrefillMixin,
):
    &#34;&#34;&#34;A scheduler that manages a tensor parallel GPU worker.&#34;&#34;&#34;

    def __init__(
        self,
        server_args: ServerArgs,
        port_args: PortArgs,
        gpu_id: int,
        tp_rank: int,
        moe_ep_rank: int,
        pp_rank: int,
        dp_rank: Optional[int],
        dp_balance_meta: Optional[DPBalanceMeta] = None,
    ):
        # Parse args
        self.server_args = server_args
        self.tp_rank = tp_rank
        self.moe_ep_rank = moe_ep_rank
        self.pp_rank = pp_rank
        self.dp_rank = dp_rank
        self.tp_size = server_args.tp_size
        self.moe_ep_size = server_args.ep_size
        self.pp_size = server_args.pp_size
        self.dp_size = server_args.dp_size
        self.schedule_policy = server_args.schedule_policy
        self.enable_lora = server_args.enable_lora
        self.max_loras_per_batch = server_args.max_loras_per_batch
        self.enable_overlap = not server_args.disable_overlap_schedule
        self.skip_tokenizer_init = server_args.skip_tokenizer_init
        self.enable_metrics = server_args.enable_metrics
        self.enable_metrics_for_all_schedulers = (
            server_args.enable_metrics_for_all_schedulers
        )
        self.enable_kv_cache_events = server_args.kv_events_config is not None
        self.stream_interval = server_args.stream_interval
        self.spec_algorithm = SpeculativeAlgorithm.from_string(
            server_args.speculative_algorithm
        )
        self.gpu_id = gpu_id
        self.enable_hierarchical_cache = server_args.enable_hierarchical_cache
        self.enable_hicache_storage = server_args.hicache_storage_backend is not None
        self.page_size = server_args.page_size

        self.attn_tp_rank, self.attn_tp_size, self.attn_dp_rank = (
            compute_dp_attention_world_info(
                server_args.enable_dp_attention,
                self.tp_rank,
                self.tp_size,
                self.dp_size,
            )
        )

        # Init model config
        self.model_config = ModelConfig.from_server_args(server_args)

        # Init inter-process communication
        context = zmq.Context(2)
        self.idle_sleeper = None

        if self.pp_rank == 0 and self.attn_tp_rank == 0:
            self.recv_from_tokenizer = get_zmq_socket(
                context, zmq.PULL, port_args.scheduler_input_ipc_name, False
            )
            self.recv_from_rpc = get_zmq_socket(
                context, zmq.DEALER, port_args.rpc_ipc_name, False
            )

            self.send_to_tokenizer = get_zmq_socket(
                context, zmq.PUSH, port_args.tokenizer_ipc_name, False
            )
            if server_args.skip_tokenizer_init:
                # Directly send to the TokenizerManager
                self.send_to_detokenizer = get_zmq_socket(
                    context, zmq.PUSH, port_args.tokenizer_ipc_name, False
                )
            else:
                # Send to the DetokenizerManager
                self.send_to_detokenizer = get_zmq_socket(
                    context, zmq.PUSH, port_args.detokenizer_ipc_name, False
                )

            if self.server_args.sleep_on_idle:
                self.idle_sleeper = IdleSleeper(
                    [
                        self.recv_from_tokenizer,
                        self.recv_from_rpc,
                    ]
                )
        else:
            self.recv_from_tokenizer = None
            self.recv_from_rpc = None
            self.send_to_tokenizer = SimpleNamespace(send_pyobj=lambda x: None)
            self.send_to_detokenizer = SimpleNamespace(send_pyobj=lambda x: None)

        if self.current_scheduler_metrics_enabled():
            self.send_metrics_from_scheduler = get_zmq_socket(
                context, zmq.PUSH, port_args.metrics_ipc_name, False
            )

        # Init tokenizer
        self.init_tokenizer()

        # Init moe config
        self.init_moe_config()

        # Set reasoning_parser and think_end_id if --reasoning_parser is enabled
        if self.server_args.reasoning_parser and self.tokenizer:
            reasoning_parser = ReasoningParser(
                model_type=self.server_args.reasoning_parser, stream_reasoning=False
            )
            self.tokenizer.think_end_id = self.tokenizer.encode(
                reasoning_parser.detector.think_end_token, add_special_tokens=False
            )[0]

        # Check whether overlap can be enabled
        if not self.is_generation:
            self.enable_overlap = False
            logger.info(&#34;Overlap scheduler is disabled for embedding models.&#34;)

        # Launch a tensor parallel worker
        if self.enable_overlap:
            TpWorkerClass = TpModelWorkerClient
        else:
            TpWorkerClass = TpModelWorker

        self.tp_worker = TpWorkerClass(
            server_args=server_args,
            gpu_id=gpu_id,
            tp_rank=tp_rank,
            moe_ep_rank=moe_ep_rank,
            pp_rank=pp_rank,
            dp_rank=dp_rank,
            nccl_port=port_args.nccl_port,
        )

        # Launch a draft worker for speculative decoding
        if self.spec_algorithm.is_eagle():
            from sglang.srt.speculative.eagle_worker import EAGLEWorker

            self.draft_worker = EAGLEWorker(
                gpu_id=gpu_id,
                tp_rank=tp_rank,
                moe_ep_rank=moe_ep_rank,
                server_args=server_args,
                nccl_port=port_args.nccl_port,
                target_worker=self.tp_worker,
                dp_rank=dp_rank,
            )
        else:
            self.draft_worker = None

        # Get token and memory info from the model worker
        (
            self.max_total_num_tokens,
            self.max_prefill_tokens,
            self.max_running_requests,
            self.max_queued_requests,
            self.max_req_len,
            self.max_req_input_len,
            self.random_seed,
            self.device,
            worker_global_server_args_dict,
            _,
            _,
            _,
        ) = self.tp_worker.get_worker_info()
        if global_server_args_dict[&#34;max_micro_batch_size&#34;] is None:
            global_server_args_dict[&#34;max_micro_batch_size&#34;] = max(
                self.max_running_requests // server_args.pp_size, 1
            )

        self.tp_group = self.tp_worker.get_tp_group()
        self.tp_cpu_group = self.tp_group.cpu_group
        self.attn_tp_group = self.tp_worker.get_attention_tp_group()
        self.attn_tp_cpu_group = self.tp_worker.get_attention_tp_cpu_group()
        self.pp_group = get_pp_group()
        self.world_group = get_world_group()

        self.pad_input_ids_func = self.tp_worker.get_pad_input_ids_func()
        global_server_args_dict.update(worker_global_server_args_dict)
        set_random_seed(self.random_seed)

        # Hybrid memory pool
        self.is_hybrid = self.tp_worker.is_hybrid
        if self.is_hybrid:
            self.sliding_window_size = self.tp_worker.sliding_window_size
            self.full_tokens_per_layer, self.swa_tokens_per_layer = (
                self.tp_worker.get_tokens_per_layer_info()
            )

        # Print debug info
        if tp_rank == 0:
            avail_mem = get_available_gpu_memory(
                self.device, self.gpu_id, empty_cache=False
            )
            logger.info(
                f&#34;max_total_num_tokens={self.max_total_num_tokens}, &#34;
                f&#34;chunked_prefill_size={server_args.chunked_prefill_size}, &#34;
                f&#34;max_prefill_tokens={self.max_prefill_tokens}, &#34;
                f&#34;max_running_requests={self.max_running_requests}, &#34;
                f&#34;context_len={self.model_config.context_len}, &#34;
                f&#34;available_gpu_mem={avail_mem:.2f} GB&#34;
            )

        # Init memory pool and cache
        self.init_memory_pool_and_cache()

        # Init running status
        self.waiting_queue: List[Req] = []
        # The running decoding batch for continuous batching
        self.running_batch: ScheduleBatch = ScheduleBatch(reqs=[], batch_is_full=False)
        # The current forward batch
        self.cur_batch: Optional[ScheduleBatch] = None
        # The last forward batch
        self.last_batch: Optional[ScheduleBatch] = None
        self.forward_ct = 0
        self.forward_ct_decode = 0
        self.num_generated_tokens = 0
        self.last_prefill_tokens = 0
        self.last_decode_stats_tic = time.perf_counter()
        self.last_prefill_stats_tic = time.perf_counter()
        self.return_health_check_ct = 0
        self.num_retracted_reqs: int = 0
        self.num_paused_reqs: int = 0
        self.kv_transfer_speed_gb_s: float = 0.0
        self.kv_transfer_latency_ms: float = 0.0
        self.sessions: Dict[str, Session] = {}
        self.current_stream = torch.get_device_module(self.device).current_stream()
        if self.device == &#34;cpu&#34;:
            self.current_stream.synchronize = lambda: None  # No-op for CPU
        self.forward_sleep_time = None

        # Init chunked prefill
        self.chunked_prefill_size = server_args.chunked_prefill_size
        if self.chunked_prefill_size &lt;= 0:  # -1 means disable
            self.chunked_prefill_size = None
        self.chunked_req = None
        self.is_mixed_chunk = (
            self.chunked_prefill_size is not None and server_args.enable_mixed_chunk
        )

        # Init the grammar backend for constrained generation
        self.grammar_queue: List[Req] = []
        if not server_args.skip_tokenizer_init:
            self.grammar_backend = create_grammar_backend(
                server_args,
                self.tokenizer,
                self.model_config.vocab_size,
                self.model_config.hf_eos_token_id,
            )
        else:
            self.grammar_backend = None

        # Init schedule policy and new token estimation
        self.policy = SchedulePolicy(
            self.schedule_policy,
            self.tree_cache,
            self.enable_hierarchical_cache,
        )
        assert (
            server_args.schedule_conservativeness &gt;= 0
        ), &#34;Invalid schedule_conservativeness&#34;
        self.init_new_token_ratio = min(
            global_config.default_init_new_token_ratio
            * server_args.schedule_conservativeness,
            1.0,
        )
        self.min_new_token_ratio = min(
            self.init_new_token_ratio
            * global_config.default_min_new_token_ratio_factor,
            1.0,
        )
        self.new_token_ratio_decay = (
            self.init_new_token_ratio - self.min_new_token_ratio
        ) / global_config.default_new_token_ratio_decay_steps
        self.new_token_ratio = self.init_new_token_ratio

        # Init watchdog thread
        self.watchdog_timeout = server_args.watchdog_timeout
        t = threading.Thread(target=self.watchdog_thread, daemon=True)
        t.start()
        self.parent_process = psutil.Process().parent()

        # Init memory saver, profiler and metric stats
        self.memory_saver_adapter = TorchMemorySaverAdapter.create(
            enable=server_args.enable_memory_saver
        )
        self.offload_tags = set()
        self.init_profier()

        self.recv_skipper = SchedulerRecvSkipper.maybe_create(server_args)
        self.input_blocker = (
            SchedulerInputBlocker(noop=self.attn_tp_rank != 0)
            if get_bool_env_var(&#34;SGLANG_ENABLE_COLOCATED_BATCH_GEN&#34;)
            else None
        )

        # Init metrics stats
        self.init_metrics(tp_rank, pp_rank, dp_rank)
        self.init_kv_events(server_args.kv_events_config)

        # Init disaggregation
        self.disaggregation_mode = DisaggregationMode(
            self.server_args.disaggregation_mode
        )
        self.init_disaggregation()

        if get_bool_env_var(&#34;SGLANG_GC_LOG&#34;):
            configure_gc_logger()

        # Init request dispatcher
        self._request_dispatcher = TypeBasedDispatcher(
            [
                (TokenizedGenerateReqInput, self.handle_generate_request),
                (TokenizedEmbeddingReqInput, self.handle_embedding_request),
                (BatchTokenizedGenerateReqInput, self.handle_batch_generate_request),
                (BatchTokenizedEmbeddingReqInput, self.handle_batch_embedding_request),
                (FlushCacheReqInput, self.flush_cache_wrapped),
                (ClearHiCacheReqInput, self.clear_hicache_storage_wrapped),
                (AbortReq, self.abort_request),
                (OpenSessionReqInput, self.open_session),
                (CloseSessionReqInput, self.close_session),
                (UpdateWeightFromDiskReqInput, self.update_weights_from_disk),
                (InitWeightsUpdateGroupReqInput, self.init_weights_update_group),
                (
                    UpdateWeightsFromDistributedReqInput,
                    self.update_weights_from_distributed,
                ),
                (UpdateWeightsFromTensorReqInput, self.update_weights_from_tensor),
                (GetWeightsByNameReqInput, self.get_weights_by_name),
                (ReleaseMemoryOccupationReqInput, self.release_memory_occupation),
                (ResumeMemoryOccupationReqInput, self.resume_memory_occupation),
                (SlowDownReqInput, self.slow_down),
                (ProfileReq, self.profile),
                (FreezeGCReq, self.handle_freeze_gc),
                (GetInternalStateReq, self.get_internal_state),
                (SetInternalStateReq, self.set_internal_state),
                (RpcReqInput, self.handle_rpc_request),
                (ExpertDistributionReq, self.expert_distribution_handle),
                (LoadLoRAAdapterReqInput, self.load_lora_adapter),
                (UnloadLoRAAdapterReqInput, self.unload_lora_adapter),
            ]
        )

        self.balance_meta = dp_balance_meta
        if (
            server_args.enable_dp_attention
            and server_args.load_balance_method == &#34;minimum_tokens&#34;
        ):
            assert dp_balance_meta is not None

        self.recv_dp_balance_id_this_term = []

    def init_tokenizer(self):
        server_args = self.server_args
        self.is_generation = self.model_config.is_generation

        if server_args.skip_tokenizer_init:
            self.tokenizer = self.processor = None
        else:
            if self.model_config.is_multimodal:
                self.processor = get_processor(
                    server_args.tokenizer_path,
                    tokenizer_mode=server_args.tokenizer_mode,
                    trust_remote_code=server_args.trust_remote_code,
                    revision=server_args.revision,
                    use_fast=not server_args.disable_fast_image_processor,
                )
                self.tokenizer = get_tokenizer_from_processor(self.processor)
            else:
                self.tokenizer = get_tokenizer(
                    server_args.tokenizer_path,
                    tokenizer_mode=server_args.tokenizer_mode,
                    trust_remote_code=server_args.trust_remote_code,
                    revision=server_args.revision,
                )

    def init_memory_pool_and_cache(self):
        server_args = self.server_args

        self.req_to_token_pool, self.token_to_kv_pool_allocator = (
            self.tp_worker.get_memory_pool()
        )

        if (
            server_args.chunked_prefill_size is not None
            and server_args.disable_radix_cache
        ):
            if self.is_hybrid:
                ChunkCacheClass = SWAChunkCache
            else:
                ChunkCacheClass = ChunkCache
            self.tree_cache = ChunkCacheClass(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                page_size=self.page_size,
            )
        else:
            if os.environ.get(&#34;SGLANG_EXPERIMENTAL_CPP_RADIX_TREE&#34;) == &#34;1&#34;:
                # lazy import to avoid JIT overhead
                from sglang.srt.mem_cache.radix_cache_cpp import RadixCacheCpp

                self.tree_cache = RadixCacheCpp(
                    disable=False,
                    use_hicache=self.enable_hierarchical_cache,
                    req_to_token_pool=self.req_to_token_pool,
                    token_to_kv_pool=self.token_to_kv_pool_allocator,
                    tp_cache_group=self.tp_cpu_group,
                    page_size=self.page_size,
                    hicache_ratio=server_args.hicache_ratio,
                    hicache_size=server_args.hicache_size,
                    hicache_write_policy=server_args.hicache_write_policy,
                    enable_kv_cache_events=self.enable_kv_cache_events,
                )
            elif self.enable_hierarchical_cache:
                self.tree_cache = HiRadixCache(
                    req_to_token_pool=self.req_to_token_pool,
                    token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                    tp_cache_group=(
                        self.attn_tp_cpu_group
                        if self.server_args.enable_dp_attention
                        else self.tp_cpu_group
                    ),
                    page_size=self.page_size,
                    hicache_ratio=server_args.hicache_ratio,
                    hicache_size=server_args.hicache_size,
                    hicache_write_policy=server_args.hicache_write_policy,
                    hicache_io_backend=server_args.hicache_io_backend,
                    hicache_mem_layout=server_args.hicache_mem_layout,
                    hicache_storage_backend=server_args.hicache_storage_backend,
                    hicache_storage_prefetch_policy=server_args.hicache_storage_prefetch_policy,
                    model_name=server_args.served_model_name,
                    storage_backend_extra_config=server_args.hicache_storage_backend_extra_config,
                )
                self.tp_worker.register_hicache_layer_transfer_counter(
                    self.tree_cache.cache_controller.layer_done_counter
                )
            elif self.is_hybrid:
                assert (
                    self.server_args.disaggregation_mode == &#34;null&#34;
                ), &#34;Hybrid mode does not support disaggregation yet&#34;
                self.tree_cache = SWARadixCache(
                    req_to_token_pool=self.req_to_token_pool,
                    token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                    sliding_window_size=self.sliding_window_size,
                    page_size=self.page_size,
                    disable=server_args.disable_radix_cache,
                )
            elif self.enable_lora:
                assert (
                    not self.enable_hierarchical_cache
                ), &#34;LoRA radix cache doesn&#39;t support hierarchical cache&#34;
                assert (
                    self.schedule_policy == &#34;fcfs&#34;
                ), &#34;LoRA radix cache only supports FCFS policy&#34;
                self.tree_cache = LoRARadixCache(
                    req_to_token_pool=self.req_to_token_pool,
                    token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                    page_size=self.page_size,
                    disable=server_args.disable_radix_cache,
                )
            else:
                self.tree_cache = RadixCache(
                    req_to_token_pool=self.req_to_token_pool,
                    token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                    page_size=self.page_size,
                    disable=server_args.disable_radix_cache,
                    enable_kv_cache_events=self.enable_kv_cache_events,
                )

        self.decode_mem_cache_buf_multiplier = (
            1
            if self.spec_algorithm.is_none()
            else (
                server_args.speculative_num_draft_tokens
                + (
                    server_args.speculative_eagle_topk
                    * server_args.speculative_num_steps
                )
            )
        )

        embedding_cache_size = int(os.environ.get(&#34;SGLANG_VLM_CACHE_SIZE_MB&#34;, &#34;100&#34;))
        init_embedding_cache(embedding_cache_size * 1024 * 1024)

    def init_disaggregation(self):
        self.transfer_backend = TransferBackend(
            self.server_args.disaggregation_transfer_backend
        )

        if (
            self.disaggregation_mode == DisaggregationMode.DECODE
        ):  # *2 for the headroom.
            buffer_size = (self.req_to_token_pool.size) * 2
            self.req_to_metadata_buffer_idx_allocator = ReqToMetadataIdxAllocator(
                buffer_size
            )
            self.disagg_metadata_buffers = MetadataBuffers(
                buffer_size,
                hidden_size=self.model_config.hf_text_config.hidden_size,
                dtype=self.model_config.dtype,
                custom_mem_pool=self.token_to_kv_pool_allocator.get_kvcache().maybe_get_custom_mem_pool(),
            )

            # The decode requests polling kv cache
            self.disagg_decode_transfer_queue = DecodeTransferQueue(
                gloo_group=self.attn_tp_cpu_group,
                req_to_metadata_buffer_idx_allocator=self.req_to_metadata_buffer_idx_allocator,
                tp_rank=self.tp_rank,
                metadata_buffers=self.disagg_metadata_buffers,
                scheduler=self,
                tree_cache=self.tree_cache,
            )

            # The decode requests pending for pre-allocation
            self.disagg_decode_prealloc_queue = DecodePreallocQueue(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                draft_token_to_kv_pool=(
                    None
                    if self.draft_worker is None
                    else self.draft_worker.model_runner.token_to_kv_pool
                ),
                req_to_metadata_buffer_idx_allocator=self.req_to_metadata_buffer_idx_allocator,
                metadata_buffers=self.disagg_metadata_buffers,
                scheduler=self,
                transfer_queue=self.disagg_decode_transfer_queue,
                tree_cache=self.tree_cache,
                gloo_group=self.attn_tp_cpu_group,
                tp_rank=self.tp_rank,
                tp_size=self.tp_size,
                dp_size=self.server_args.dp_size,
                gpu_id=self.gpu_id,
                bootstrap_port=self.server_args.disaggregation_bootstrap_port,
                max_total_num_tokens=self.max_total_num_tokens,
                prefill_pp_size=self.server_args.disaggregation_prefill_pp,
                num_reserved_decode_tokens=self.server_args.num_reserved_decode_tokens,
                transfer_backend=self.transfer_backend,
            )

        elif self.disaggregation_mode == DisaggregationMode.PREFILL:
            # *2 for the headroom.
            buffer_size = self.max_running_requests * 2
            self.req_to_metadata_buffer_idx_allocator = ReqToMetadataIdxAllocator(
                buffer_size
            )
            self.disagg_metadata_buffers = MetadataBuffers(
                buffer_size,
                hidden_size=self.model_config.hf_text_config.hidden_size,
                dtype=self.model_config.dtype,
                custom_mem_pool=self.token_to_kv_pool_allocator.get_kvcache().maybe_get_custom_mem_pool(),
            )

            self.disagg_prefill_bootstrap_queue = PrefillBootstrapQueue(
                token_to_kv_pool=self.token_to_kv_pool_allocator.get_kvcache(),
                draft_token_to_kv_pool=(
                    None
                    if self.draft_worker is None
                    else self.draft_worker.model_runner.token_to_kv_pool
                ),
                req_to_metadata_buffer_idx_allocator=self.req_to_metadata_buffer_idx_allocator,
                metadata_buffers=self.disagg_metadata_buffers,
                tp_rank=self.tp_rank,
                tp_size=self.tp_size,
                gpu_id=self.gpu_id,
                bootstrap_port=self.server_args.disaggregation_bootstrap_port,
                gloo_group=self.attn_tp_cpu_group,
                max_total_num_tokens=self.max_total_num_tokens,
                decode_tp_size=self.server_args.disaggregation_decode_tp,
                decode_dp_size=self.server_args.disaggregation_decode_dp,
                scheduler=self,
                pp_rank=self.pp_rank,
                pp_size=self.pp_size,
                transfer_backend=self.transfer_backend,
            )
            # The prefill requests that are in the middle of kv sending
            self.disagg_prefill_inflight_queue: List[Req] = []

    def init_moe_config(self):
        if hasattr(self.model_config.hf_config, &#34;num_experts_per_tok&#34;):
            initialize_moe_config(self.server_args)

    @DynamicGradMode()
    def event_loop_normal(self):
        &#34;&#34;&#34;A normal scheduler loop.&#34;&#34;&#34;
        while True:
            recv_reqs = self.recv_requests()
            self.process_input_requests(recv_reqs)

            batch = self.get_next_batch_to_run()
            self.cur_batch = batch

            if batch:
                result = self.run_batch(batch)
                self.process_batch_result(batch, result)
            else:
                # When the server is idle, do self-check and re-init some states
                self.self_check_during_idle()

            self.last_batch = batch

    @DynamicGradMode()
    def event_loop_overlap(self):
        &#34;&#34;&#34;A scheduler loop that overlaps the CPU processing and GPU computation.&#34;&#34;&#34;
        self.result_queue = deque()

        while True:
            recv_reqs = self.recv_requests()
            self.process_input_requests(recv_reqs)

            batch = self.get_next_batch_to_run()
            self.cur_batch = batch

            if batch:
                batch.launch_done = threading.Event()
                result = self.run_batch(batch)
                self.result_queue.append((batch.copy(), result))

                if self.last_batch is None:
                    # Create a dummy first batch to start the pipeline for overlap schedule.
                    # It is now used for triggering the sampling_info_done event.
                    tmp_batch = ScheduleBatch(
                        reqs=None,
                        forward_mode=ForwardMode.DUMMY_FIRST,
                        next_batch_sampling_info=self.tp_worker.cur_sampling_info,
                    )
                    self.process_batch_result(tmp_batch, None, batch.launch_done)

            if self.last_batch:
                # Process the results of the last batch
                tmp_batch, tmp_result = self.result_queue.popleft()
                tmp_batch.next_batch_sampling_info = (
                    self.tp_worker.cur_sampling_info if batch else None
                )
                # NOTE: we should use current launched batch&#39;s launch_done event Instead of the last batch&#39;s
                self.process_batch_result(
                    tmp_batch, tmp_result, batch.launch_done if batch else None
                )
            elif batch is None:
                # When the server is idle, do self-check and re-init some states
                self.self_check_during_idle()

            self.last_batch = batch

    @DynamicGradMode()
    def event_loop_pp(self):
        &#34;&#34;&#34;A non-overlap scheduler loop for pipeline parallelism.&#34;&#34;&#34;
        mbs = [None] * self.pp_size
        last_mbs = [None] * self.pp_size
        self.running_mbs = [
            ScheduleBatch(reqs=[], batch_is_full=False) for _ in range(self.pp_size)
        ]
        bids = [None] * self.pp_size
        pp_outputs: Optional[PPProxyTensors] = None
        while True:
            server_is_idle = True
            for mb_id in range(self.pp_size):
                self.running_batch = self.running_mbs[mb_id]
                self.last_batch = last_mbs[mb_id]

                recv_reqs = self.recv_requests()
                self.process_input_requests(recv_reqs)
                mbs[mb_id] = self.get_next_batch_to_run()
                self.running_mbs[mb_id] = self.running_batch

                self.cur_batch = mbs[mb_id]
                if self.cur_batch:
                    server_is_idle = False
                    result = self.run_batch(self.cur_batch)

                # (last rank) send the outputs to the next step
                if self.pp_group.is_last_rank:
                    if self.cur_batch:
                        next_token_ids, bids[mb_id] = (
                            result.next_token_ids,
                            result.bid,
                        )
                        if self.cur_batch.return_logprob:
                            pp_outputs = PPProxyTensors(
                                {
                                    &#34;next_token_ids&#34;: next_token_ids,
                                    &#34;extend_input_len_per_req&#34;: result.extend_input_len_per_req,
                                    &#34;extend_logprob_start_len_per_req&#34;: result.extend_logprob_start_len_per_req,
                                }
                                | (
                                    {
                                        f&#34;logits_output.{k}&#34;: v
                                        for k, v in result.logits_output.__dict__.items()
                                    }
                                    if result.logits_output is not None
                                    else {}
                                )
                            )
                        else:
                            pp_outputs = PPProxyTensors(
                                {
                                    &#34;next_token_ids&#34;: next_token_ids,
                                }
                            )
                        # send the output from the last round to let the next stage worker run post processing
                        self.pp_group.send_tensor_dict(
                            pp_outputs.tensors,
                            all_gather_group=self.attn_tp_group,
                        )

                # receive outputs and post-process (filter finished reqs) the coming microbatch
                next_mb_id = (mb_id + 1) % self.pp_size
                next_pp_outputs = None
                if mbs[next_mb_id] is not None:
                    next_pp_outputs: Optional[PPProxyTensors] = PPProxyTensors(
                        self.pp_group.recv_tensor_dict(
                            all_gather_group=self.attn_tp_group
                        )
                    )
                    mbs[next_mb_id].output_ids = next_pp_outputs[&#34;next_token_ids&#34;]
                    logits_output_args = {
                        k[len(&#34;logits_output.&#34;) :]: v
                        for k, v in next_pp_outputs.tensors.items()
                        if k.startswith(&#34;logits_output.&#34;)
                    }
                    if len(logits_output_args) &gt; 0:
                        logits_output = LogitsProcessorOutput(**logits_output_args)
                    else:
                        logits_output = None
                    output_result = GenerationBatchResult(
                        logits_output=logits_output,
                        pp_hidden_states_proxy_tensors=None,
                        next_token_ids=next_pp_outputs[&#34;next_token_ids&#34;],
                        extend_input_len_per_req=next_pp_outputs.tensors.get(
                            &#34;extend_input_len_per_req&#34;, None
                        ),
                        extend_logprob_start_len_per_req=next_pp_outputs.tensors.get(
                            &#34;extend_logprob_start_len_per_req&#34;, None
                        ),
                        bid=bids[next_mb_id],
                        can_run_cuda_graph=result.can_run_cuda_graph,
                    )
                    self.process_batch_result(mbs[next_mb_id], output_result)
                    last_mbs[next_mb_id] = mbs[next_mb_id]

                # (not last rank)
                if not self.pp_group.is_last_rank:
                    if self.cur_batch:
                        bids[mb_id] = result.bid
                    # carry the outputs to the next stage
                    # send the outputs from the last round to let the next stage worker run post processing
                    if pp_outputs:
                        self.pp_group.send_tensor_dict(
                            pp_outputs.tensors,
                            all_gather_group=self.attn_tp_group,
                        )

                    # send out reqs to the next stage
                    dp_offset = self.attn_dp_rank * self.attn_tp_size
                    if self.attn_tp_rank == 0:
                        point_to_point_pyobj(
                            recv_reqs,
                            self.pp_rank * self.tp_size + dp_offset,
                            self.world_group.device_group,
                            self.pp_rank * self.tp_size + dp_offset,
                            (self.pp_rank + 1) * self.tp_size + dp_offset,
                        )

                    # send out proxy tensors to the next stage
                    if self.cur_batch:
                        self.pp_group.send_tensor_dict(
                            result.pp_hidden_states_proxy_tensors,
                            all_gather_group=self.attn_tp_group,
                        )

                pp_outputs = next_pp_outputs

            # When the server is idle, self-check and re-init some states
            if server_is_idle:
                # When the server is idle, do self-check and re-init some states
                self.self_check_during_idle()

    def recv_requests(self) -&gt; List[Req]:
        &#34;&#34;&#34;Receive results at tp_rank = 0 and broadcast it to all other TP ranks.&#34;&#34;&#34;

        if self.recv_skipper is not None:
            last_forward_mode = (
                self.last_batch.forward_mode if self.last_batch is not None else None
            )
            if not self.recv_skipper.handle(last_forward_mode):
                return []

        if self.pp_rank == 0:
            if self.attn_tp_rank == 0:
                recv_reqs = []

                while True:
                    try:
                        recv_req = self.recv_from_tokenizer.recv_pyobj(zmq.NOBLOCK)
                    except zmq.ZMQError:
                        break
                    recv_reqs.append(recv_req)

                while True:
                    try:
                        recv_rpc = self.recv_from_rpc.recv_pyobj(zmq.NOBLOCK)
                    except zmq.ZMQError:
                        break
                    recv_reqs.append(recv_rpc)
            else:
                recv_reqs = None
        else:
            if self.attn_tp_rank == 0:
                dp_offset = self.attn_dp_rank * self.attn_tp_size
                recv_reqs = point_to_point_pyobj(
                    [],
                    self.pp_rank * self.tp_size + dp_offset,
                    self.world_group.device_group,
                    (self.pp_rank - 1) * self.tp_size + dp_offset,
                    self.pp_rank * self.tp_size + dp_offset,
                )
            else:
                recv_reqs = None

        if self.input_blocker is not None:
            recv_reqs = self.input_blocker.handle(recv_reqs)

        if self.server_args.enable_dp_attention:
            if self.attn_tp_rank == 0:
                work_reqs = [
                    req
                    for req in recv_reqs
                    if isinstance(
                        req,
                        (
                            TokenizedGenerateReqInput,
                            TokenizedEmbeddingReqInput,
                            BatchTokenizedGenerateReqInput,
                            BatchTokenizedEmbeddingReqInput,
                        ),
                    )
                ]
                control_reqs = [
                    req
                    for req in recv_reqs
                    if not isinstance(
                        req,
                        (
                            TokenizedGenerateReqInput,
                            TokenizedEmbeddingReqInput,
                            BatchTokenizedGenerateReqInput,
                            BatchTokenizedEmbeddingReqInput,
                        ),
                    )
                ]
            else:
                work_reqs = None
                control_reqs = None

            if self.attn_tp_size != 1:
                work_reqs = broadcast_pyobj(
                    work_reqs,
                    self.attn_tp_group.rank,
                    self.attn_tp_cpu_group,
                    src=self.attn_tp_group.ranks[0],
                )
            if self.tp_size != 1:
                control_reqs = broadcast_pyobj(
                    control_reqs,
                    self.tp_group.rank,
                    self.tp_cpu_group,
                    src=self.tp_group.ranks[0],
                )
            recv_reqs = work_reqs + control_reqs
        elif self.tp_size != 1:
            recv_reqs = broadcast_pyobj(
                recv_reqs,
                self.tp_group.rank,
                self.tp_cpu_group,
                src=self.tp_group.ranks[0],
            )
        return recv_reqs

    def process_input_requests(self, recv_reqs: List):
        for recv_req in recv_reqs:
            # If it is a health check generation request and there are running requests, ignore it.
            if is_health_check_generate_req(recv_req) and (
                self.chunked_req is not None
                or not self.running_batch.is_empty()
                or len(self.offload_tags) &gt; 0
            ):
                self.return_health_check_ct += 1
                continue

            # If it is a work request, accept or reject the request based on the request queue size.
            if is_work_request(recv_req):
                if len(self.waiting_queue) + 1 &gt; self.max_queued_requests:
                    abort_req = AbortReq(
                        recv_req.rid,
                        finished_reason={
                            &#34;type&#34;: &#34;abort&#34;,
                            &#34;status_code&#34;: HTTPStatus.SERVICE_UNAVAILABLE,
                            &#34;message&#34;: &#34;The request queue is full.&#34;,
                        },
                    )
                    self.send_to_tokenizer.send_pyobj(abort_req)
                    continue
            output = self._request_dispatcher(recv_req)
            if output is not None:
                if isinstance(output, RpcReqOutput):
                    if self.recv_from_rpc is not None:
                        self.recv_from_rpc.send_pyobj(output)
                else:
                    self.send_to_tokenizer.send_pyobj(output)

    def handle_generate_request(
        self,
        recv_req: TokenizedGenerateReqInput,
    ):
        if (
            self.server_args.enable_dp_attention
            and self.server_args.load_balance_method == &#34;minimum_tokens&#34;
        ):
            self.recv_dp_balance_id_this_term.append(recv_req.dp_balance_id)

        # Create a new request
        if (
            recv_req.session_params is None
            or recv_req.session_params.id is None
            or recv_req.session_params.id not in self.sessions
        ):
            if recv_req.input_embeds is not None:
                # Generate fake input_ids based on the length of input_embeds
                seq_length = len(recv_req.input_embeds)
                fake_input_ids = [1] * seq_length
                recv_req.input_ids = fake_input_ids

            if recv_req.bootstrap_port is None:
                # Use default bootstrap port
                recv_req.bootstrap_port = self.server_args.disaggregation_bootstrap_port

            req = Req(
                recv_req.rid,
                recv_req.input_text,
                recv_req.input_ids,
                recv_req.sampling_params,
                return_logprob=recv_req.return_logprob,
                top_logprobs_num=recv_req.top_logprobs_num,
                token_ids_logprob=recv_req.token_ids_logprob,
                stream=recv_req.stream,
                lora_id=recv_req.lora_id,
                input_embeds=recv_req.input_embeds,
                custom_logit_processor=recv_req.custom_logit_processor,
                return_hidden_states=recv_req.return_hidden_states,
                eos_token_ids=self.model_config.hf_eos_token_id,
                bootstrap_host=recv_req.bootstrap_host,
                bootstrap_port=recv_req.bootstrap_port,
                bootstrap_room=recv_req.bootstrap_room,
                data_parallel_rank=recv_req.data_parallel_rank,
                vocab_size=self.model_config.vocab_size,
            )
            req.tokenizer = self.tokenizer

            if self.disaggregation_mode != DisaggregationMode.NULL:
                # Invalid request for disaggregated mode
                if recv_req.bootstrap_room is None:
                    error_msg = (
                        f&#34;Invalid request: Disaggregated request received without &#34;
                        f&#34;boostrap room id. {req.rid=}&#34;
                    )
                    logger.error(error_msg)
                    prepare_abort(req, error_msg, status_code=HTTPStatus.BAD_REQUEST)
                    self.stream_output([req], req.return_logprob)
                    return

            if (
                recv_req.session_params is not None
                and recv_req.session_params.id is not None
            ):
                req.set_finish_with_abort(
                    f&#34;Invalid request: session id {recv_req.session_params.id} does not exist&#34;
                )
                self._add_request_to_queue(req)
                return
        else:
            # Create a new request from a previous session
            session = self.sessions[recv_req.session_params.id]
            req = session.create_req(recv_req, self.tokenizer)
            if isinstance(req.finished_reason, FINISH_ABORT):
                self._add_request_to_queue(req)
                return

        # Handle multimodal inputs
        if recv_req.mm_inputs is not None:
            image_inputs = MultimodalInputs.from_dict(recv_req.mm_inputs)
            # Expand a single image token into multiple dummy tokens for receiving image embeddings
            req.origin_input_ids = self.pad_input_ids_func(
                req.origin_input_ids, image_inputs
            )
            req.extend_image_inputs(image_inputs)

            if len(req.origin_input_ids) &gt;= self.max_req_input_len:
                req.set_finish_with_abort(
                    error_msg=(
                        &#34;Multimodal prompt is too long after expanding multimodal tokens. &#34;
                        f&#34;After expanding {len(req.origin_input_ids_unpadded)=} =&gt; {len(req.origin_input_ids)} &gt;= {self.max_req_input_len}.&#34;
                    )
                )
                self._add_request_to_queue(req)
                return

        # Validate prompt length
        error_msg = validate_input_length(
            req,
            self.max_req_input_len,
            self.server_args.allow_auto_truncate,
        )
        if error_msg:
            req.set_finish_with_abort(error_msg)
            self._add_request_to_queue(req)
            return

        # Copy more attributes
        if recv_req.logprob_start_len == -1 or not recv_req.return_logprob:
            # By default, only return the logprobs for output tokens
            req.logprob_start_len = len(req.origin_input_ids) - 1
        else:
            req.logprob_start_len = recv_req.logprob_start_len

        if req.logprob_start_len &gt;= len(req.origin_input_ids):
            error_msg = f&#34;{req.logprob_start_len=} is higher than the number of input tokens {len(req.origin_input_ids)=}. Please use a smaller logprob_start_len.&#34;
            req.logprob_start_len = len(req.origin_input_ids) - 1
            req.set_finish_with_abort(error_msg)
            self._add_request_to_queue(req)
            return

        req.sampling_params.max_new_tokens = min(
            (
                req.sampling_params.max_new_tokens
                if req.sampling_params.max_new_tokens is not None
                else 1 &lt;&lt; 30
            ),
            self.max_req_len - len(req.origin_input_ids) - 1,
        )

        # Init grammar cache for this request
        add_to_grammar_queue = False
        if (
            req.sampling_params.json_schema is not None
            or req.sampling_params.regex is not None
            or req.sampling_params.ebnf is not None
            or req.sampling_params.structural_tag is not None
        ):
            assert self.grammar_backend is not None
            if req.sampling_params.json_schema is not None:
                key = (&#34;json&#34;, req.sampling_params.json_schema)
            elif req.sampling_params.regex is not None:
                key = (&#34;regex&#34;, req.sampling_params.regex)
            elif req.sampling_params.ebnf is not None:
                key = (&#34;ebnf&#34;, req.sampling_params.ebnf)
            elif req.sampling_params.structural_tag:
                key = (&#34;structural_tag&#34;, req.sampling_params.structural_tag)

            value, cache_hit = self.grammar_backend.get_cached_or_future_value(key)
            req.grammar = value

            if not cache_hit:
                req.grammar_key = key
                add_to_grammar_queue = True
            else:
                if value is INVALID_GRAMMAR_OBJ:  # We hit a cached invalid grammar.
                    error_msg = f&#34;Invalid grammar request with cache hit: {key=}&#34;
                    req.set_finish_with_abort(error_msg)

        if add_to_grammar_queue:
            req.queue_time_start = time.perf_counter()
            self.grammar_queue.append(req)
        else:
            self._add_request_to_queue(req)

    def handle_batch_generate_request(
        self,
        recv_req: BatchTokenizedGenerateReqInput,
    ):
        &#34;&#34;&#34;Handle optimized batch generate request.&#34;&#34;&#34;
        logger.debug(f&#34;Processing batch generate request with {len(recv_req)} requests&#34;)

        # Process each request in the batch
        for tokenized_req in recv_req:
            self.handle_generate_request(tokenized_req)

    def _add_request_to_queue(self, req: Req):
        req.queue_time_start = time.perf_counter()
        if self.disaggregation_mode == DisaggregationMode.PREFILL:
            self._prefetch_kvcache(req)
            self.disagg_prefill_bootstrap_queue.add(
                req, self.model_config.num_key_value_heads
            )
        elif self.disaggregation_mode == DisaggregationMode.DECODE:
            self.disagg_decode_prealloc_queue.add(req)
        else:
            self._prefetch_kvcache(req)
            self.waiting_queue.append(req)

    def _prefetch_kvcache(self, req: Req):
        if self.enable_hicache_storage:
            req.init_next_round_input(self.tree_cache)
            if req.last_node.backuped:
                # only to initiate the prefetch if the last node is backuped
                # otherwise, the allocated GPU memory must be locked for integrity
                last_hash = req.last_host_node.get_last_hash_value()
                matched_len = len(req.prefix_indices) + req.host_hit_length
                new_input_tokens = req.fill_ids[matched_len:]
                self.tree_cache.prefetch_from_storage(
                    req.rid, req.last_host_node, new_input_tokens, last_hash
                )

    def _extend_requests_to_queue(self, reqs: List[Req], is_retracted: bool = False):
        if self.disaggregation_mode == DisaggregationMode.PREFILL:
            self.disagg_prefill_bootstrap_queue.extend(
                reqs, self.model_config.num_key_value_heads
            )
        elif self.disaggregation_mode == DisaggregationMode.DECODE:
            # If this is a decode server, we put the request to the decode pending prealloc queue
            self.disagg_decode_prealloc_queue.extend(reqs, is_retracted)
        else:
            self.waiting_queue.extend(reqs)

    def handle_embedding_request(
        self,
        recv_req: TokenizedEmbeddingReqInput,
    ):
        req = Req(
            recv_req.rid,
            recv_req.input_text,
            recv_req.input_ids,
            recv_req.sampling_params,
            token_type_ids=recv_req.token_type_ids,
        )
        req.tokenizer = self.tokenizer

        # Handle multimodal inputs
        if recv_req.image_inputs is not None:
            image_inputs = MultimodalInputs.from_dict(recv_req.image_inputs)
            # Expand a single image token into multiple dummy tokens for receiving image embeddings
            req.origin_input_ids = self.pad_input_ids_func(
                req.origin_input_ids, image_inputs
            )
            req.extend_image_inputs(image_inputs)

            if len(req.origin_input_ids) &gt;= self.max_req_input_len:
                req.set_finish_with_abort(
                    error_msg=(
                        &#34;Multimodal prompt is too long after expanding multimodal tokens. &#34;
                        f&#34;After expanding {len(req.origin_input_ids_unpadded)=} =&gt; {len(req.origin_input_ids)} &gt;= {self.max_req_input_len}.&#34;
                    )
                )
                self._add_request_to_queue(req)
                return

        # Validate prompts length
        error_msg = validate_input_length(
            req,
            self.max_req_input_len,
            self.server_args.allow_auto_truncate,
        )
        if error_msg:
            self._add_request_to_queue(req)
            return

        # Copy more attributes
        req.logprob_start_len = len(req.origin_input_ids) - 1
        self._add_request_to_queue(req)

    def handle_batch_embedding_request(
        self,
        recv_req: BatchTokenizedEmbeddingReqInput,
    ):
        &#34;&#34;&#34;Handle optimized batch embedding request.&#34;&#34;&#34;
        logger.debug(
            f&#34;Processing batch embedding request with {len(recv_req)} requests&#34;
        )

        # Process each request in the batch
        for tokenized_req in recv_req:
            self.handle_embedding_request(tokenized_req)

    def self_check_during_idle(self):
        self.check_memory()
        self.check_tree_cache()
        self.new_token_ratio = self.init_new_token_ratio
        self.maybe_sleep_on_idle()

    def check_memory(self):
        if self.is_hybrid:
            (
                full_num_used,
                swa_num_used,
                _,
                _,
                full_available_size,
                full_evictable_size,
                swa_available_size,
                swa_evictable_size,
            ) = self._get_swa_token_info()
            memory_leak = full_num_used != 0 or swa_num_used != 0
            token_msg = (
                f&#34;{self.full_tokens_per_layer=}, {full_available_size=}, {full_evictable_size=}, {self.tree_cache.full_protected_size()=}\n&#34;
                f&#34;{self.swa_tokens_per_layer=}, {swa_available_size=}, {swa_evictable_size=}, {self.tree_cache.swa_protected_size()=}\n&#34;
            )
        else:
            _, _, available_size, evictable_size = self._get_token_info()
            protected_size = self.tree_cache.protected_size()
            memory_leak = (available_size + evictable_size) != (
                self.max_total_num_tokens
                if not self.enable_hierarchical_cache
                else self.max_total_num_tokens - protected_size
            )
            token_msg = f&#34;{self.max_total_num_tokens=}, {available_size=}, {evictable_size=}, {protected_size=}\n&#34;

        if memory_leak:
            msg = &#34;token_to_kv_pool_allocator memory leak detected! &#34; f&#34;{token_msg}&#34;
            raise ValueError(msg)

        if self.disaggregation_mode == DisaggregationMode.DECODE:
            req_total_size = (
                self.req_to_token_pool.size + self.req_to_token_pool.pre_alloc_size
            )
        else:
            req_total_size = self.req_to_token_pool.size

        if len(self.req_to_token_pool.free_slots) != req_total_size:
            msg = (
                &#34;req_to_token_pool memory leak detected!&#34;
                f&#34;available_size={len(self.req_to_token_pool.free_slots)}, &#34;
                f&#34;total_size={self.req_to_token_pool.size}\n&#34;
            )
            raise ValueError(msg)

        if (
            self.enable_metrics
            and self.current_scheduler_metrics_enabled()
            and time.perf_counter() &gt; self.metrics_collector.last_log_time + 30
        ):
            # During idle time, also collect metrics every 30 seconds.
            if self.is_hybrid:
                (
                    full_num_used,
                    swa_num_used,
                    full_token_usage,
                    swa_token_usage,
                    _,
                    _,
                    _,
                    _,
                ) = self._get_swa_token_info()
                num_used = max(full_num_used, swa_num_used)
                token_usage = max(full_token_usage, swa_token_usage)
            else:
                num_used, token_usage, _, _ = self._get_token_info()
            num_running_reqs = len(self.running_batch.reqs)
            self.stats.num_running_reqs = num_running_reqs
            self.stats.num_used_tokens = num_used
            self.stats.token_usage = round(token_usage, 2)
            self.stats.gen_throughput = 0
            self.stats.num_queue_reqs = len(self.waiting_queue)
            self.stats.num_grammar_queue_reqs = len(self.grammar_queue)
            self.metrics_collector.log_stats(self.stats)
        self._publish_kv_events()

    def check_tree_cache(self):
        if self.is_hybrid and isinstance(self.tree_cache, SWARadixCache):
            self.tree_cache.sanity_check()

    def _get_token_info(self):
        available_size = self.token_to_kv_pool_allocator.available_size()
        evictable_size = self.tree_cache.evictable_size()
        num_used = self.max_total_num_tokens - (available_size + evictable_size)
        token_usage = num_used / self.max_total_num_tokens
        return num_used, token_usage, available_size, evictable_size

    def _get_swa_token_info(self):
        full_available_size = self.token_to_kv_pool_allocator.full_available_size()
        full_evictable_size = self.tree_cache.full_evictable_size()
        swa_available_size = self.token_to_kv_pool_allocator.swa_available_size()
        swa_evictable_size = self.tree_cache.swa_evictable_size()
        full_num_used = self.full_tokens_per_layer - (
            full_available_size + full_evictable_size
        )
        swa_num_used = self.swa_tokens_per_layer - (
            swa_available_size + swa_evictable_size
        )
        full_token_usage = full_num_used / self.full_tokens_per_layer
        swa_token_usage = swa_num_used / self.swa_tokens_per_layer
        return (
            full_num_used,
            swa_num_used,
            full_token_usage,
            swa_token_usage,
            full_available_size,
            full_evictable_size,
            swa_available_size,
            swa_evictable_size,
        )

    def get_next_batch_to_run(self) -&gt; Optional[ScheduleBatch]:
        # Merge the prefill batch into the running batch
        chunked_req_to_exclude = set()
        if self.chunked_req:
            # Move the chunked request out of the batch so that we can merge
            # only finished requests to running_batch.
            chunked_req_to_exclude.add(self.chunked_req)
            self.tree_cache.cache_unfinished_req(self.chunked_req, chunked=True)
            # chunked request keeps its rid but will get a new req_pool_idx
            self.req_to_token_pool.free(self.chunked_req.req_pool_idx)
        if self.last_batch and self.last_batch.forward_mode.is_extend():
            if self.last_batch.chunked_req is not None:
                # In the context pipeline parallelism, after the last chunk, the current microbatch still track outdated chunked_req.
                # We need to discard it.
                chunked_req_to_exclude.add(self.last_batch.chunked_req)

            # Filter batch
            last_bs = self.last_batch.batch_size()
            self.last_batch.filter_batch(
                chunked_req_to_exclude=list(chunked_req_to_exclude)
            )
            if self.last_batch.batch_size() &lt; last_bs:
                self.running_batch.batch_is_full = False

            # Merge the new batch into the running batch.
            # For prefill-only batch, we can avoid going through decoding step.
            if not self.last_batch.is_empty() and not self.last_batch.is_prefill_only:
                if self.running_batch.is_empty():
                    self.running_batch = self.last_batch
                else:
                    # Merge running_batch with prefill batch
                    self.running_batch.merge_batch(self.last_batch)

        new_batch = self.get_new_batch_prefill()

        need_dp_attn_preparation = require_mlp_sync(self.server_args)

        if need_dp_attn_preparation and not self.spec_algorithm.is_none():
            # In speculative decoding, prefill batches and decode batches cannot be processed in the same DP attention group.
            # We prepare idle batches in advance to skip preparing decode batches when there are prefill batches in the group.
            new_batch = self.prepare_mlp_sync_batch(new_batch)
            need_dp_attn_preparation = new_batch is None

        if new_batch is not None:
            # Run prefill first if possible
            ret = new_batch
        else:
            # Run decode
            if not self.running_batch.is_empty():
                self.running_batch = self.update_running_batch(self.running_batch)
                ret = self.running_batch if not self.running_batch.is_empty() else None
            else:
                ret = None

        # Handle DP attention
        if need_dp_attn_preparation:
            if (
                self.server_args.load_balance_method == &#34;minimum_tokens&#34;
                and self.forward_ct % 40 == 0
            ):
                self.handle_dp_balance_data(ret)
            ret = self.prepare_mlp_sync_batch(ret)

        return ret

    def get_num_allocatable_reqs(self, running_bs):
        res = global_server_args_dict[&#34;max_micro_batch_size&#34;] - running_bs
        if self.pp_size &gt; 1:
            res = min(res, self.req_to_token_pool.available_size())
        return res

    def get_new_batch_prefill(self) -&gt; Optional[ScheduleBatch]:
        # Check if the grammar is ready in the grammar queue
        if self.grammar_queue:
            self.move_ready_grammar_requests()

        # Handle the cases where prefill is not allowed
        if (
            self.running_batch.batch_is_full or len(self.waiting_queue) == 0
        ) and self.chunked_req is None:
            return None

        running_bs = len(self.running_batch.reqs)
        # Ignore the check if self.chunked_req is not None.
        # In the non-PP case, when self.chunked_req is not None, num_allocatable_reqs should always be greater than 0,
        # as the space for the chunked request has just been released.
        # In PP case, a chunked req can start in one microbatch and end in another microbatch, so the max_running_requests per microbatch should not be strict.
        # Instead, we should always allow chunked request to be added, otherwise, there will be a memory leak.
        if self.get_num_allocatable_reqs(running_bs) &lt;= 0 and not self.chunked_req:
            self.running_batch.batch_is_full = True
            return None

        if self.enable_hierarchical_cache:
            self.tree_cache.check_hicache_events()

        # Get priority queue
        self.policy.calc_priority(self.waiting_queue)

        # Prefill policy
        adder = PrefillAdder(
            self.page_size,
            self.tree_cache,
            self.token_to_kv_pool_allocator,
            self.running_batch,
            self.new_token_ratio,
            self.max_prefill_tokens,
            self.chunked_prefill_size,
            running_bs if self.is_mixed_chunk else 0,
        )

        if self.chunked_req is not None:
            self.chunked_req.init_next_round_input()
            self.chunked_req = adder.add_chunked_req(self.chunked_req)

        if self.enable_lora:
            lora_set = set([req.lora_id for req in self.running_batch.reqs])

        # Get requests from the waiting queue to a new prefill batch
        for req in self.waiting_queue:

            if self.enable_lora and not self.tp_worker.can_run_lora_batch(
                lora_set
                | set([req.lora_id for req in adder.can_run_list])
                | set([req.lora_id])
            ):
                self.running_batch.batch_is_full = True
                break

            if len(adder.can_run_list) &gt;= self.get_num_allocatable_reqs(running_bs):
                self.running_batch.batch_is_full = True
                break

            if self.disaggregation_mode == DisaggregationMode.PREFILL:
                # In prefill mode, prealloc queue and transfer queue can also take memory,
                # so we need to check if the available size for the actual available size.
                if len(adder.can_run_list) &gt;= self.req_to_token_pool.available_size():
                    self.running_batch.batch_is_full = True
                    break

            if self.enable_hicache_storage:
                prefetch_done = self.tree_cache.check_prefetch_progress(req.rid)
                if not prefetch_done:
                    # skip staging requests that are ongoing prefetch
                    continue

            req.init_next_round_input(self.tree_cache)
            res = adder.add_one_req(req, has_chunked_req=(self.chunked_req is not None))

            if res != AddReqResult.CONTINUE:
                if res == AddReqResult.NO_TOKEN:
                    if self.enable_hierarchical_cache:
                        # Set batch_is_full after making sure there are requests that can be served
                        self.running_batch.batch_is_full = len(
                            adder.can_run_list
                        ) &gt; 0 or (not self.running_batch.is_empty())
                    else:
                        self.running_batch.batch_is_full = True
                break

        # Update waiting queue
        can_run_list: List[Req] = adder.can_run_list
        if len(can_run_list) == 0:
            return None

        if self.enable_metrics:
            # only record queue time when enable_metrics is True to avoid overhead
            for req in can_run_list:
                req.queue_time_end = time.perf_counter()

        self.waiting_queue = [
            x for x in self.waiting_queue if x not in set(can_run_list)
        ]

        if adder.new_chunked_req is not None:
            assert self.chunked_req is None
            self.chunked_req = adder.new_chunked_req

        if self.chunked_req:
            self.chunked_req.is_chunked += 1

        # Print stats
        if self.current_scheduler_metrics_enabled():
            self.log_prefill_stats(adder, can_run_list, running_bs)

        # Create a new batch
        new_batch = ScheduleBatch.init_new(
            can_run_list,
            self.req_to_token_pool,
            self.token_to_kv_pool_allocator,
            self.tree_cache,
            self.model_config,
            self.enable_overlap,
            self.spec_algorithm,
            chunked_req=self.chunked_req,
        )
        if self.enable_hierarchical_cache:
            # todo (zhiqiang): disable cuda graph execution if hicache loading triggered
            new_batch.hicache_consumer_index = (
                self.tree_cache.ready_to_load_host_cache()
            )

        new_batch.prepare_for_extend()

        # Mixed-style chunked prefill
        if (
            self.is_mixed_chunk
            and not self.running_batch.is_empty()
            and not (new_batch.return_logprob or self.running_batch.return_logprob)
        ):
            # TODO (lianmin): support return_logprob + mixed chunked prefill
            self.running_batch.filter_batch()
            if not self.running_batch.is_empty():
                self.running_batch.prepare_for_decode()
                new_batch.mix_with_running(self.running_batch)
                new_batch.decoding_reqs = self.running_batch.reqs
            self.running_batch = ScheduleBatch(
                reqs=[], batch_is_full=self.running_batch.batch_is_full
            )
        else:
            new_batch.decoding_reqs = None

        return new_batch

    def update_running_batch(self, batch: ScheduleBatch) -&gt; Optional[ScheduleBatch]:
        &#34;&#34;&#34;Update the current running decoding batch.&#34;&#34;&#34;
        initial_bs = batch.batch_size()

        batch.filter_batch()
        if batch.is_empty():
            batch.batch_is_full = False
            return batch

        # Check if decode out of memory
        if not batch.check_decode_mem(self.decode_mem_cache_buf_multiplier) or (
            TEST_RETRACT and batch.batch_size() &gt; 10
        ):
            old_ratio = self.new_token_ratio

            retracted_reqs, new_token_ratio = batch.retract_decode(self.server_args)
            num_retracted_reqs = len(retracted_reqs)
            self.new_token_ratio = new_token_ratio

            logger.info(
                &#34;KV cache pool is full. Retract requests. &#34;
                f&#34;#retracted_reqs: {num_retracted_reqs}, &#34;
                f&#34;#new_token_ratio: {old_ratio:.4f} -&gt; {self.new_token_ratio:.4f}&#34;
            )

            self._extend_requests_to_queue(retracted_reqs, is_retracted=True)
            self.total_retracted_reqs += num_retracted_reqs
        else:
            self.new_token_ratio = max(
                self.new_token_ratio - self.new_token_ratio_decay,
                self.min_new_token_ratio,
            )

        if batch.batch_size() &lt; initial_bs:
            batch.batch_is_full = False

        # Update batch tensors
        batch.prepare_for_decode()
        return batch

    def run_batch(
        self, batch: ScheduleBatch
    ) -&gt; Union[GenerationBatchResult, EmbeddingBatchResult]:
        &#34;&#34;&#34;Run a batch.&#34;&#34;&#34;
        self.forward_ct += 1

        # Whether to run the profiler
        self._profile_batch_predicate(batch)
        if self.forward_sleep_time is not None:
            logger.info(f&#34;Scheduler.run_batch sleep {self.forward_sleep_time}s&#34;)
            time.sleep(self.forward_sleep_time)

        # Run forward
        if self.is_generation:
            if self.spec_algorithm.is_none():
                model_worker_batch = batch.get_model_worker_batch()

                # update the consumer index of hicache to the running batch
                self.tp_worker.set_hicache_consumer(
                    model_worker_batch.hicache_consumer_index
                )
                if self.pp_group.is_last_rank:
                    logits_output, next_token_ids, can_run_cuda_graph = (
                        self.tp_worker.forward_batch_generation(model_worker_batch)
                    )
                else:
                    pp_hidden_states_proxy_tensors, _, can_run_cuda_graph = (
                        self.tp_worker.forward_batch_generation(model_worker_batch)
                    )
                bid = model_worker_batch.bid
            else:
                (
                    logits_output,
                    next_token_ids,
                    bid,
                    num_accepted_tokens,
                    can_run_cuda_graph,
                ) = self.draft_worker.forward_batch_speculative_generation(batch)
                bs = batch.batch_size()
                self.spec_num_total_accepted_tokens += num_accepted_tokens + bs
                self.spec_num_total_forward_ct += bs
                self.num_generated_tokens += num_accepted_tokens

            if self.pp_group.is_last_rank:
                batch.output_ids = next_token_ids

            # These 2 values are needed for processing the output, but the values can be
            # modified by overlap schedule. So we have to copy them here so that
            # we can use the correct values in output processing.
            if batch.return_logprob or self.spec_algorithm.is_eagle():
                extend_input_len_per_req = [req.extend_input_len for req in batch.reqs]
            else:
                extend_input_len_per_req = None
            if batch.return_logprob:
                extend_logprob_start_len_per_req = [
                    req.extend_logprob_start_len for req in batch.reqs
                ]
            else:
                extend_logprob_start_len_per_req = None

            ret = GenerationBatchResult(
                logits_output=logits_output if self.pp_group.is_last_rank else None,
                pp_hidden_states_proxy_tensors=(
                    pp_hidden_states_proxy_tensors
                    if not self.pp_group.is_last_rank
                    else None
                ),
                next_token_ids=next_token_ids if self.pp_group.is_last_rank else None,
                extend_input_len_per_req=extend_input_len_per_req,
                extend_logprob_start_len_per_req=extend_logprob_start_len_per_req,
                bid=bid,
                can_run_cuda_graph=can_run_cuda_graph,
            )
        else:  # embedding or reward model
            model_worker_batch = batch.get_model_worker_batch()
            embeddings = self.tp_worker.forward_batch_embedding(model_worker_batch)
            ret = EmbeddingBatchResult(
                embeddings=embeddings, bid=model_worker_batch.bid
            )
        return ret

    def process_batch_result(
        self,
        batch: ScheduleBatch,
        result: Union[GenerationBatchResult, EmbeddingBatchResult],
        launch_done: Optional[threading.Event] = None,
    ):
        if batch.forward_mode.is_decode():
            self.process_batch_result_decode(batch, result, launch_done)
        elif batch.forward_mode.is_extend():
            self.process_batch_result_prefill(batch, result, launch_done)
        elif batch.forward_mode.is_idle():
            if self.enable_overlap:
                self.tp_worker.resolve_last_batch_result(launch_done)
                self.set_next_batch_sampling_info_done(batch)
        elif batch.forward_mode.is_dummy_first():
            self.set_next_batch_sampling_info_done(batch)

        self.maybe_send_health_check_signal()

    def maybe_send_health_check_signal(self):
        if self.return_health_check_ct:
            # Return some signal for the health check.
            # This is used to prevent the health check signal being blocked by long context prefill.
            # However, one minor issue is that this code path does not check the status of detokenizer manager.
            self.return_health_check_ct -= 1
            self.send_to_tokenizer.send_pyobj(HealthCheckOutput())

    def prepare_mlp_sync_batch(self, local_batch: ScheduleBatch):
        return self.prepare_mlp_sync_batch_raw(
            local_batch,
            dp_size=self.server_args.dp_size,
            attn_tp_size=self.attn_tp_size,
            tp_group=self.tp_group,
            get_idle_batch=self.get_idle_batch,
            disable_cuda_graph=self.server_args.disable_cuda_graph,
            spec_algorithm=self.spec_algorithm,
            speculative_num_draft_tokens=self.server_args.speculative_num_draft_tokens,
            require_mlp_tp_gather=require_mlp_tp_gather(self.server_args),
            disable_overlap_schedule=self.server_args.disable_overlap_schedule,
        )

    def handle_dp_balance_data(self, local_batch: ScheduleBatch):
        def gather_dp_balance_info(holding_tokens_list) -&gt; Union[None, List[List[int]]]:
            &#34;&#34;&#34;gather recv_dp_balance_id_this_term and holding tokens per worker for dp balance&#34;&#34;&#34;
            recv_list = self.recv_dp_balance_id_this_term
            assert len(recv_list) &lt;= 511, (
                &#34;The number of requests received this round is too large. &#34;
                &#34;Please increase gather_tensor_size and onfly_info_size.&#34;
            )
            # The maximum size of the tensor used for gathering data from all workers.
            gather_tensor_size = 512

            # recv_tensor: | holding_tokens | len(recv_dp_balance_id) | recv_dp_balance_ids
            recv_tensor = torch.zeros(gather_tensor_size, dtype=torch.int32)
            recv_tensor[0] = holding_tokens_list
            recv_tensor[1] = len(
                recv_list
            )  # The first element is the length of the list.
            recv_tensor[2 : len(recv_list) + 2] = torch.tensor(
                recv_list, dtype=torch.int32
            )

            if self.tp_rank == 0:
                gathered_list = [
                    torch.zeros(gather_tensor_size, dtype=torch.int32)
                    for _ in range(self.balance_meta.num_workers)
                ]
            else:
                gathered_list = None

            torch.distributed.gather(
                recv_tensor, gathered_list, group=self.tp_cpu_group
            )

            gathered_id_list_per_worker = None
            if self.tp_rank == 0:
                gathered_id_list_per_worker = []
                holding_tokens_list = []
                for tensor in gathered_list:
                    holding_tokens_list.append(tensor[0].item())
                    list_length = tensor[1].item()
                    gathered_id_list_per_worker.append(
                        tensor[2 : list_length + 2].tolist()
                    )

            return gathered_id_list_per_worker, holding_tokens_list

        def write_shared_dp_balance_info(new_recv_rid_lists, local_tokens):
            meta = self.balance_meta

            with meta.mutex:
                onfly_list: List[Dict[int, int]] = meta.get_shared_onfly()
                assert len(new_recv_rid_lists) == len(
                    onfly_list
                ), &#34;num_worker not equal&#34;
                # 1.Check if the rid received by each worker this round is present in onfly.
                #   If it is, remove the corresponding onfly item.
                worker_id = 0
                for new_recv_rids, on_fly_reqs in zip(new_recv_rid_lists, onfly_list):
                    for new_recv_rid in new_recv_rids:
                        assert (
                            new_recv_rid in on_fly_reqs
                        ), f&#34;{new_recv_rid=} not in {worker_id=} {on_fly_reqs=}, data consistency is wrong&#34;
                        del on_fly_reqs[new_recv_rid]
                    worker_id += 1
                # 2. Atomically write local_tokens and onfly into shm under the mutex
                meta.set_shared_onfly_info(onfly_list)
                meta.set_shared_local_tokens(local_tokens)

        holding_tokens = self.get_load()

        new_recv_dp_balance_id_list, holding_token_list = gather_dp_balance_info(
            holding_tokens
        )

        self.recv_dp_balance_id_this_term.clear()
        if self.tp_rank == 0:  # only first worker write info
            write_shared_dp_balance_info(
                new_recv_dp_balance_id_list, holding_token_list
            )

    @staticmethod
    def prepare_mlp_sync_batch_raw(
        local_batch: ScheduleBatch,
        dp_size,
        attn_tp_size: int,
        tp_group,
        get_idle_batch,
        disable_cuda_graph: bool,
        spec_algorithm,
        speculative_num_draft_tokens,
        require_mlp_tp_gather: bool,
        disable_overlap_schedule: bool,
    ):
        # Check if other DP workers have running batches
        if local_batch is None:
            num_tokens = 0
            num_tokens_for_logprob = 0
        elif local_batch.forward_mode.is_decode():
            num_tokens = local_batch.batch_size()
            num_tokens_for_logprob = num_tokens
        else:
            num_tokens = local_batch.extend_num_tokens
            num_tokens_for_logprob = sum(
                [
                    # We should have at least 1 token for sample in every case.
                    max(extend_len - logprob_start_len, 1)
                    for logprob_start_len, extend_len in zip(
                        local_batch.extend_logprob_start_lens, local_batch.extend_lens
                    )
                ]
            )

        if local_batch is None or local_batch.forward_mode.is_decode_or_idle():
            can_cuda_graph = 1
        else:
            can_cuda_graph = 0

        is_extend_in_batch = (
            local_batch.forward_mode.is_extend() if local_batch else False
        )

        tbo_preparer = TboDPAttentionPreparer()
        if disable_overlap_schedule:
            group = tp_group.device_group
            device = tp_group.device
        else:
            group = tp_group.cpu_group
            device = &#34;cpu&#34;

        local_info = torch.tensor(
            [
                num_tokens,
                can_cuda_graph,
                num_tokens_for_logprob,
                is_extend_in_batch,
                *tbo_preparer.prepare_all_gather(
                    local_batch,
                ),
            ],
            dtype=torch.int64,
            device=device,
        )
        global_info = torch.empty(
            (dp_size, attn_tp_size, 6),
            dtype=torch.int64,
            device=device,
        )
        torch.distributed.all_gather_into_tensor(
            global_info.flatten(),
            local_info,
            group=group,
        )
        global_num_tokens = global_info[:, 0, 0].tolist()
        can_cuda_graph = min(global_info[:, 0, 1].tolist())
        global_num_tokens_for_logprob = global_info[:, 0, 2].tolist()
        is_extend_in_batch = global_info[:, 0, 3].tolist()

        tbo_split_seq_index, global_forward_mode = tbo_preparer.compute_output(
            global_info[:, :, 4:6]
        )

        if local_batch is None and max(global_num_tokens) &gt; 0:
            local_batch = get_idle_batch()

        if local_batch is not None:
            # TODO: handle the case when moe_dense_tp_size != 1
            if not require_mlp_tp_gather:
                local_batch.global_num_tokens = [num_tokens]
                local_batch.global_num_tokens_for_logprob = [num_tokens_for_logprob]
            else:
                local_batch.global_num_tokens = global_num_tokens
                local_batch.global_num_tokens_for_logprob = (
                    global_num_tokens_for_logprob
                )
            local_batch.is_extend_in_batch = any(is_extend_in_batch)
            local_batch.tbo_split_seq_index = tbo_split_seq_index
            local_batch.global_forward_mode = global_forward_mode

            # Check forward mode for cuda graph
            if not disable_cuda_graph:
                local_batch.can_run_dp_cuda_graph = can_cuda_graph

        return local_batch

    def get_idle_batch(self):
        idle_batch = ScheduleBatch.init_new(
            [],
            self.req_to_token_pool,
            self.token_to_kv_pool_allocator,
            self.tree_cache,
            self.model_config,
            self.enable_overlap,
            self.spec_algorithm,
        )
        idle_batch.prepare_for_idle()
        return idle_batch

    def move_ready_grammar_requests(self):
        &#34;&#34;&#34;Move requests whose grammar objects are ready from grammar_queue to waiting_queue.&#34;&#34;&#34;

        num_ready_reqs = 0
        num_timeout_reqs = 0
        for req in self.grammar_queue:
            try:
                if req.finished():  # It is aborted by AbortReq
                    num_ready_reqs += 1
                    continue
                req.grammar = req.grammar.result(timeout=0.03)
                self.grammar_backend.set_cache(req.grammar_key, req.grammar.copy())
                if req.grammar is INVALID_GRAMMAR_OBJ:
                    req.set_finish_with_abort(
                        f&#34;Invalid grammar request: {req.grammar_key=}&#34;
                    )
                num_ready_reqs += 1
            except futures._base.TimeoutError:
                req.grammar_wait_ct += 1
                # NOTE(lianmin): this timeout is the waiting time of the above line. It is
                # not the waiting time from it enters the grammar queue.
                if req.grammar_wait_ct &gt; GRAMMAR_TIMEOUT / 0.03:
                    num_timeout_reqs = 1
                break

        if self.server_args.enable_dp_attention:
            tp_size = self.attn_tp_size
            tp_group = self.attn_tp_cpu_group
        else:
            tp_size = self.tp_size
            tp_group = self.tp_cpu_group

        if tp_size &gt; 1:
            # Sync across TP ranks to make sure they have the same number of ready requests
            tensor = torch.tensor([num_ready_reqs, num_timeout_reqs], dtype=torch.int32)
            torch.distributed.all_reduce(
                tensor, op=torch.distributed.ReduceOp.MAX, group=tp_group
            )
            num_ready_reqs_max, num_timeout_reqs_max = tensor.tolist()

            for i in range(num_ready_reqs, num_ready_reqs_max):
                req = self.grammar_queue[i]
                if req.finished():  # It is aborted by AbortReq
                    continue
                req.grammar = req.grammar.result()
                self.grammar_backend.set_cache(req.grammar_key, req.grammar.copy())
                if req.grammar is INVALID_GRAMMAR_OBJ:
                    req.set_finish_with_abort(
                        f&#34;Invalid grammar request: {req.grammar_key=}&#34;
                    )
        else:
            num_ready_reqs_max = num_ready_reqs
            num_timeout_reqs_max = num_timeout_reqs

        for i in range(num_ready_reqs, num_ready_reqs + num_timeout_reqs_max):
            req = self.grammar_queue[i]
            req.grammar.cancel()
            error_msg = f&#34;Grammar preprocessing timed out for {req.grammar_key=}&#34;
            req.set_finish_with_abort(error_msg)
            self.grammar_backend.set_cache(req.grammar_key, INVALID_GRAMMAR_OBJ)
        num_ready_reqs = num_ready_reqs_max + num_timeout_reqs_max

        self._extend_requests_to_queue(self.grammar_queue[:num_ready_reqs])
        self.grammar_queue = self.grammar_queue[num_ready_reqs:]

    def set_next_batch_sampling_info_done(self, batch: ScheduleBatch):
        if batch.next_batch_sampling_info:
            if batch.next_batch_sampling_info.grammars is not None:
                batch.next_batch_sampling_info.update_regex_vocab_mask()
                self.current_stream.synchronize()
            batch.next_batch_sampling_info.sampling_info_done.set()

    def watchdog_thread(self):
        &#34;&#34;&#34;A watch dog thread that will try to kill the server itself if one forward batch takes too long.&#34;&#34;&#34;
        self.watchdog_last_forward_ct = 0
        self.watchdog_last_time = time.perf_counter()

        while True:
            current = time.perf_counter()
            if self.cur_batch is not None:
                if self.watchdog_last_forward_ct == self.forward_ct:
                    if current &gt; self.watchdog_last_time + self.watchdog_timeout:
                        break
                else:
                    self.watchdog_last_forward_ct = self.forward_ct
                    self.watchdog_last_time = current
            time.sleep(self.watchdog_timeout // 2)

        if not disable_request_logging():
            # Print batch size and memory pool info to check whether there are de-sync issues.
            if self.is_hybrid:
                (
                    _,
                    _,
                    _,
                    _,
                    full_available_size,
                    full_evictable_size,
                    swa_available_size,
                    swa_evictable_size,
                ) = self._get_swa_token_info()
                info_msg = (
                    f&#34;{full_available_size=}, &#34;
                    f&#34;{full_evictable_size=}, &#34;
                    f&#34;{swa_available_size=}, &#34;
                    f&#34;{swa_evictable_size=}, &#34;
                )
            else:
                _, _, available_size, evictable_size = self._get_token_info()
                info_msg = f&#34;{available_size=}, &#34; f&#34;{evictable_size=}, &#34;
            logger.error(
                f&#34;{self.cur_batch.batch_size()=}, &#34;
                f&#34;{self.cur_batch.reqs=}, &#34;
                f&#34;{info_msg}&#34;
            )

        pyspy_dump_schedulers()
        logger.error(f&#34;Watchdog timeout ({self.watchdog_timeout=})&#34;)
        print(file=sys.stderr, flush=True)
        print(file=sys.stdout, flush=True)

        # Wait for some time so that the parent process can print the error.
        time.sleep(5)
        self.parent_process.send_signal(signal.SIGQUIT)

    def flush_cache_wrapped(self, recv_req: FlushCacheReqInput):
        success = self.flush_cache()
        return FlushCacheReqOutput(success=success)

    def clear_hicache_storage_wrapped(self, recv_req: ClearHiCacheReqInput):
        if self.enable_hierarchical_cache:
            self.tree_cache.clear_storage_backend()
            logger.info(&#34;Hierarchical cache cleared successfully!&#34;)
            if_success = True
        else:
            logging.warning(&#34;Hierarchical cache is not enabled.&#34;)
            if_success = False
        return ClearHiCacheReqOutput(success=if_success)

    def flush_cache(self):
        &#34;&#34;&#34;Flush the memory pool and cache.&#34;&#34;&#34;
        if (
            len(self.waiting_queue) == 0
            and self.running_batch.is_empty()
            and (self.pp_size == 1 or all(x.is_empty() for x in self.running_mbs))
        ):
            self.cur_batch = None
            self.last_batch = None
            self.tree_cache.reset()
            if self.grammar_backend:
                self.grammar_backend.reset()
            self.req_to_token_pool.clear()
            self.token_to_kv_pool_allocator.clear()

            if not self.spec_algorithm.is_none():
                self.draft_worker.model_runner.req_to_token_pool.clear()
                self.draft_worker.model_runner.token_to_kv_pool_allocator.clear()

            self.num_generated_tokens = 0
            self.forward_ct_decode = 0
            self.spec_num_total_accepted_tokens = 0
            self.spec_num_total_forward_ct = 0
            self.cum_spec_accept_length = 0
            self.cum_spec_accept_count = 0
            torch.cuda.empty_cache()
            logger.info(&#34;Cache flushed successfully!&#34;)
            if_success = True
        else:
            logging.warning(
                f&#34;Cache not flushed because there are pending requests. &#34;
                f&#34;#queue-req: {len(self.waiting_queue)}, &#34;
                f&#34;#running-req: {len(self.running_batch.reqs)}&#34;
            )
            if_success = False
        return if_success

    def get_load(self):
        # TODO(lsyin): use dynamically maintained num_waiting_tokens
        if self.is_hybrid:
            load_full = (
                self.full_tokens_per_layer
                - self.token_to_kv_pool_allocator.full_available_size()
                - self.tree_cache.full_evictable_size()
            )
            load_swa = (
                self.swa_tokens_per_layer
                - self.token_to_kv_pool_allocator.swa_available_size()
                - self.tree_cache.swa_evictable_size()
            )
            load = max(load_full, load_swa)
        else:
            load = (
                self.max_total_num_tokens
                - self.token_to_kv_pool_allocator.available_size()
                - self.tree_cache.evictable_size()
            )
        load += sum(len(req.origin_input_ids) for req in self.waiting_queue)
        if self.disaggregation_mode == DisaggregationMode.PREFILL:
            load += sum(
                len(req.origin_input_ids)
                for req in self.disagg_prefill_bootstrap_queue.queue
            )
        elif self.disaggregation_mode == DisaggregationMode.DECODE:
            load += sum(
                len(req.req.origin_input_ids)
                for req in self.disagg_decode_prealloc_queue.queue
            )

        return load

    def get_internal_state(self, recv_req: GetInternalStateReq):
        ret = dict(global_server_args_dict)
        ret[&#34;last_gen_throughput&#34;] = self.last_gen_throughput
        ret[&#34;memory_usage&#34;] = {
            &#34;weight&#34;: round(
                self.tp_worker.worker.model_runner.weight_load_mem_usage, 2
            ),
            &#34;kvcache&#34;: round(
                self.token_to_kv_pool_allocator.get_kvcache().mem_usage, 2
            ),
            &#34;token_capacity&#34;: int(self.max_total_num_tokens),
        }

        if not _is_cpu:
            ret[&#34;memory_usage&#34;][&#34;cuda_graph&#34;] = round(
                self.tp_worker.worker.model_runner.cuda_graph_mem_usage, 2
            )

        if not self.spec_algorithm.is_none() and self.cum_spec_accept_count &gt; 0:
            ret[&#34;avg_spec_accept_length&#34;] = (
                self.cum_spec_accept_length / self.cum_spec_accept_count
            )
        if RECORD_STEP_TIME:
            ret[&#34;step_time_dict&#34;] = self.step_time_dict

        ret[&#34;load&#34;] = self.get_load()

        return GetInternalStateReqOutput(internal_state=ret)

    def set_internal_state(self, recv_req: SetInternalStateReq):
        server_args_dict = recv_req.server_args
        args_allow_update = set(
            [
                &#34;max_micro_batch_size&#34;,
                &#34;speculative_accept_threshold_single&#34;,
                &#34;speculative_accept_threshold_acc&#34;,
            ]
        )
        if_success = True
        for k, v in server_args_dict.items():
            if k not in args_allow_update:
                logging.warning(f&#34;Updating {k} is not supported.&#34;)
                if_success = False
                break
            elif k == &#34;max_micro_batch_size&#34; and (
                v &gt; self.max_running_requests // self.pp_size or v &lt; 1
            ):
                logging.warning(
                    f&#34;Updating {k} to {v} is rejected because it is out of the valid range [1, {self.max_running_requests // self.pp_size}].&#34;
                )
                if_success = False
                break
        if if_success:
            if not self.spec_algorithm.is_none() and self.cum_spec_accept_count &gt; 0:
                avg_spec_accept_length = (
                    self.cum_spec_accept_length / self.cum_spec_accept_count
                )
                logger.info(f&#34;{avg_spec_accept_length=}&#34;)
            self.cum_spec_accept_length = self.cum_spec_accept_count = 0
            for k, v in server_args_dict.items():
                global_server_args_dict[k] = v
            logger.info(f&#34;Global server args updated! {global_server_args_dict=}&#34;)
        return SetInternalStateReqOutput(
            updated=True,
            server_args=global_server_args_dict,
        )

    def handle_rpc_request(self, recv_req: RpcReqInput):
        # Handle RPC requests
        logger.info(
            f&#34;handle_rpc_request: {recv_req.method}, param: {recv_req.parameters}&#34;
        )

        success = True
        exec = None
        try:
            func = getattr(self, recv_req.method)
            func(recv_req.parameters)
        except Exception as e:
            success = False
            exec = e
            logger.error(f&#34;Failed to call rpc {recv_req.method}: {str(e)}&#34;)

        barrier()
        return RpcReqOutput(success, &#34;&#34; if not exec else str(exec))

    def abort_request(self, recv_req: AbortReq):
        # Delete requests in the waiting queue
        to_del = []
        for i, req in enumerate(self.waiting_queue):
            if recv_req.abort_all or req.rid.startswith(recv_req.rid):
                to_del.append(i)

        # Sort in reverse order to avoid index issues when deleting
        for i in reversed(to_del):
            # Abort method 1: directly pop from the queue
            # This only works for requests that have not started anything.
            # We still need to send something back to TokenizerManager to clean up the state.
            req = self.waiting_queue.pop(i)
            self.send_to_tokenizer.send_pyobj(AbortReq(req.rid))
            # For disaggregation decode mode, the request in the waiting queue has KV cache allocated.
            if self.disaggregation_mode == DisaggregationMode.DECODE:
                self.tree_cache.cache_finished_req(req)

            logger.debug(f&#34;Abort queued request. {req.rid=}&#34;)

        # Delete the requests in the grammar queue
        for req in self.grammar_queue:
            # Abort method 2: call `set_finish_with_abort`
            # The request will still run one prefill forward pass.
            # In this case, we change the input_ids to be only one token to make this prefill cheap.
            if recv_req.abort_all or req.rid.startswith(recv_req.rid):
                logger.debug(f&#34;Abort grammar queue request. {req.rid=}&#34;)
                if req.grammar:
                    req.grammar.cancel()
                req.set_finish_with_abort(&#34;Aborted by AbortReq.&#34;)

        # Delete requests not in the waiting queue when PD disaggregation is enabled
        if self.disaggregation_mode == DisaggregationMode.PREFILL:
            # Abort requests that have not yet been bootstrapped
            for i, req in enumerate(self.disagg_prefill_bootstrap_queue.queue):
                logger.debug(f&#34;Abort bootstrap queue request. {req.rid=}&#34;)
                if recv_req.abort_all or req.rid.startswith(recv_req.rid):
                    if hasattr(req.disagg_kv_sender, &#34;abort&#34;):
                        req.disagg_kv_sender.abort()

            # Abort in-flight requests
            for i, req in enumerate(self.disagg_prefill_inflight_queue):
                logger.debug(f&#34;Abort inflight queue request. {req.rid=}&#34;)
                if recv_req.abort_all or req.rid.startswith(recv_req.rid):
                    if hasattr(req.disagg_kv_sender, &#34;abort&#34;):
                        req.disagg_kv_sender.abort()

        elif self.disaggregation_mode == DisaggregationMode.DECODE:
            # Abort requests that have not yet finished preallocation
            for i, decode_req in enumerate(self.disagg_decode_prealloc_queue.queue):
                logger.debug(f&#34;Abort prealloc queue request. {decode_req.req.rid=}&#34;)
                if recv_req.abort_all or decode_req.req.rid.startswith(recv_req.rid):
                    if hasattr(decode_req.kv_receiver, &#34;abort&#34;):
                        decode_req.kv_receiver.abort()

            # Abort requests waiting for kvcache to release tree cache
            for i, decode_req in enumerate(self.disagg_decode_transfer_queue.queue):
                logger.debug(f&#34;Abort transfer queue request. {decode_req.req.rid=}&#34;)
                if recv_req.abort_all or decode_req.req.rid.startswith(recv_req.rid):
                    if hasattr(decode_req.kv_receiver, &#34;abort&#34;):
                        decode_req.kv_receiver.abort()

        # Delete requests in the running batch
        if self.cur_batch is self.running_batch or self.cur_batch is None:
            reqs = self.running_batch.reqs
        else:
            reqs = self.running_batch.reqs + self.cur_batch.reqs

        for req in reqs:
            if not req.finished() and (
                recv_req.abort_all or req.rid.startswith(recv_req.rid)
            ):
                # Abort method 3: set `to_abort=True`
                # The request will still run one decode forward pass.
                # Then we reuse all existing code to clean up the KV cache allocation.
                logger.debug(f&#34;Abort running request. {req.rid=}&#34;)
                req.to_abort = True

    def _pause_engine(self) -&gt; Tuple[List[Req], int]:
        raise NotImplementedError()

    def load_lora_adapter(
        self, recv_req: LoadLoRAAdapterReqInput
    ) -&gt; LoadLoRAAdapterReqOutput:
        &#34;&#34;&#34;In-place loading a new lora adapter from disk or huggingface.&#34;&#34;&#34;

        result = self.tp_worker.load_lora_adapter(recv_req)
        return result

    def unload_lora_adapter(
        self, recv_req: UnloadLoRAAdapterReqInput
    ) -&gt; UnloadLoRAAdapterReqOutput:
        &#34;&#34;&#34;Unload the lora adapter.&#34;&#34;&#34;

        result = self.tp_worker.unload_lora_adapter(recv_req)
        return result

    def slow_down(self, recv_req: SlowDownReqInput):
        t = recv_req.forward_sleep_time
        if t is not None and t &lt;= 0:
            t = None
        self.forward_sleep_time = t
        return SlowDownReqOutput()

    def expert_distribution_handle(self, recv_req: ExpertDistributionReq):
        if recv_req == ExpertDistributionReq.START_RECORD:
            get_global_expert_distribution_recorder().start_record()
        elif recv_req == ExpertDistributionReq.STOP_RECORD:
            get_global_expert_distribution_recorder().stop_record()
        elif recv_req == ExpertDistributionReq.DUMP_RECORD:
            get_global_expert_distribution_recorder().dump_record()
        else:
            raise ValueError(f&#34;Unrecognized ExpertDistributionReq value: {recv_req=}&#34;)
        return ExpertDistributionReqOutput()

    def open_session(self, recv_req: OpenSessionReqInput):
        # handle error
        session_id = recv_req.session_id
        if session_id in self.sessions:
            logger.warning(f&#34;session id {session_id} already exist, cannot open.&#34;)
            return OpenSessionReqOutput(session_id, False)
        elif session_id is None:
            logger.warning(&#34;session id is None, cannot open.&#34;)
            return OpenSessionReqOutput(session_id, False)
        else:
            self.sessions[session_id] = Session(
                recv_req.capacity_of_str_len, session_id
            )
            return OpenSessionReqOutput(session_id, True)

    def close_session(self, recv_req: CloseSessionReqInput):
        # handle error
        session_id = recv_req.session_id
        if session_id not in self.sessions:
            logger.warning(f&#34;session id {session_id} does not exist, cannot delete.&#34;)
        else:
            del self.sessions[session_id]

    def get_print_prefix(self):
        prefix = &#34;&#34;
        if self.attn_dp_rank is not None:
            prefix += f&#34; DP{self.attn_dp_rank}&#34;
        if self.server_args.tp_size &gt; 1:
            prefix += f&#34; TP{self.tp_rank}&#34;
        if self.pp_size &gt; 1:
            prefix += f&#34; PP{self.pp_rank}&#34;
        return prefix

    def current_scheduler_metrics_enabled(self):
        return self.attn_tp_rank == 0 or self.enable_metrics_for_all_schedulers

    def maybe_sleep_on_idle(self):
        if self.idle_sleeper is not None:
            self.idle_sleeper.maybe_sleep()

    def handle_freeze_gc(self, recv_req: FreezeGCReq):
        &#34;&#34;&#34;Handle freeze_gc request: freeze scheduler&#39;s GC and forward to detokenizer.&#34;&#34;&#34;
        freeze_gc(&#34;Scheduler&#34;)
        self.send_to_detokenizer.send_pyobj(recv_req)
        return None</code></pre>
</details>
<div class="desc"><p>A scheduler that manages a tensor parallel GPU worker.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin" href="scheduler_output_processor_mixin.html#sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin">SchedulerOutputProcessorMixin</a></li>
<li><a title="sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin" href="scheduler_update_weights_mixin.html#sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin">SchedulerUpdateWeightsMixin</a></li>
<li><a title="sglang.srt.managers.scheduler_profiler_mixin.SchedulerProfilerMixin" href="scheduler_profiler_mixin.html#sglang.srt.managers.scheduler_profiler_mixin.SchedulerProfilerMixin">SchedulerProfilerMixin</a></li>
<li><a title="sglang.srt.managers.scheduler_metrics_mixin.SchedulerMetricsMixin" href="scheduler_metrics_mixin.html#sglang.srt.managers.scheduler_metrics_mixin.SchedulerMetricsMixin">SchedulerMetricsMixin</a></li>
<li><a title="sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin" href="../disaggregation/decode.html#sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin">SchedulerDisaggregationDecodeMixin</a></li>
<li><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin">SchedulerDisaggregationPrefillMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sglang.srt.managers.scheduler.Scheduler.prepare_mlp_sync_batch_raw"><code class="name flex">
<span>def <span class="ident">prepare_mlp_sync_batch_raw</span></span>(<span>local_batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>,<br>dp_size,<br>attn_tp_size: int,<br>tp_group,<br>get_idle_batch,<br>disable_cuda_graph: bool,<br>spec_algorithm,<br>speculative_num_draft_tokens,<br>require_mlp_tp_gather: bool,<br>disable_overlap_schedule: bool)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def prepare_mlp_sync_batch_raw(
    local_batch: ScheduleBatch,
    dp_size,
    attn_tp_size: int,
    tp_group,
    get_idle_batch,
    disable_cuda_graph: bool,
    spec_algorithm,
    speculative_num_draft_tokens,
    require_mlp_tp_gather: bool,
    disable_overlap_schedule: bool,
):
    # Check if other DP workers have running batches
    if local_batch is None:
        num_tokens = 0
        num_tokens_for_logprob = 0
    elif local_batch.forward_mode.is_decode():
        num_tokens = local_batch.batch_size()
        num_tokens_for_logprob = num_tokens
    else:
        num_tokens = local_batch.extend_num_tokens
        num_tokens_for_logprob = sum(
            [
                # We should have at least 1 token for sample in every case.
                max(extend_len - logprob_start_len, 1)
                for logprob_start_len, extend_len in zip(
                    local_batch.extend_logprob_start_lens, local_batch.extend_lens
                )
            ]
        )

    if local_batch is None or local_batch.forward_mode.is_decode_or_idle():
        can_cuda_graph = 1
    else:
        can_cuda_graph = 0

    is_extend_in_batch = (
        local_batch.forward_mode.is_extend() if local_batch else False
    )

    tbo_preparer = TboDPAttentionPreparer()
    if disable_overlap_schedule:
        group = tp_group.device_group
        device = tp_group.device
    else:
        group = tp_group.cpu_group
        device = &#34;cpu&#34;

    local_info = torch.tensor(
        [
            num_tokens,
            can_cuda_graph,
            num_tokens_for_logprob,
            is_extend_in_batch,
            *tbo_preparer.prepare_all_gather(
                local_batch,
            ),
        ],
        dtype=torch.int64,
        device=device,
    )
    global_info = torch.empty(
        (dp_size, attn_tp_size, 6),
        dtype=torch.int64,
        device=device,
    )
    torch.distributed.all_gather_into_tensor(
        global_info.flatten(),
        local_info,
        group=group,
    )
    global_num_tokens = global_info[:, 0, 0].tolist()
    can_cuda_graph = min(global_info[:, 0, 1].tolist())
    global_num_tokens_for_logprob = global_info[:, 0, 2].tolist()
    is_extend_in_batch = global_info[:, 0, 3].tolist()

    tbo_split_seq_index, global_forward_mode = tbo_preparer.compute_output(
        global_info[:, :, 4:6]
    )

    if local_batch is None and max(global_num_tokens) &gt; 0:
        local_batch = get_idle_batch()

    if local_batch is not None:
        # TODO: handle the case when moe_dense_tp_size != 1
        if not require_mlp_tp_gather:
            local_batch.global_num_tokens = [num_tokens]
            local_batch.global_num_tokens_for_logprob = [num_tokens_for_logprob]
        else:
            local_batch.global_num_tokens = global_num_tokens
            local_batch.global_num_tokens_for_logprob = (
                global_num_tokens_for_logprob
            )
        local_batch.is_extend_in_batch = any(is_extend_in_batch)
        local_batch.tbo_split_seq_index = tbo_split_seq_index
        local_batch.global_forward_mode = global_forward_mode

        # Check forward mode for cuda graph
        if not disable_cuda_graph:
            local_batch.can_run_dp_cuda_graph = can_cuda_graph

    return local_batch</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.managers.scheduler.Scheduler.abort_request"><code class="name flex">
<span>def <span class="ident">abort_request</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.AbortReq" href="io_struct.html#sglang.srt.managers.io_struct.AbortReq">AbortReq</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort_request(self, recv_req: AbortReq):
    # Delete requests in the waiting queue
    to_del = []
    for i, req in enumerate(self.waiting_queue):
        if recv_req.abort_all or req.rid.startswith(recv_req.rid):
            to_del.append(i)

    # Sort in reverse order to avoid index issues when deleting
    for i in reversed(to_del):
        # Abort method 1: directly pop from the queue
        # This only works for requests that have not started anything.
        # We still need to send something back to TokenizerManager to clean up the state.
        req = self.waiting_queue.pop(i)
        self.send_to_tokenizer.send_pyobj(AbortReq(req.rid))
        # For disaggregation decode mode, the request in the waiting queue has KV cache allocated.
        if self.disaggregation_mode == DisaggregationMode.DECODE:
            self.tree_cache.cache_finished_req(req)

        logger.debug(f&#34;Abort queued request. {req.rid=}&#34;)

    # Delete the requests in the grammar queue
    for req in self.grammar_queue:
        # Abort method 2: call `set_finish_with_abort`
        # The request will still run one prefill forward pass.
        # In this case, we change the input_ids to be only one token to make this prefill cheap.
        if recv_req.abort_all or req.rid.startswith(recv_req.rid):
            logger.debug(f&#34;Abort grammar queue request. {req.rid=}&#34;)
            if req.grammar:
                req.grammar.cancel()
            req.set_finish_with_abort(&#34;Aborted by AbortReq.&#34;)

    # Delete requests not in the waiting queue when PD disaggregation is enabled
    if self.disaggregation_mode == DisaggregationMode.PREFILL:
        # Abort requests that have not yet been bootstrapped
        for i, req in enumerate(self.disagg_prefill_bootstrap_queue.queue):
            logger.debug(f&#34;Abort bootstrap queue request. {req.rid=}&#34;)
            if recv_req.abort_all or req.rid.startswith(recv_req.rid):
                if hasattr(req.disagg_kv_sender, &#34;abort&#34;):
                    req.disagg_kv_sender.abort()

        # Abort in-flight requests
        for i, req in enumerate(self.disagg_prefill_inflight_queue):
            logger.debug(f&#34;Abort inflight queue request. {req.rid=}&#34;)
            if recv_req.abort_all or req.rid.startswith(recv_req.rid):
                if hasattr(req.disagg_kv_sender, &#34;abort&#34;):
                    req.disagg_kv_sender.abort()

    elif self.disaggregation_mode == DisaggregationMode.DECODE:
        # Abort requests that have not yet finished preallocation
        for i, decode_req in enumerate(self.disagg_decode_prealloc_queue.queue):
            logger.debug(f&#34;Abort prealloc queue request. {decode_req.req.rid=}&#34;)
            if recv_req.abort_all or decode_req.req.rid.startswith(recv_req.rid):
                if hasattr(decode_req.kv_receiver, &#34;abort&#34;):
                    decode_req.kv_receiver.abort()

        # Abort requests waiting for kvcache to release tree cache
        for i, decode_req in enumerate(self.disagg_decode_transfer_queue.queue):
            logger.debug(f&#34;Abort transfer queue request. {decode_req.req.rid=}&#34;)
            if recv_req.abort_all or decode_req.req.rid.startswith(recv_req.rid):
                if hasattr(decode_req.kv_receiver, &#34;abort&#34;):
                    decode_req.kv_receiver.abort()

    # Delete requests in the running batch
    if self.cur_batch is self.running_batch or self.cur_batch is None:
        reqs = self.running_batch.reqs
    else:
        reqs = self.running_batch.reqs + self.cur_batch.reqs

    for req in reqs:
        if not req.finished() and (
            recv_req.abort_all or req.rid.startswith(recv_req.rid)
        ):
            # Abort method 3: set `to_abort=True`
            # The request will still run one decode forward pass.
            # Then we reuse all existing code to clean up the KV cache allocation.
            logger.debug(f&#34;Abort running request. {req.rid=}&#34;)
            req.to_abort = True</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.check_memory"><code class="name flex">
<span>def <span class="ident">check_memory</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_memory(self):
    if self.is_hybrid:
        (
            full_num_used,
            swa_num_used,
            _,
            _,
            full_available_size,
            full_evictable_size,
            swa_available_size,
            swa_evictable_size,
        ) = self._get_swa_token_info()
        memory_leak = full_num_used != 0 or swa_num_used != 0
        token_msg = (
            f&#34;{self.full_tokens_per_layer=}, {full_available_size=}, {full_evictable_size=}, {self.tree_cache.full_protected_size()=}\n&#34;
            f&#34;{self.swa_tokens_per_layer=}, {swa_available_size=}, {swa_evictable_size=}, {self.tree_cache.swa_protected_size()=}\n&#34;
        )
    else:
        _, _, available_size, evictable_size = self._get_token_info()
        protected_size = self.tree_cache.protected_size()
        memory_leak = (available_size + evictable_size) != (
            self.max_total_num_tokens
            if not self.enable_hierarchical_cache
            else self.max_total_num_tokens - protected_size
        )
        token_msg = f&#34;{self.max_total_num_tokens=}, {available_size=}, {evictable_size=}, {protected_size=}\n&#34;

    if memory_leak:
        msg = &#34;token_to_kv_pool_allocator memory leak detected! &#34; f&#34;{token_msg}&#34;
        raise ValueError(msg)

    if self.disaggregation_mode == DisaggregationMode.DECODE:
        req_total_size = (
            self.req_to_token_pool.size + self.req_to_token_pool.pre_alloc_size
        )
    else:
        req_total_size = self.req_to_token_pool.size

    if len(self.req_to_token_pool.free_slots) != req_total_size:
        msg = (
            &#34;req_to_token_pool memory leak detected!&#34;
            f&#34;available_size={len(self.req_to_token_pool.free_slots)}, &#34;
            f&#34;total_size={self.req_to_token_pool.size}\n&#34;
        )
        raise ValueError(msg)

    if (
        self.enable_metrics
        and self.current_scheduler_metrics_enabled()
        and time.perf_counter() &gt; self.metrics_collector.last_log_time + 30
    ):
        # During idle time, also collect metrics every 30 seconds.
        if self.is_hybrid:
            (
                full_num_used,
                swa_num_used,
                full_token_usage,
                swa_token_usage,
                _,
                _,
                _,
                _,
            ) = self._get_swa_token_info()
            num_used = max(full_num_used, swa_num_used)
            token_usage = max(full_token_usage, swa_token_usage)
        else:
            num_used, token_usage, _, _ = self._get_token_info()
        num_running_reqs = len(self.running_batch.reqs)
        self.stats.num_running_reqs = num_running_reqs
        self.stats.num_used_tokens = num_used
        self.stats.token_usage = round(token_usage, 2)
        self.stats.gen_throughput = 0
        self.stats.num_queue_reqs = len(self.waiting_queue)
        self.stats.num_grammar_queue_reqs = len(self.grammar_queue)
        self.metrics_collector.log_stats(self.stats)
    self._publish_kv_events()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.check_tree_cache"><code class="name flex">
<span>def <span class="ident">check_tree_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_tree_cache(self):
    if self.is_hybrid and isinstance(self.tree_cache, SWARadixCache):
        self.tree_cache.sanity_check()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.clear_hicache_storage_wrapped"><code class="name flex">
<span>def <span class="ident">clear_hicache_storage_wrapped</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.ClearHiCacheReqInput" href="io_struct.html#sglang.srt.managers.io_struct.ClearHiCacheReqInput">ClearHiCacheReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_hicache_storage_wrapped(self, recv_req: ClearHiCacheReqInput):
    if self.enable_hierarchical_cache:
        self.tree_cache.clear_storage_backend()
        logger.info(&#34;Hierarchical cache cleared successfully!&#34;)
        if_success = True
    else:
        logging.warning(&#34;Hierarchical cache is not enabled.&#34;)
        if_success = False
    return ClearHiCacheReqOutput(success=if_success)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.close_session"><code class="name flex">
<span>def <span class="ident">close_session</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.CloseSessionReqInput" href="io_struct.html#sglang.srt.managers.io_struct.CloseSessionReqInput">CloseSessionReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_session(self, recv_req: CloseSessionReqInput):
    # handle error
    session_id = recv_req.session_id
    if session_id not in self.sessions:
        logger.warning(f&#34;session id {session_id} does not exist, cannot delete.&#34;)
    else:
        del self.sessions[session_id]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.current_scheduler_metrics_enabled"><code class="name flex">
<span>def <span class="ident">current_scheduler_metrics_enabled</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def current_scheduler_metrics_enabled(self):
    return self.attn_tp_rank == 0 or self.enable_metrics_for_all_schedulers</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.event_loop_normal"><code class="name flex">
<span>def <span class="ident">event_loop_normal</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@DynamicGradMode()
def event_loop_normal(self):
    &#34;&#34;&#34;A normal scheduler loop.&#34;&#34;&#34;
    while True:
        recv_reqs = self.recv_requests()
        self.process_input_requests(recv_reqs)

        batch = self.get_next_batch_to_run()
        self.cur_batch = batch

        if batch:
            result = self.run_batch(batch)
            self.process_batch_result(batch, result)
        else:
            # When the server is idle, do self-check and re-init some states
            self.self_check_during_idle()

        self.last_batch = batch</code></pre>
</details>
<div class="desc"><p>A normal scheduler loop.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.event_loop_overlap"><code class="name flex">
<span>def <span class="ident">event_loop_overlap</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@DynamicGradMode()
def event_loop_overlap(self):
    &#34;&#34;&#34;A scheduler loop that overlaps the CPU processing and GPU computation.&#34;&#34;&#34;
    self.result_queue = deque()

    while True:
        recv_reqs = self.recv_requests()
        self.process_input_requests(recv_reqs)

        batch = self.get_next_batch_to_run()
        self.cur_batch = batch

        if batch:
            batch.launch_done = threading.Event()
            result = self.run_batch(batch)
            self.result_queue.append((batch.copy(), result))

            if self.last_batch is None:
                # Create a dummy first batch to start the pipeline for overlap schedule.
                # It is now used for triggering the sampling_info_done event.
                tmp_batch = ScheduleBatch(
                    reqs=None,
                    forward_mode=ForwardMode.DUMMY_FIRST,
                    next_batch_sampling_info=self.tp_worker.cur_sampling_info,
                )
                self.process_batch_result(tmp_batch, None, batch.launch_done)

        if self.last_batch:
            # Process the results of the last batch
            tmp_batch, tmp_result = self.result_queue.popleft()
            tmp_batch.next_batch_sampling_info = (
                self.tp_worker.cur_sampling_info if batch else None
            )
            # NOTE: we should use current launched batch&#39;s launch_done event Instead of the last batch&#39;s
            self.process_batch_result(
                tmp_batch, tmp_result, batch.launch_done if batch else None
            )
        elif batch is None:
            # When the server is idle, do self-check and re-init some states
            self.self_check_during_idle()

        self.last_batch = batch</code></pre>
</details>
<div class="desc"><p>A scheduler loop that overlaps the CPU processing and GPU computation.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.event_loop_pp"><code class="name flex">
<span>def <span class="ident">event_loop_pp</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@DynamicGradMode()
def event_loop_pp(self):
    &#34;&#34;&#34;A non-overlap scheduler loop for pipeline parallelism.&#34;&#34;&#34;
    mbs = [None] * self.pp_size
    last_mbs = [None] * self.pp_size
    self.running_mbs = [
        ScheduleBatch(reqs=[], batch_is_full=False) for _ in range(self.pp_size)
    ]
    bids = [None] * self.pp_size
    pp_outputs: Optional[PPProxyTensors] = None
    while True:
        server_is_idle = True
        for mb_id in range(self.pp_size):
            self.running_batch = self.running_mbs[mb_id]
            self.last_batch = last_mbs[mb_id]

            recv_reqs = self.recv_requests()
            self.process_input_requests(recv_reqs)
            mbs[mb_id] = self.get_next_batch_to_run()
            self.running_mbs[mb_id] = self.running_batch

            self.cur_batch = mbs[mb_id]
            if self.cur_batch:
                server_is_idle = False
                result = self.run_batch(self.cur_batch)

            # (last rank) send the outputs to the next step
            if self.pp_group.is_last_rank:
                if self.cur_batch:
                    next_token_ids, bids[mb_id] = (
                        result.next_token_ids,
                        result.bid,
                    )
                    if self.cur_batch.return_logprob:
                        pp_outputs = PPProxyTensors(
                            {
                                &#34;next_token_ids&#34;: next_token_ids,
                                &#34;extend_input_len_per_req&#34;: result.extend_input_len_per_req,
                                &#34;extend_logprob_start_len_per_req&#34;: result.extend_logprob_start_len_per_req,
                            }
                            | (
                                {
                                    f&#34;logits_output.{k}&#34;: v
                                    for k, v in result.logits_output.__dict__.items()
                                }
                                if result.logits_output is not None
                                else {}
                            )
                        )
                    else:
                        pp_outputs = PPProxyTensors(
                            {
                                &#34;next_token_ids&#34;: next_token_ids,
                            }
                        )
                    # send the output from the last round to let the next stage worker run post processing
                    self.pp_group.send_tensor_dict(
                        pp_outputs.tensors,
                        all_gather_group=self.attn_tp_group,
                    )

            # receive outputs and post-process (filter finished reqs) the coming microbatch
            next_mb_id = (mb_id + 1) % self.pp_size
            next_pp_outputs = None
            if mbs[next_mb_id] is not None:
                next_pp_outputs: Optional[PPProxyTensors] = PPProxyTensors(
                    self.pp_group.recv_tensor_dict(
                        all_gather_group=self.attn_tp_group
                    )
                )
                mbs[next_mb_id].output_ids = next_pp_outputs[&#34;next_token_ids&#34;]
                logits_output_args = {
                    k[len(&#34;logits_output.&#34;) :]: v
                    for k, v in next_pp_outputs.tensors.items()
                    if k.startswith(&#34;logits_output.&#34;)
                }
                if len(logits_output_args) &gt; 0:
                    logits_output = LogitsProcessorOutput(**logits_output_args)
                else:
                    logits_output = None
                output_result = GenerationBatchResult(
                    logits_output=logits_output,
                    pp_hidden_states_proxy_tensors=None,
                    next_token_ids=next_pp_outputs[&#34;next_token_ids&#34;],
                    extend_input_len_per_req=next_pp_outputs.tensors.get(
                        &#34;extend_input_len_per_req&#34;, None
                    ),
                    extend_logprob_start_len_per_req=next_pp_outputs.tensors.get(
                        &#34;extend_logprob_start_len_per_req&#34;, None
                    ),
                    bid=bids[next_mb_id],
                    can_run_cuda_graph=result.can_run_cuda_graph,
                )
                self.process_batch_result(mbs[next_mb_id], output_result)
                last_mbs[next_mb_id] = mbs[next_mb_id]

            # (not last rank)
            if not self.pp_group.is_last_rank:
                if self.cur_batch:
                    bids[mb_id] = result.bid
                # carry the outputs to the next stage
                # send the outputs from the last round to let the next stage worker run post processing
                if pp_outputs:
                    self.pp_group.send_tensor_dict(
                        pp_outputs.tensors,
                        all_gather_group=self.attn_tp_group,
                    )

                # send out reqs to the next stage
                dp_offset = self.attn_dp_rank * self.attn_tp_size
                if self.attn_tp_rank == 0:
                    point_to_point_pyobj(
                        recv_reqs,
                        self.pp_rank * self.tp_size + dp_offset,
                        self.world_group.device_group,
                        self.pp_rank * self.tp_size + dp_offset,
                        (self.pp_rank + 1) * self.tp_size + dp_offset,
                    )

                # send out proxy tensors to the next stage
                if self.cur_batch:
                    self.pp_group.send_tensor_dict(
                        result.pp_hidden_states_proxy_tensors,
                        all_gather_group=self.attn_tp_group,
                    )

            pp_outputs = next_pp_outputs

        # When the server is idle, self-check and re-init some states
        if server_is_idle:
            # When the server is idle, do self-check and re-init some states
            self.self_check_during_idle()</code></pre>
</details>
<div class="desc"><p>A non-overlap scheduler loop for pipeline parallelism.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.expert_distribution_handle"><code class="name flex">
<span>def <span class="ident">expert_distribution_handle</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.ExpertDistributionReq" href="io_struct.html#sglang.srt.managers.io_struct.ExpertDistributionReq">ExpertDistributionReq</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expert_distribution_handle(self, recv_req: ExpertDistributionReq):
    if recv_req == ExpertDistributionReq.START_RECORD:
        get_global_expert_distribution_recorder().start_record()
    elif recv_req == ExpertDistributionReq.STOP_RECORD:
        get_global_expert_distribution_recorder().stop_record()
    elif recv_req == ExpertDistributionReq.DUMP_RECORD:
        get_global_expert_distribution_recorder().dump_record()
    else:
        raise ValueError(f&#34;Unrecognized ExpertDistributionReq value: {recv_req=}&#34;)
    return ExpertDistributionReqOutput()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.flush_cache"><code class="name flex">
<span>def <span class="ident">flush_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_cache(self):
    &#34;&#34;&#34;Flush the memory pool and cache.&#34;&#34;&#34;
    if (
        len(self.waiting_queue) == 0
        and self.running_batch.is_empty()
        and (self.pp_size == 1 or all(x.is_empty() for x in self.running_mbs))
    ):
        self.cur_batch = None
        self.last_batch = None
        self.tree_cache.reset()
        if self.grammar_backend:
            self.grammar_backend.reset()
        self.req_to_token_pool.clear()
        self.token_to_kv_pool_allocator.clear()

        if not self.spec_algorithm.is_none():
            self.draft_worker.model_runner.req_to_token_pool.clear()
            self.draft_worker.model_runner.token_to_kv_pool_allocator.clear()

        self.num_generated_tokens = 0
        self.forward_ct_decode = 0
        self.spec_num_total_accepted_tokens = 0
        self.spec_num_total_forward_ct = 0
        self.cum_spec_accept_length = 0
        self.cum_spec_accept_count = 0
        torch.cuda.empty_cache()
        logger.info(&#34;Cache flushed successfully!&#34;)
        if_success = True
    else:
        logging.warning(
            f&#34;Cache not flushed because there are pending requests. &#34;
            f&#34;#queue-req: {len(self.waiting_queue)}, &#34;
            f&#34;#running-req: {len(self.running_batch.reqs)}&#34;
        )
        if_success = False
    return if_success</code></pre>
</details>
<div class="desc"><p>Flush the memory pool and cache.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.flush_cache_wrapped"><code class="name flex">
<span>def <span class="ident">flush_cache_wrapped</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.FlushCacheReqInput" href="io_struct.html#sglang.srt.managers.io_struct.FlushCacheReqInput">FlushCacheReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flush_cache_wrapped(self, recv_req: FlushCacheReqInput):
    success = self.flush_cache()
    return FlushCacheReqOutput(success=success)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_idle_batch"><code class="name flex">
<span>def <span class="ident">get_idle_batch</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_idle_batch(self):
    idle_batch = ScheduleBatch.init_new(
        [],
        self.req_to_token_pool,
        self.token_to_kv_pool_allocator,
        self.tree_cache,
        self.model_config,
        self.enable_overlap,
        self.spec_algorithm,
    )
    idle_batch.prepare_for_idle()
    return idle_batch</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_internal_state"><code class="name flex">
<span>def <span class="ident">get_internal_state</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.GetInternalStateReq" href="io_struct.html#sglang.srt.managers.io_struct.GetInternalStateReq">GetInternalStateReq</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_internal_state(self, recv_req: GetInternalStateReq):
    ret = dict(global_server_args_dict)
    ret[&#34;last_gen_throughput&#34;] = self.last_gen_throughput
    ret[&#34;memory_usage&#34;] = {
        &#34;weight&#34;: round(
            self.tp_worker.worker.model_runner.weight_load_mem_usage, 2
        ),
        &#34;kvcache&#34;: round(
            self.token_to_kv_pool_allocator.get_kvcache().mem_usage, 2
        ),
        &#34;token_capacity&#34;: int(self.max_total_num_tokens),
    }

    if not _is_cpu:
        ret[&#34;memory_usage&#34;][&#34;cuda_graph&#34;] = round(
            self.tp_worker.worker.model_runner.cuda_graph_mem_usage, 2
        )

    if not self.spec_algorithm.is_none() and self.cum_spec_accept_count &gt; 0:
        ret[&#34;avg_spec_accept_length&#34;] = (
            self.cum_spec_accept_length / self.cum_spec_accept_count
        )
    if RECORD_STEP_TIME:
        ret[&#34;step_time_dict&#34;] = self.step_time_dict

    ret[&#34;load&#34;] = self.get_load()

    return GetInternalStateReqOutput(internal_state=ret)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_load"><code class="name flex">
<span>def <span class="ident">get_load</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_load(self):
    # TODO(lsyin): use dynamically maintained num_waiting_tokens
    if self.is_hybrid:
        load_full = (
            self.full_tokens_per_layer
            - self.token_to_kv_pool_allocator.full_available_size()
            - self.tree_cache.full_evictable_size()
        )
        load_swa = (
            self.swa_tokens_per_layer
            - self.token_to_kv_pool_allocator.swa_available_size()
            - self.tree_cache.swa_evictable_size()
        )
        load = max(load_full, load_swa)
    else:
        load = (
            self.max_total_num_tokens
            - self.token_to_kv_pool_allocator.available_size()
            - self.tree_cache.evictable_size()
        )
    load += sum(len(req.origin_input_ids) for req in self.waiting_queue)
    if self.disaggregation_mode == DisaggregationMode.PREFILL:
        load += sum(
            len(req.origin_input_ids)
            for req in self.disagg_prefill_bootstrap_queue.queue
        )
    elif self.disaggregation_mode == DisaggregationMode.DECODE:
        load += sum(
            len(req.req.origin_input_ids)
            for req in self.disagg_decode_prealloc_queue.queue
        )

    return load</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_new_batch_prefill"><code class="name flex">
<span>def <span class="ident">get_new_batch_prefill</span></span>(<span>self) ‑> <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_new_batch_prefill(self) -&gt; Optional[ScheduleBatch]:
    # Check if the grammar is ready in the grammar queue
    if self.grammar_queue:
        self.move_ready_grammar_requests()

    # Handle the cases where prefill is not allowed
    if (
        self.running_batch.batch_is_full or len(self.waiting_queue) == 0
    ) and self.chunked_req is None:
        return None

    running_bs = len(self.running_batch.reqs)
    # Ignore the check if self.chunked_req is not None.
    # In the non-PP case, when self.chunked_req is not None, num_allocatable_reqs should always be greater than 0,
    # as the space for the chunked request has just been released.
    # In PP case, a chunked req can start in one microbatch and end in another microbatch, so the max_running_requests per microbatch should not be strict.
    # Instead, we should always allow chunked request to be added, otherwise, there will be a memory leak.
    if self.get_num_allocatable_reqs(running_bs) &lt;= 0 and not self.chunked_req:
        self.running_batch.batch_is_full = True
        return None

    if self.enable_hierarchical_cache:
        self.tree_cache.check_hicache_events()

    # Get priority queue
    self.policy.calc_priority(self.waiting_queue)

    # Prefill policy
    adder = PrefillAdder(
        self.page_size,
        self.tree_cache,
        self.token_to_kv_pool_allocator,
        self.running_batch,
        self.new_token_ratio,
        self.max_prefill_tokens,
        self.chunked_prefill_size,
        running_bs if self.is_mixed_chunk else 0,
    )

    if self.chunked_req is not None:
        self.chunked_req.init_next_round_input()
        self.chunked_req = adder.add_chunked_req(self.chunked_req)

    if self.enable_lora:
        lora_set = set([req.lora_id for req in self.running_batch.reqs])

    # Get requests from the waiting queue to a new prefill batch
    for req in self.waiting_queue:

        if self.enable_lora and not self.tp_worker.can_run_lora_batch(
            lora_set
            | set([req.lora_id for req in adder.can_run_list])
            | set([req.lora_id])
        ):
            self.running_batch.batch_is_full = True
            break

        if len(adder.can_run_list) &gt;= self.get_num_allocatable_reqs(running_bs):
            self.running_batch.batch_is_full = True
            break

        if self.disaggregation_mode == DisaggregationMode.PREFILL:
            # In prefill mode, prealloc queue and transfer queue can also take memory,
            # so we need to check if the available size for the actual available size.
            if len(adder.can_run_list) &gt;= self.req_to_token_pool.available_size():
                self.running_batch.batch_is_full = True
                break

        if self.enable_hicache_storage:
            prefetch_done = self.tree_cache.check_prefetch_progress(req.rid)
            if not prefetch_done:
                # skip staging requests that are ongoing prefetch
                continue

        req.init_next_round_input(self.tree_cache)
        res = adder.add_one_req(req, has_chunked_req=(self.chunked_req is not None))

        if res != AddReqResult.CONTINUE:
            if res == AddReqResult.NO_TOKEN:
                if self.enable_hierarchical_cache:
                    # Set batch_is_full after making sure there are requests that can be served
                    self.running_batch.batch_is_full = len(
                        adder.can_run_list
                    ) &gt; 0 or (not self.running_batch.is_empty())
                else:
                    self.running_batch.batch_is_full = True
            break

    # Update waiting queue
    can_run_list: List[Req] = adder.can_run_list
    if len(can_run_list) == 0:
        return None

    if self.enable_metrics:
        # only record queue time when enable_metrics is True to avoid overhead
        for req in can_run_list:
            req.queue_time_end = time.perf_counter()

    self.waiting_queue = [
        x for x in self.waiting_queue if x not in set(can_run_list)
    ]

    if adder.new_chunked_req is not None:
        assert self.chunked_req is None
        self.chunked_req = adder.new_chunked_req

    if self.chunked_req:
        self.chunked_req.is_chunked += 1

    # Print stats
    if self.current_scheduler_metrics_enabled():
        self.log_prefill_stats(adder, can_run_list, running_bs)

    # Create a new batch
    new_batch = ScheduleBatch.init_new(
        can_run_list,
        self.req_to_token_pool,
        self.token_to_kv_pool_allocator,
        self.tree_cache,
        self.model_config,
        self.enable_overlap,
        self.spec_algorithm,
        chunked_req=self.chunked_req,
    )
    if self.enable_hierarchical_cache:
        # todo (zhiqiang): disable cuda graph execution if hicache loading triggered
        new_batch.hicache_consumer_index = (
            self.tree_cache.ready_to_load_host_cache()
        )

    new_batch.prepare_for_extend()

    # Mixed-style chunked prefill
    if (
        self.is_mixed_chunk
        and not self.running_batch.is_empty()
        and not (new_batch.return_logprob or self.running_batch.return_logprob)
    ):
        # TODO (lianmin): support return_logprob + mixed chunked prefill
        self.running_batch.filter_batch()
        if not self.running_batch.is_empty():
            self.running_batch.prepare_for_decode()
            new_batch.mix_with_running(self.running_batch)
            new_batch.decoding_reqs = self.running_batch.reqs
        self.running_batch = ScheduleBatch(
            reqs=[], batch_is_full=self.running_batch.batch_is_full
        )
    else:
        new_batch.decoding_reqs = None

    return new_batch</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_next_batch_to_run"><code class="name flex">
<span>def <span class="ident">get_next_batch_to_run</span></span>(<span>self) ‑> <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_next_batch_to_run(self) -&gt; Optional[ScheduleBatch]:
    # Merge the prefill batch into the running batch
    chunked_req_to_exclude = set()
    if self.chunked_req:
        # Move the chunked request out of the batch so that we can merge
        # only finished requests to running_batch.
        chunked_req_to_exclude.add(self.chunked_req)
        self.tree_cache.cache_unfinished_req(self.chunked_req, chunked=True)
        # chunked request keeps its rid but will get a new req_pool_idx
        self.req_to_token_pool.free(self.chunked_req.req_pool_idx)
    if self.last_batch and self.last_batch.forward_mode.is_extend():
        if self.last_batch.chunked_req is not None:
            # In the context pipeline parallelism, after the last chunk, the current microbatch still track outdated chunked_req.
            # We need to discard it.
            chunked_req_to_exclude.add(self.last_batch.chunked_req)

        # Filter batch
        last_bs = self.last_batch.batch_size()
        self.last_batch.filter_batch(
            chunked_req_to_exclude=list(chunked_req_to_exclude)
        )
        if self.last_batch.batch_size() &lt; last_bs:
            self.running_batch.batch_is_full = False

        # Merge the new batch into the running batch.
        # For prefill-only batch, we can avoid going through decoding step.
        if not self.last_batch.is_empty() and not self.last_batch.is_prefill_only:
            if self.running_batch.is_empty():
                self.running_batch = self.last_batch
            else:
                # Merge running_batch with prefill batch
                self.running_batch.merge_batch(self.last_batch)

    new_batch = self.get_new_batch_prefill()

    need_dp_attn_preparation = require_mlp_sync(self.server_args)

    if need_dp_attn_preparation and not self.spec_algorithm.is_none():
        # In speculative decoding, prefill batches and decode batches cannot be processed in the same DP attention group.
        # We prepare idle batches in advance to skip preparing decode batches when there are prefill batches in the group.
        new_batch = self.prepare_mlp_sync_batch(new_batch)
        need_dp_attn_preparation = new_batch is None

    if new_batch is not None:
        # Run prefill first if possible
        ret = new_batch
    else:
        # Run decode
        if not self.running_batch.is_empty():
            self.running_batch = self.update_running_batch(self.running_batch)
            ret = self.running_batch if not self.running_batch.is_empty() else None
        else:
            ret = None

    # Handle DP attention
    if need_dp_attn_preparation:
        if (
            self.server_args.load_balance_method == &#34;minimum_tokens&#34;
            and self.forward_ct % 40 == 0
        ):
            self.handle_dp_balance_data(ret)
        ret = self.prepare_mlp_sync_batch(ret)

    return ret</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_num_allocatable_reqs"><code class="name flex">
<span>def <span class="ident">get_num_allocatable_reqs</span></span>(<span>self, running_bs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_num_allocatable_reqs(self, running_bs):
    res = global_server_args_dict[&#34;max_micro_batch_size&#34;] - running_bs
    if self.pp_size &gt; 1:
        res = min(res, self.req_to_token_pool.available_size())
    return res</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.get_print_prefix"><code class="name flex">
<span>def <span class="ident">get_print_prefix</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_print_prefix(self):
    prefix = &#34;&#34;
    if self.attn_dp_rank is not None:
        prefix += f&#34; DP{self.attn_dp_rank}&#34;
    if self.server_args.tp_size &gt; 1:
        prefix += f&#34; TP{self.tp_rank}&#34;
    if self.pp_size &gt; 1:
        prefix += f&#34; PP{self.pp_rank}&#34;
    return prefix</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_batch_embedding_request"><code class="name flex">
<span>def <span class="ident">handle_batch_embedding_request</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.BatchTokenizedEmbeddingReqInput" href="io_struct.html#sglang.srt.managers.io_struct.BatchTokenizedEmbeddingReqInput">BatchTokenizedEmbeddingReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_batch_embedding_request(
    self,
    recv_req: BatchTokenizedEmbeddingReqInput,
):
    &#34;&#34;&#34;Handle optimized batch embedding request.&#34;&#34;&#34;
    logger.debug(
        f&#34;Processing batch embedding request with {len(recv_req)} requests&#34;
    )

    # Process each request in the batch
    for tokenized_req in recv_req:
        self.handle_embedding_request(tokenized_req)</code></pre>
</details>
<div class="desc"><p>Handle optimized batch embedding request.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_batch_generate_request"><code class="name flex">
<span>def <span class="ident">handle_batch_generate_request</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.BatchTokenizedGenerateReqInput" href="io_struct.html#sglang.srt.managers.io_struct.BatchTokenizedGenerateReqInput">BatchTokenizedGenerateReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_batch_generate_request(
    self,
    recv_req: BatchTokenizedGenerateReqInput,
):
    &#34;&#34;&#34;Handle optimized batch generate request.&#34;&#34;&#34;
    logger.debug(f&#34;Processing batch generate request with {len(recv_req)} requests&#34;)

    # Process each request in the batch
    for tokenized_req in recv_req:
        self.handle_generate_request(tokenized_req)</code></pre>
</details>
<div class="desc"><p>Handle optimized batch generate request.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_dp_balance_data"><code class="name flex">
<span>def <span class="ident">handle_dp_balance_data</span></span>(<span>self,<br>local_batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_dp_balance_data(self, local_batch: ScheduleBatch):
    def gather_dp_balance_info(holding_tokens_list) -&gt; Union[None, List[List[int]]]:
        &#34;&#34;&#34;gather recv_dp_balance_id_this_term and holding tokens per worker for dp balance&#34;&#34;&#34;
        recv_list = self.recv_dp_balance_id_this_term
        assert len(recv_list) &lt;= 511, (
            &#34;The number of requests received this round is too large. &#34;
            &#34;Please increase gather_tensor_size and onfly_info_size.&#34;
        )
        # The maximum size of the tensor used for gathering data from all workers.
        gather_tensor_size = 512

        # recv_tensor: | holding_tokens | len(recv_dp_balance_id) | recv_dp_balance_ids
        recv_tensor = torch.zeros(gather_tensor_size, dtype=torch.int32)
        recv_tensor[0] = holding_tokens_list
        recv_tensor[1] = len(
            recv_list
        )  # The first element is the length of the list.
        recv_tensor[2 : len(recv_list) + 2] = torch.tensor(
            recv_list, dtype=torch.int32
        )

        if self.tp_rank == 0:
            gathered_list = [
                torch.zeros(gather_tensor_size, dtype=torch.int32)
                for _ in range(self.balance_meta.num_workers)
            ]
        else:
            gathered_list = None

        torch.distributed.gather(
            recv_tensor, gathered_list, group=self.tp_cpu_group
        )

        gathered_id_list_per_worker = None
        if self.tp_rank == 0:
            gathered_id_list_per_worker = []
            holding_tokens_list = []
            for tensor in gathered_list:
                holding_tokens_list.append(tensor[0].item())
                list_length = tensor[1].item()
                gathered_id_list_per_worker.append(
                    tensor[2 : list_length + 2].tolist()
                )

        return gathered_id_list_per_worker, holding_tokens_list

    def write_shared_dp_balance_info(new_recv_rid_lists, local_tokens):
        meta = self.balance_meta

        with meta.mutex:
            onfly_list: List[Dict[int, int]] = meta.get_shared_onfly()
            assert len(new_recv_rid_lists) == len(
                onfly_list
            ), &#34;num_worker not equal&#34;
            # 1.Check if the rid received by each worker this round is present in onfly.
            #   If it is, remove the corresponding onfly item.
            worker_id = 0
            for new_recv_rids, on_fly_reqs in zip(new_recv_rid_lists, onfly_list):
                for new_recv_rid in new_recv_rids:
                    assert (
                        new_recv_rid in on_fly_reqs
                    ), f&#34;{new_recv_rid=} not in {worker_id=} {on_fly_reqs=}, data consistency is wrong&#34;
                    del on_fly_reqs[new_recv_rid]
                worker_id += 1
            # 2. Atomically write local_tokens and onfly into shm under the mutex
            meta.set_shared_onfly_info(onfly_list)
            meta.set_shared_local_tokens(local_tokens)

    holding_tokens = self.get_load()

    new_recv_dp_balance_id_list, holding_token_list = gather_dp_balance_info(
        holding_tokens
    )

    self.recv_dp_balance_id_this_term.clear()
    if self.tp_rank == 0:  # only first worker write info
        write_shared_dp_balance_info(
            new_recv_dp_balance_id_list, holding_token_list
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_embedding_request"><code class="name flex">
<span>def <span class="ident">handle_embedding_request</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.TokenizedEmbeddingReqInput" href="io_struct.html#sglang.srt.managers.io_struct.TokenizedEmbeddingReqInput">TokenizedEmbeddingReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_embedding_request(
    self,
    recv_req: TokenizedEmbeddingReqInput,
):
    req = Req(
        recv_req.rid,
        recv_req.input_text,
        recv_req.input_ids,
        recv_req.sampling_params,
        token_type_ids=recv_req.token_type_ids,
    )
    req.tokenizer = self.tokenizer

    # Handle multimodal inputs
    if recv_req.image_inputs is not None:
        image_inputs = MultimodalInputs.from_dict(recv_req.image_inputs)
        # Expand a single image token into multiple dummy tokens for receiving image embeddings
        req.origin_input_ids = self.pad_input_ids_func(
            req.origin_input_ids, image_inputs
        )
        req.extend_image_inputs(image_inputs)

        if len(req.origin_input_ids) &gt;= self.max_req_input_len:
            req.set_finish_with_abort(
                error_msg=(
                    &#34;Multimodal prompt is too long after expanding multimodal tokens. &#34;
                    f&#34;After expanding {len(req.origin_input_ids_unpadded)=} =&gt; {len(req.origin_input_ids)} &gt;= {self.max_req_input_len}.&#34;
                )
            )
            self._add_request_to_queue(req)
            return

    # Validate prompts length
    error_msg = validate_input_length(
        req,
        self.max_req_input_len,
        self.server_args.allow_auto_truncate,
    )
    if error_msg:
        self._add_request_to_queue(req)
        return

    # Copy more attributes
    req.logprob_start_len = len(req.origin_input_ids) - 1
    self._add_request_to_queue(req)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_freeze_gc"><code class="name flex">
<span>def <span class="ident">handle_freeze_gc</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.FreezeGCReq" href="io_struct.html#sglang.srt.managers.io_struct.FreezeGCReq">FreezeGCReq</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_freeze_gc(self, recv_req: FreezeGCReq):
    &#34;&#34;&#34;Handle freeze_gc request: freeze scheduler&#39;s GC and forward to detokenizer.&#34;&#34;&#34;
    freeze_gc(&#34;Scheduler&#34;)
    self.send_to_detokenizer.send_pyobj(recv_req)
    return None</code></pre>
</details>
<div class="desc"><p>Handle freeze_gc request: freeze scheduler's GC and forward to detokenizer.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_generate_request"><code class="name flex">
<span>def <span class="ident">handle_generate_request</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.TokenizedGenerateReqInput" href="io_struct.html#sglang.srt.managers.io_struct.TokenizedGenerateReqInput">TokenizedGenerateReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_generate_request(
    self,
    recv_req: TokenizedGenerateReqInput,
):
    if (
        self.server_args.enable_dp_attention
        and self.server_args.load_balance_method == &#34;minimum_tokens&#34;
    ):
        self.recv_dp_balance_id_this_term.append(recv_req.dp_balance_id)

    # Create a new request
    if (
        recv_req.session_params is None
        or recv_req.session_params.id is None
        or recv_req.session_params.id not in self.sessions
    ):
        if recv_req.input_embeds is not None:
            # Generate fake input_ids based on the length of input_embeds
            seq_length = len(recv_req.input_embeds)
            fake_input_ids = [1] * seq_length
            recv_req.input_ids = fake_input_ids

        if recv_req.bootstrap_port is None:
            # Use default bootstrap port
            recv_req.bootstrap_port = self.server_args.disaggregation_bootstrap_port

        req = Req(
            recv_req.rid,
            recv_req.input_text,
            recv_req.input_ids,
            recv_req.sampling_params,
            return_logprob=recv_req.return_logprob,
            top_logprobs_num=recv_req.top_logprobs_num,
            token_ids_logprob=recv_req.token_ids_logprob,
            stream=recv_req.stream,
            lora_id=recv_req.lora_id,
            input_embeds=recv_req.input_embeds,
            custom_logit_processor=recv_req.custom_logit_processor,
            return_hidden_states=recv_req.return_hidden_states,
            eos_token_ids=self.model_config.hf_eos_token_id,
            bootstrap_host=recv_req.bootstrap_host,
            bootstrap_port=recv_req.bootstrap_port,
            bootstrap_room=recv_req.bootstrap_room,
            data_parallel_rank=recv_req.data_parallel_rank,
            vocab_size=self.model_config.vocab_size,
        )
        req.tokenizer = self.tokenizer

        if self.disaggregation_mode != DisaggregationMode.NULL:
            # Invalid request for disaggregated mode
            if recv_req.bootstrap_room is None:
                error_msg = (
                    f&#34;Invalid request: Disaggregated request received without &#34;
                    f&#34;boostrap room id. {req.rid=}&#34;
                )
                logger.error(error_msg)
                prepare_abort(req, error_msg, status_code=HTTPStatus.BAD_REQUEST)
                self.stream_output([req], req.return_logprob)
                return

        if (
            recv_req.session_params is not None
            and recv_req.session_params.id is not None
        ):
            req.set_finish_with_abort(
                f&#34;Invalid request: session id {recv_req.session_params.id} does not exist&#34;
            )
            self._add_request_to_queue(req)
            return
    else:
        # Create a new request from a previous session
        session = self.sessions[recv_req.session_params.id]
        req = session.create_req(recv_req, self.tokenizer)
        if isinstance(req.finished_reason, FINISH_ABORT):
            self._add_request_to_queue(req)
            return

    # Handle multimodal inputs
    if recv_req.mm_inputs is not None:
        image_inputs = MultimodalInputs.from_dict(recv_req.mm_inputs)
        # Expand a single image token into multiple dummy tokens for receiving image embeddings
        req.origin_input_ids = self.pad_input_ids_func(
            req.origin_input_ids, image_inputs
        )
        req.extend_image_inputs(image_inputs)

        if len(req.origin_input_ids) &gt;= self.max_req_input_len:
            req.set_finish_with_abort(
                error_msg=(
                    &#34;Multimodal prompt is too long after expanding multimodal tokens. &#34;
                    f&#34;After expanding {len(req.origin_input_ids_unpadded)=} =&gt; {len(req.origin_input_ids)} &gt;= {self.max_req_input_len}.&#34;
                )
            )
            self._add_request_to_queue(req)
            return

    # Validate prompt length
    error_msg = validate_input_length(
        req,
        self.max_req_input_len,
        self.server_args.allow_auto_truncate,
    )
    if error_msg:
        req.set_finish_with_abort(error_msg)
        self._add_request_to_queue(req)
        return

    # Copy more attributes
    if recv_req.logprob_start_len == -1 or not recv_req.return_logprob:
        # By default, only return the logprobs for output tokens
        req.logprob_start_len = len(req.origin_input_ids) - 1
    else:
        req.logprob_start_len = recv_req.logprob_start_len

    if req.logprob_start_len &gt;= len(req.origin_input_ids):
        error_msg = f&#34;{req.logprob_start_len=} is higher than the number of input tokens {len(req.origin_input_ids)=}. Please use a smaller logprob_start_len.&#34;
        req.logprob_start_len = len(req.origin_input_ids) - 1
        req.set_finish_with_abort(error_msg)
        self._add_request_to_queue(req)
        return

    req.sampling_params.max_new_tokens = min(
        (
            req.sampling_params.max_new_tokens
            if req.sampling_params.max_new_tokens is not None
            else 1 &lt;&lt; 30
        ),
        self.max_req_len - len(req.origin_input_ids) - 1,
    )

    # Init grammar cache for this request
    add_to_grammar_queue = False
    if (
        req.sampling_params.json_schema is not None
        or req.sampling_params.regex is not None
        or req.sampling_params.ebnf is not None
        or req.sampling_params.structural_tag is not None
    ):
        assert self.grammar_backend is not None
        if req.sampling_params.json_schema is not None:
            key = (&#34;json&#34;, req.sampling_params.json_schema)
        elif req.sampling_params.regex is not None:
            key = (&#34;regex&#34;, req.sampling_params.regex)
        elif req.sampling_params.ebnf is not None:
            key = (&#34;ebnf&#34;, req.sampling_params.ebnf)
        elif req.sampling_params.structural_tag:
            key = (&#34;structural_tag&#34;, req.sampling_params.structural_tag)

        value, cache_hit = self.grammar_backend.get_cached_or_future_value(key)
        req.grammar = value

        if not cache_hit:
            req.grammar_key = key
            add_to_grammar_queue = True
        else:
            if value is INVALID_GRAMMAR_OBJ:  # We hit a cached invalid grammar.
                error_msg = f&#34;Invalid grammar request with cache hit: {key=}&#34;
                req.set_finish_with_abort(error_msg)

    if add_to_grammar_queue:
        req.queue_time_start = time.perf_counter()
        self.grammar_queue.append(req)
    else:
        self._add_request_to_queue(req)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.handle_rpc_request"><code class="name flex">
<span>def <span class="ident">handle_rpc_request</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.RpcReqInput" href="io_struct.html#sglang.srt.managers.io_struct.RpcReqInput">RpcReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_rpc_request(self, recv_req: RpcReqInput):
    # Handle RPC requests
    logger.info(
        f&#34;handle_rpc_request: {recv_req.method}, param: {recv_req.parameters}&#34;
    )

    success = True
    exec = None
    try:
        func = getattr(self, recv_req.method)
        func(recv_req.parameters)
    except Exception as e:
        success = False
        exec = e
        logger.error(f&#34;Failed to call rpc {recv_req.method}: {str(e)}&#34;)

    barrier()
    return RpcReqOutput(success, &#34;&#34; if not exec else str(exec))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.init_disaggregation"><code class="name flex">
<span>def <span class="ident">init_disaggregation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_disaggregation(self):
    self.transfer_backend = TransferBackend(
        self.server_args.disaggregation_transfer_backend
    )

    if (
        self.disaggregation_mode == DisaggregationMode.DECODE
    ):  # *2 for the headroom.
        buffer_size = (self.req_to_token_pool.size) * 2
        self.req_to_metadata_buffer_idx_allocator = ReqToMetadataIdxAllocator(
            buffer_size
        )
        self.disagg_metadata_buffers = MetadataBuffers(
            buffer_size,
            hidden_size=self.model_config.hf_text_config.hidden_size,
            dtype=self.model_config.dtype,
            custom_mem_pool=self.token_to_kv_pool_allocator.get_kvcache().maybe_get_custom_mem_pool(),
        )

        # The decode requests polling kv cache
        self.disagg_decode_transfer_queue = DecodeTransferQueue(
            gloo_group=self.attn_tp_cpu_group,
            req_to_metadata_buffer_idx_allocator=self.req_to_metadata_buffer_idx_allocator,
            tp_rank=self.tp_rank,
            metadata_buffers=self.disagg_metadata_buffers,
            scheduler=self,
            tree_cache=self.tree_cache,
        )

        # The decode requests pending for pre-allocation
        self.disagg_decode_prealloc_queue = DecodePreallocQueue(
            req_to_token_pool=self.req_to_token_pool,
            token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
            draft_token_to_kv_pool=(
                None
                if self.draft_worker is None
                else self.draft_worker.model_runner.token_to_kv_pool
            ),
            req_to_metadata_buffer_idx_allocator=self.req_to_metadata_buffer_idx_allocator,
            metadata_buffers=self.disagg_metadata_buffers,
            scheduler=self,
            transfer_queue=self.disagg_decode_transfer_queue,
            tree_cache=self.tree_cache,
            gloo_group=self.attn_tp_cpu_group,
            tp_rank=self.tp_rank,
            tp_size=self.tp_size,
            dp_size=self.server_args.dp_size,
            gpu_id=self.gpu_id,
            bootstrap_port=self.server_args.disaggregation_bootstrap_port,
            max_total_num_tokens=self.max_total_num_tokens,
            prefill_pp_size=self.server_args.disaggregation_prefill_pp,
            num_reserved_decode_tokens=self.server_args.num_reserved_decode_tokens,
            transfer_backend=self.transfer_backend,
        )

    elif self.disaggregation_mode == DisaggregationMode.PREFILL:
        # *2 for the headroom.
        buffer_size = self.max_running_requests * 2
        self.req_to_metadata_buffer_idx_allocator = ReqToMetadataIdxAllocator(
            buffer_size
        )
        self.disagg_metadata_buffers = MetadataBuffers(
            buffer_size,
            hidden_size=self.model_config.hf_text_config.hidden_size,
            dtype=self.model_config.dtype,
            custom_mem_pool=self.token_to_kv_pool_allocator.get_kvcache().maybe_get_custom_mem_pool(),
        )

        self.disagg_prefill_bootstrap_queue = PrefillBootstrapQueue(
            token_to_kv_pool=self.token_to_kv_pool_allocator.get_kvcache(),
            draft_token_to_kv_pool=(
                None
                if self.draft_worker is None
                else self.draft_worker.model_runner.token_to_kv_pool
            ),
            req_to_metadata_buffer_idx_allocator=self.req_to_metadata_buffer_idx_allocator,
            metadata_buffers=self.disagg_metadata_buffers,
            tp_rank=self.tp_rank,
            tp_size=self.tp_size,
            gpu_id=self.gpu_id,
            bootstrap_port=self.server_args.disaggregation_bootstrap_port,
            gloo_group=self.attn_tp_cpu_group,
            max_total_num_tokens=self.max_total_num_tokens,
            decode_tp_size=self.server_args.disaggregation_decode_tp,
            decode_dp_size=self.server_args.disaggregation_decode_dp,
            scheduler=self,
            pp_rank=self.pp_rank,
            pp_size=self.pp_size,
            transfer_backend=self.transfer_backend,
        )
        # The prefill requests that are in the middle of kv sending
        self.disagg_prefill_inflight_queue: List[Req] = []</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.init_memory_pool_and_cache"><code class="name flex">
<span>def <span class="ident">init_memory_pool_and_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_memory_pool_and_cache(self):
    server_args = self.server_args

    self.req_to_token_pool, self.token_to_kv_pool_allocator = (
        self.tp_worker.get_memory_pool()
    )

    if (
        server_args.chunked_prefill_size is not None
        and server_args.disable_radix_cache
    ):
        if self.is_hybrid:
            ChunkCacheClass = SWAChunkCache
        else:
            ChunkCacheClass = ChunkCache
        self.tree_cache = ChunkCacheClass(
            req_to_token_pool=self.req_to_token_pool,
            token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
            page_size=self.page_size,
        )
    else:
        if os.environ.get(&#34;SGLANG_EXPERIMENTAL_CPP_RADIX_TREE&#34;) == &#34;1&#34;:
            # lazy import to avoid JIT overhead
            from sglang.srt.mem_cache.radix_cache_cpp import RadixCacheCpp

            self.tree_cache = RadixCacheCpp(
                disable=False,
                use_hicache=self.enable_hierarchical_cache,
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool=self.token_to_kv_pool_allocator,
                tp_cache_group=self.tp_cpu_group,
                page_size=self.page_size,
                hicache_ratio=server_args.hicache_ratio,
                hicache_size=server_args.hicache_size,
                hicache_write_policy=server_args.hicache_write_policy,
                enable_kv_cache_events=self.enable_kv_cache_events,
            )
        elif self.enable_hierarchical_cache:
            self.tree_cache = HiRadixCache(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                tp_cache_group=(
                    self.attn_tp_cpu_group
                    if self.server_args.enable_dp_attention
                    else self.tp_cpu_group
                ),
                page_size=self.page_size,
                hicache_ratio=server_args.hicache_ratio,
                hicache_size=server_args.hicache_size,
                hicache_write_policy=server_args.hicache_write_policy,
                hicache_io_backend=server_args.hicache_io_backend,
                hicache_mem_layout=server_args.hicache_mem_layout,
                hicache_storage_backend=server_args.hicache_storage_backend,
                hicache_storage_prefetch_policy=server_args.hicache_storage_prefetch_policy,
                model_name=server_args.served_model_name,
                storage_backend_extra_config=server_args.hicache_storage_backend_extra_config,
            )
            self.tp_worker.register_hicache_layer_transfer_counter(
                self.tree_cache.cache_controller.layer_done_counter
            )
        elif self.is_hybrid:
            assert (
                self.server_args.disaggregation_mode == &#34;null&#34;
            ), &#34;Hybrid mode does not support disaggregation yet&#34;
            self.tree_cache = SWARadixCache(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                sliding_window_size=self.sliding_window_size,
                page_size=self.page_size,
                disable=server_args.disable_radix_cache,
            )
        elif self.enable_lora:
            assert (
                not self.enable_hierarchical_cache
            ), &#34;LoRA radix cache doesn&#39;t support hierarchical cache&#34;
            assert (
                self.schedule_policy == &#34;fcfs&#34;
            ), &#34;LoRA radix cache only supports FCFS policy&#34;
            self.tree_cache = LoRARadixCache(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                page_size=self.page_size,
                disable=server_args.disable_radix_cache,
            )
        else:
            self.tree_cache = RadixCache(
                req_to_token_pool=self.req_to_token_pool,
                token_to_kv_pool_allocator=self.token_to_kv_pool_allocator,
                page_size=self.page_size,
                disable=server_args.disable_radix_cache,
                enable_kv_cache_events=self.enable_kv_cache_events,
            )

    self.decode_mem_cache_buf_multiplier = (
        1
        if self.spec_algorithm.is_none()
        else (
            server_args.speculative_num_draft_tokens
            + (
                server_args.speculative_eagle_topk
                * server_args.speculative_num_steps
            )
        )
    )

    embedding_cache_size = int(os.environ.get(&#34;SGLANG_VLM_CACHE_SIZE_MB&#34;, &#34;100&#34;))
    init_embedding_cache(embedding_cache_size * 1024 * 1024)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.init_moe_config"><code class="name flex">
<span>def <span class="ident">init_moe_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_moe_config(self):
    if hasattr(self.model_config.hf_config, &#34;num_experts_per_tok&#34;):
        initialize_moe_config(self.server_args)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.init_tokenizer"><code class="name flex">
<span>def <span class="ident">init_tokenizer</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_tokenizer(self):
    server_args = self.server_args
    self.is_generation = self.model_config.is_generation

    if server_args.skip_tokenizer_init:
        self.tokenizer = self.processor = None
    else:
        if self.model_config.is_multimodal:
            self.processor = get_processor(
                server_args.tokenizer_path,
                tokenizer_mode=server_args.tokenizer_mode,
                trust_remote_code=server_args.trust_remote_code,
                revision=server_args.revision,
                use_fast=not server_args.disable_fast_image_processor,
            )
            self.tokenizer = get_tokenizer_from_processor(self.processor)
        else:
            self.tokenizer = get_tokenizer(
                server_args.tokenizer_path,
                tokenizer_mode=server_args.tokenizer_mode,
                trust_remote_code=server_args.trust_remote_code,
                revision=server_args.revision,
            )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.load_lora_adapter"><code class="name flex">
<span>def <span class="ident">load_lora_adapter</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.LoadLoRAAdapterReqInput" href="io_struct.html#sglang.srt.managers.io_struct.LoadLoRAAdapterReqInput">LoadLoRAAdapterReqInput</a>) ‑> <a title="sglang.srt.managers.io_struct.LoRAUpdateResult" href="io_struct.html#sglang.srt.managers.io_struct.LoRAUpdateResult">LoRAUpdateResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_lora_adapter(
    self, recv_req: LoadLoRAAdapterReqInput
) -&gt; LoadLoRAAdapterReqOutput:
    &#34;&#34;&#34;In-place loading a new lora adapter from disk or huggingface.&#34;&#34;&#34;

    result = self.tp_worker.load_lora_adapter(recv_req)
    return result</code></pre>
</details>
<div class="desc"><p>In-place loading a new lora adapter from disk or huggingface.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.maybe_send_health_check_signal"><code class="name flex">
<span>def <span class="ident">maybe_send_health_check_signal</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maybe_send_health_check_signal(self):
    if self.return_health_check_ct:
        # Return some signal for the health check.
        # This is used to prevent the health check signal being blocked by long context prefill.
        # However, one minor issue is that this code path does not check the status of detokenizer manager.
        self.return_health_check_ct -= 1
        self.send_to_tokenizer.send_pyobj(HealthCheckOutput())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.maybe_sleep_on_idle"><code class="name flex">
<span>def <span class="ident">maybe_sleep_on_idle</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maybe_sleep_on_idle(self):
    if self.idle_sleeper is not None:
        self.idle_sleeper.maybe_sleep()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.move_ready_grammar_requests"><code class="name flex">
<span>def <span class="ident">move_ready_grammar_requests</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_ready_grammar_requests(self):
    &#34;&#34;&#34;Move requests whose grammar objects are ready from grammar_queue to waiting_queue.&#34;&#34;&#34;

    num_ready_reqs = 0
    num_timeout_reqs = 0
    for req in self.grammar_queue:
        try:
            if req.finished():  # It is aborted by AbortReq
                num_ready_reqs += 1
                continue
            req.grammar = req.grammar.result(timeout=0.03)
            self.grammar_backend.set_cache(req.grammar_key, req.grammar.copy())
            if req.grammar is INVALID_GRAMMAR_OBJ:
                req.set_finish_with_abort(
                    f&#34;Invalid grammar request: {req.grammar_key=}&#34;
                )
            num_ready_reqs += 1
        except futures._base.TimeoutError:
            req.grammar_wait_ct += 1
            # NOTE(lianmin): this timeout is the waiting time of the above line. It is
            # not the waiting time from it enters the grammar queue.
            if req.grammar_wait_ct &gt; GRAMMAR_TIMEOUT / 0.03:
                num_timeout_reqs = 1
            break

    if self.server_args.enable_dp_attention:
        tp_size = self.attn_tp_size
        tp_group = self.attn_tp_cpu_group
    else:
        tp_size = self.tp_size
        tp_group = self.tp_cpu_group

    if tp_size &gt; 1:
        # Sync across TP ranks to make sure they have the same number of ready requests
        tensor = torch.tensor([num_ready_reqs, num_timeout_reqs], dtype=torch.int32)
        torch.distributed.all_reduce(
            tensor, op=torch.distributed.ReduceOp.MAX, group=tp_group
        )
        num_ready_reqs_max, num_timeout_reqs_max = tensor.tolist()

        for i in range(num_ready_reqs, num_ready_reqs_max):
            req = self.grammar_queue[i]
            if req.finished():  # It is aborted by AbortReq
                continue
            req.grammar = req.grammar.result()
            self.grammar_backend.set_cache(req.grammar_key, req.grammar.copy())
            if req.grammar is INVALID_GRAMMAR_OBJ:
                req.set_finish_with_abort(
                    f&#34;Invalid grammar request: {req.grammar_key=}&#34;
                )
    else:
        num_ready_reqs_max = num_ready_reqs
        num_timeout_reqs_max = num_timeout_reqs

    for i in range(num_ready_reqs, num_ready_reqs + num_timeout_reqs_max):
        req = self.grammar_queue[i]
        req.grammar.cancel()
        error_msg = f&#34;Grammar preprocessing timed out for {req.grammar_key=}&#34;
        req.set_finish_with_abort(error_msg)
        self.grammar_backend.set_cache(req.grammar_key, INVALID_GRAMMAR_OBJ)
    num_ready_reqs = num_ready_reqs_max + num_timeout_reqs_max

    self._extend_requests_to_queue(self.grammar_queue[:num_ready_reqs])
    self.grammar_queue = self.grammar_queue[num_ready_reqs:]</code></pre>
</details>
<div class="desc"><p>Move requests whose grammar objects are ready from grammar_queue to waiting_queue.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.open_session"><code class="name flex">
<span>def <span class="ident">open_session</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.OpenSessionReqInput" href="io_struct.html#sglang.srt.managers.io_struct.OpenSessionReqInput">OpenSessionReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_session(self, recv_req: OpenSessionReqInput):
    # handle error
    session_id = recv_req.session_id
    if session_id in self.sessions:
        logger.warning(f&#34;session id {session_id} already exist, cannot open.&#34;)
        return OpenSessionReqOutput(session_id, False)
    elif session_id is None:
        logger.warning(&#34;session id is None, cannot open.&#34;)
        return OpenSessionReqOutput(session_id, False)
    else:
        self.sessions[session_id] = Session(
            recv_req.capacity_of_str_len, session_id
        )
        return OpenSessionReqOutput(session_id, True)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.prepare_mlp_sync_batch"><code class="name flex">
<span>def <span class="ident">prepare_mlp_sync_batch</span></span>(<span>self,<br>local_batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare_mlp_sync_batch(self, local_batch: ScheduleBatch):
    return self.prepare_mlp_sync_batch_raw(
        local_batch,
        dp_size=self.server_args.dp_size,
        attn_tp_size=self.attn_tp_size,
        tp_group=self.tp_group,
        get_idle_batch=self.get_idle_batch,
        disable_cuda_graph=self.server_args.disable_cuda_graph,
        spec_algorithm=self.spec_algorithm,
        speculative_num_draft_tokens=self.server_args.speculative_num_draft_tokens,
        require_mlp_tp_gather=require_mlp_tp_gather(self.server_args),
        disable_overlap_schedule=self.server_args.disable_overlap_schedule,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.process_batch_result"><code class="name flex">
<span>def <span class="ident">process_batch_result</span></span>(<span>self,<br>batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>,<br>result: <a title="sglang.srt.managers.scheduler.GenerationBatchResult" href="#sglang.srt.managers.scheduler.GenerationBatchResult">GenerationBatchResult</a> | <a title="sglang.srt.managers.scheduler.EmbeddingBatchResult" href="#sglang.srt.managers.scheduler.EmbeddingBatchResult">EmbeddingBatchResult</a>,<br>launch_done: threading.Event | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_batch_result(
    self,
    batch: ScheduleBatch,
    result: Union[GenerationBatchResult, EmbeddingBatchResult],
    launch_done: Optional[threading.Event] = None,
):
    if batch.forward_mode.is_decode():
        self.process_batch_result_decode(batch, result, launch_done)
    elif batch.forward_mode.is_extend():
        self.process_batch_result_prefill(batch, result, launch_done)
    elif batch.forward_mode.is_idle():
        if self.enable_overlap:
            self.tp_worker.resolve_last_batch_result(launch_done)
            self.set_next_batch_sampling_info_done(batch)
    elif batch.forward_mode.is_dummy_first():
        self.set_next_batch_sampling_info_done(batch)

    self.maybe_send_health_check_signal()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.process_input_requests"><code class="name flex">
<span>def <span class="ident">process_input_requests</span></span>(<span>self, recv_reqs: List)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_input_requests(self, recv_reqs: List):
    for recv_req in recv_reqs:
        # If it is a health check generation request and there are running requests, ignore it.
        if is_health_check_generate_req(recv_req) and (
            self.chunked_req is not None
            or not self.running_batch.is_empty()
            or len(self.offload_tags) &gt; 0
        ):
            self.return_health_check_ct += 1
            continue

        # If it is a work request, accept or reject the request based on the request queue size.
        if is_work_request(recv_req):
            if len(self.waiting_queue) + 1 &gt; self.max_queued_requests:
                abort_req = AbortReq(
                    recv_req.rid,
                    finished_reason={
                        &#34;type&#34;: &#34;abort&#34;,
                        &#34;status_code&#34;: HTTPStatus.SERVICE_UNAVAILABLE,
                        &#34;message&#34;: &#34;The request queue is full.&#34;,
                    },
                )
                self.send_to_tokenizer.send_pyobj(abort_req)
                continue
        output = self._request_dispatcher(recv_req)
        if output is not None:
            if isinstance(output, RpcReqOutput):
                if self.recv_from_rpc is not None:
                    self.recv_from_rpc.send_pyobj(output)
            else:
                self.send_to_tokenizer.send_pyobj(output)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.recv_requests"><code class="name flex">
<span>def <span class="ident">recv_requests</span></span>(<span>self) ‑> List[<a title="sglang.srt.managers.schedule_batch.Req" href="schedule_batch.html#sglang.srt.managers.schedule_batch.Req">Req</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_requests(self) -&gt; List[Req]:
    &#34;&#34;&#34;Receive results at tp_rank = 0 and broadcast it to all other TP ranks.&#34;&#34;&#34;

    if self.recv_skipper is not None:
        last_forward_mode = (
            self.last_batch.forward_mode if self.last_batch is not None else None
        )
        if not self.recv_skipper.handle(last_forward_mode):
            return []

    if self.pp_rank == 0:
        if self.attn_tp_rank == 0:
            recv_reqs = []

            while True:
                try:
                    recv_req = self.recv_from_tokenizer.recv_pyobj(zmq.NOBLOCK)
                except zmq.ZMQError:
                    break
                recv_reqs.append(recv_req)

            while True:
                try:
                    recv_rpc = self.recv_from_rpc.recv_pyobj(zmq.NOBLOCK)
                except zmq.ZMQError:
                    break
                recv_reqs.append(recv_rpc)
        else:
            recv_reqs = None
    else:
        if self.attn_tp_rank == 0:
            dp_offset = self.attn_dp_rank * self.attn_tp_size
            recv_reqs = point_to_point_pyobj(
                [],
                self.pp_rank * self.tp_size + dp_offset,
                self.world_group.device_group,
                (self.pp_rank - 1) * self.tp_size + dp_offset,
                self.pp_rank * self.tp_size + dp_offset,
            )
        else:
            recv_reqs = None

    if self.input_blocker is not None:
        recv_reqs = self.input_blocker.handle(recv_reqs)

    if self.server_args.enable_dp_attention:
        if self.attn_tp_rank == 0:
            work_reqs = [
                req
                for req in recv_reqs
                if isinstance(
                    req,
                    (
                        TokenizedGenerateReqInput,
                        TokenizedEmbeddingReqInput,
                        BatchTokenizedGenerateReqInput,
                        BatchTokenizedEmbeddingReqInput,
                    ),
                )
            ]
            control_reqs = [
                req
                for req in recv_reqs
                if not isinstance(
                    req,
                    (
                        TokenizedGenerateReqInput,
                        TokenizedEmbeddingReqInput,
                        BatchTokenizedGenerateReqInput,
                        BatchTokenizedEmbeddingReqInput,
                    ),
                )
            ]
        else:
            work_reqs = None
            control_reqs = None

        if self.attn_tp_size != 1:
            work_reqs = broadcast_pyobj(
                work_reqs,
                self.attn_tp_group.rank,
                self.attn_tp_cpu_group,
                src=self.attn_tp_group.ranks[0],
            )
        if self.tp_size != 1:
            control_reqs = broadcast_pyobj(
                control_reqs,
                self.tp_group.rank,
                self.tp_cpu_group,
                src=self.tp_group.ranks[0],
            )
        recv_reqs = work_reqs + control_reqs
    elif self.tp_size != 1:
        recv_reqs = broadcast_pyobj(
            recv_reqs,
            self.tp_group.rank,
            self.tp_cpu_group,
            src=self.tp_group.ranks[0],
        )
    return recv_reqs</code></pre>
</details>
<div class="desc"><p>Receive results at tp_rank = 0 and broadcast it to all other TP ranks.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.run_batch"><code class="name flex">
<span>def <span class="ident">run_batch</span></span>(<span>self,<br>batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>) ‑> <a title="sglang.srt.managers.scheduler.GenerationBatchResult" href="#sglang.srt.managers.scheduler.GenerationBatchResult">GenerationBatchResult</a> | <a title="sglang.srt.managers.scheduler.EmbeddingBatchResult" href="#sglang.srt.managers.scheduler.EmbeddingBatchResult">EmbeddingBatchResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_batch(
    self, batch: ScheduleBatch
) -&gt; Union[GenerationBatchResult, EmbeddingBatchResult]:
    &#34;&#34;&#34;Run a batch.&#34;&#34;&#34;
    self.forward_ct += 1

    # Whether to run the profiler
    self._profile_batch_predicate(batch)
    if self.forward_sleep_time is not None:
        logger.info(f&#34;Scheduler.run_batch sleep {self.forward_sleep_time}s&#34;)
        time.sleep(self.forward_sleep_time)

    # Run forward
    if self.is_generation:
        if self.spec_algorithm.is_none():
            model_worker_batch = batch.get_model_worker_batch()

            # update the consumer index of hicache to the running batch
            self.tp_worker.set_hicache_consumer(
                model_worker_batch.hicache_consumer_index
            )
            if self.pp_group.is_last_rank:
                logits_output, next_token_ids, can_run_cuda_graph = (
                    self.tp_worker.forward_batch_generation(model_worker_batch)
                )
            else:
                pp_hidden_states_proxy_tensors, _, can_run_cuda_graph = (
                    self.tp_worker.forward_batch_generation(model_worker_batch)
                )
            bid = model_worker_batch.bid
        else:
            (
                logits_output,
                next_token_ids,
                bid,
                num_accepted_tokens,
                can_run_cuda_graph,
            ) = self.draft_worker.forward_batch_speculative_generation(batch)
            bs = batch.batch_size()
            self.spec_num_total_accepted_tokens += num_accepted_tokens + bs
            self.spec_num_total_forward_ct += bs
            self.num_generated_tokens += num_accepted_tokens

        if self.pp_group.is_last_rank:
            batch.output_ids = next_token_ids

        # These 2 values are needed for processing the output, but the values can be
        # modified by overlap schedule. So we have to copy them here so that
        # we can use the correct values in output processing.
        if batch.return_logprob or self.spec_algorithm.is_eagle():
            extend_input_len_per_req = [req.extend_input_len for req in batch.reqs]
        else:
            extend_input_len_per_req = None
        if batch.return_logprob:
            extend_logprob_start_len_per_req = [
                req.extend_logprob_start_len for req in batch.reqs
            ]
        else:
            extend_logprob_start_len_per_req = None

        ret = GenerationBatchResult(
            logits_output=logits_output if self.pp_group.is_last_rank else None,
            pp_hidden_states_proxy_tensors=(
                pp_hidden_states_proxy_tensors
                if not self.pp_group.is_last_rank
                else None
            ),
            next_token_ids=next_token_ids if self.pp_group.is_last_rank else None,
            extend_input_len_per_req=extend_input_len_per_req,
            extend_logprob_start_len_per_req=extend_logprob_start_len_per_req,
            bid=bid,
            can_run_cuda_graph=can_run_cuda_graph,
        )
    else:  # embedding or reward model
        model_worker_batch = batch.get_model_worker_batch()
        embeddings = self.tp_worker.forward_batch_embedding(model_worker_batch)
        ret = EmbeddingBatchResult(
            embeddings=embeddings, bid=model_worker_batch.bid
        )
    return ret</code></pre>
</details>
<div class="desc"><p>Run a batch.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.self_check_during_idle"><code class="name flex">
<span>def <span class="ident">self_check_during_idle</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def self_check_during_idle(self):
    self.check_memory()
    self.check_tree_cache()
    self.new_token_ratio = self.init_new_token_ratio
    self.maybe_sleep_on_idle()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.set_internal_state"><code class="name flex">
<span>def <span class="ident">set_internal_state</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.SetInternalStateReq" href="io_struct.html#sglang.srt.managers.io_struct.SetInternalStateReq">SetInternalStateReq</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_internal_state(self, recv_req: SetInternalStateReq):
    server_args_dict = recv_req.server_args
    args_allow_update = set(
        [
            &#34;max_micro_batch_size&#34;,
            &#34;speculative_accept_threshold_single&#34;,
            &#34;speculative_accept_threshold_acc&#34;,
        ]
    )
    if_success = True
    for k, v in server_args_dict.items():
        if k not in args_allow_update:
            logging.warning(f&#34;Updating {k} is not supported.&#34;)
            if_success = False
            break
        elif k == &#34;max_micro_batch_size&#34; and (
            v &gt; self.max_running_requests // self.pp_size or v &lt; 1
        ):
            logging.warning(
                f&#34;Updating {k} to {v} is rejected because it is out of the valid range [1, {self.max_running_requests // self.pp_size}].&#34;
            )
            if_success = False
            break
    if if_success:
        if not self.spec_algorithm.is_none() and self.cum_spec_accept_count &gt; 0:
            avg_spec_accept_length = (
                self.cum_spec_accept_length / self.cum_spec_accept_count
            )
            logger.info(f&#34;{avg_spec_accept_length=}&#34;)
        self.cum_spec_accept_length = self.cum_spec_accept_count = 0
        for k, v in server_args_dict.items():
            global_server_args_dict[k] = v
        logger.info(f&#34;Global server args updated! {global_server_args_dict=}&#34;)
    return SetInternalStateReqOutput(
        updated=True,
        server_args=global_server_args_dict,
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.set_next_batch_sampling_info_done"><code class="name flex">
<span>def <span class="ident">set_next_batch_sampling_info_done</span></span>(<span>self,<br>batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_next_batch_sampling_info_done(self, batch: ScheduleBatch):
    if batch.next_batch_sampling_info:
        if batch.next_batch_sampling_info.grammars is not None:
            batch.next_batch_sampling_info.update_regex_vocab_mask()
            self.current_stream.synchronize()
        batch.next_batch_sampling_info.sampling_info_done.set()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.slow_down"><code class="name flex">
<span>def <span class="ident">slow_down</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.SlowDownReqInput" href="io_struct.html#sglang.srt.managers.io_struct.SlowDownReqInput">SlowDownReqInput</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slow_down(self, recv_req: SlowDownReqInput):
    t = recv_req.forward_sleep_time
    if t is not None and t &lt;= 0:
        t = None
    self.forward_sleep_time = t
    return SlowDownReqOutput()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.unload_lora_adapter"><code class="name flex">
<span>def <span class="ident">unload_lora_adapter</span></span>(<span>self,<br>recv_req: <a title="sglang.srt.managers.io_struct.UnloadLoRAAdapterReqInput" href="io_struct.html#sglang.srt.managers.io_struct.UnloadLoRAAdapterReqInput">UnloadLoRAAdapterReqInput</a>) ‑> <a title="sglang.srt.managers.io_struct.LoRAUpdateResult" href="io_struct.html#sglang.srt.managers.io_struct.LoRAUpdateResult">LoRAUpdateResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unload_lora_adapter(
    self, recv_req: UnloadLoRAAdapterReqInput
) -&gt; UnloadLoRAAdapterReqOutput:
    &#34;&#34;&#34;Unload the lora adapter.&#34;&#34;&#34;

    result = self.tp_worker.unload_lora_adapter(recv_req)
    return result</code></pre>
</details>
<div class="desc"><p>Unload the lora adapter.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.update_running_batch"><code class="name flex">
<span>def <span class="ident">update_running_batch</span></span>(<span>self,<br>batch: <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a>) ‑> <a title="sglang.srt.managers.schedule_batch.ScheduleBatch" href="schedule_batch.html#sglang.srt.managers.schedule_batch.ScheduleBatch">ScheduleBatch</a> | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_running_batch(self, batch: ScheduleBatch) -&gt; Optional[ScheduleBatch]:
    &#34;&#34;&#34;Update the current running decoding batch.&#34;&#34;&#34;
    initial_bs = batch.batch_size()

    batch.filter_batch()
    if batch.is_empty():
        batch.batch_is_full = False
        return batch

    # Check if decode out of memory
    if not batch.check_decode_mem(self.decode_mem_cache_buf_multiplier) or (
        TEST_RETRACT and batch.batch_size() &gt; 10
    ):
        old_ratio = self.new_token_ratio

        retracted_reqs, new_token_ratio = batch.retract_decode(self.server_args)
        num_retracted_reqs = len(retracted_reqs)
        self.new_token_ratio = new_token_ratio

        logger.info(
            &#34;KV cache pool is full. Retract requests. &#34;
            f&#34;#retracted_reqs: {num_retracted_reqs}, &#34;
            f&#34;#new_token_ratio: {old_ratio:.4f} -&gt; {self.new_token_ratio:.4f}&#34;
        )

        self._extend_requests_to_queue(retracted_reqs, is_retracted=True)
        self.total_retracted_reqs += num_retracted_reqs
    else:
        self.new_token_ratio = max(
            self.new_token_ratio - self.new_token_ratio_decay,
            self.min_new_token_ratio,
        )

    if batch.batch_size() &lt; initial_bs:
        batch.batch_is_full = False

    # Update batch tensors
    batch.prepare_for_decode()
    return batch</code></pre>
</details>
<div class="desc"><p>Update the current running decoding batch.</p></div>
</dd>
<dt id="sglang.srt.managers.scheduler.Scheduler.watchdog_thread"><code class="name flex">
<span>def <span class="ident">watchdog_thread</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def watchdog_thread(self):
    &#34;&#34;&#34;A watch dog thread that will try to kill the server itself if one forward batch takes too long.&#34;&#34;&#34;
    self.watchdog_last_forward_ct = 0
    self.watchdog_last_time = time.perf_counter()

    while True:
        current = time.perf_counter()
        if self.cur_batch is not None:
            if self.watchdog_last_forward_ct == self.forward_ct:
                if current &gt; self.watchdog_last_time + self.watchdog_timeout:
                    break
            else:
                self.watchdog_last_forward_ct = self.forward_ct
                self.watchdog_last_time = current
        time.sleep(self.watchdog_timeout // 2)

    if not disable_request_logging():
        # Print batch size and memory pool info to check whether there are de-sync issues.
        if self.is_hybrid:
            (
                _,
                _,
                _,
                _,
                full_available_size,
                full_evictable_size,
                swa_available_size,
                swa_evictable_size,
            ) = self._get_swa_token_info()
            info_msg = (
                f&#34;{full_available_size=}, &#34;
                f&#34;{full_evictable_size=}, &#34;
                f&#34;{swa_available_size=}, &#34;
                f&#34;{swa_evictable_size=}, &#34;
            )
        else:
            _, _, available_size, evictable_size = self._get_token_info()
            info_msg = f&#34;{available_size=}, &#34; f&#34;{evictable_size=}, &#34;
        logger.error(
            f&#34;{self.cur_batch.batch_size()=}, &#34;
            f&#34;{self.cur_batch.reqs=}, &#34;
            f&#34;{info_msg}&#34;
        )

    pyspy_dump_schedulers()
    logger.error(f&#34;Watchdog timeout ({self.watchdog_timeout=})&#34;)
    print(file=sys.stderr, flush=True)
    print(file=sys.stdout, flush=True)

    # Wait for some time so that the parent process can print the error.
    time.sleep(5)
    self.parent_process.send_signal(signal.SIGQUIT)</code></pre>
</details>
<div class="desc"><p>A watch dog thread that will try to kill the server itself if one forward batch takes too long.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin" href="scheduler_output_processor_mixin.html#sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin">SchedulerOutputProcessorMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin.add_input_logprob_return_values" href="scheduler_output_processor_mixin.html#sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin.add_input_logprob_return_values">add_input_logprob_return_values</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin.add_logprob_return_values" href="scheduler_output_processor_mixin.html#sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin.add_logprob_return_values">add_logprob_return_values</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin.stream_output" href="scheduler_output_processor_mixin.html#sglang.srt.managers.scheduler_output_processor_mixin.SchedulerOutputProcessorMixin.stream_output">stream_output</a></code></li>
</ul>
</li>
<li><code><b><a title="sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin" href="scheduler_update_weights_mixin.html#sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin">SchedulerUpdateWeightsMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.init_weights_update_group" href="scheduler_update_weights_mixin.html#sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.init_weights_update_group">init_weights_update_group</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.update_weights_from_disk" href="scheduler_update_weights_mixin.html#sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.update_weights_from_disk">update_weights_from_disk</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.update_weights_from_distributed" href="scheduler_update_weights_mixin.html#sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.update_weights_from_distributed">update_weights_from_distributed</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.update_weights_from_tensor" href="scheduler_update_weights_mixin.html#sglang.srt.managers.scheduler_update_weights_mixin.SchedulerUpdateWeightsMixin.update_weights_from_tensor">update_weights_from_tensor</a></code></li>
</ul>
</li>
<li><code><b><a title="sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin" href="../disaggregation/decode.html#sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin">SchedulerDisaggregationDecodeMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin.event_loop_normal_disagg_decode" href="../disaggregation/decode.html#sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin.event_loop_normal_disagg_decode">event_loop_normal_disagg_decode</a></code></li>
<li><code><a title="sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin.get_new_prebuilt_batch" href="../disaggregation/decode.html#sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin.get_new_prebuilt_batch">get_new_prebuilt_batch</a></code></li>
<li><code><a title="sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin.get_next_disagg_decode_batch_to_run" href="../disaggregation/decode.html#sglang.srt.disaggregation.decode.SchedulerDisaggregationDecodeMixin.get_next_disagg_decode_batch_to_run">get_next_disagg_decode_batch_to_run</a></code></li>
</ul>
</li>
<li><code><b><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin">SchedulerDisaggregationPrefillMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_normal_disagg_prefill" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_normal_disagg_prefill">event_loop_normal_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_pp_disagg_prefill" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_pp_disagg_prefill">event_loop_pp_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.get_transferred_rids" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.get_transferred_rids">get_transferred_rids</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_batch_result_disagg_prefill" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_batch_result_disagg_prefill">process_batch_result_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_disagg_prefill_inflight_queue" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_disagg_prefill_inflight_queue">process_disagg_prefill_inflight_queue</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_kv_chunk" href="../disaggregation/prefill.html#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_kv_chunk">send_kv_chunk</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.managers" href="index.html">sglang.srt.managers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sglang.srt.managers.scheduler.is_health_check_generate_req" href="#sglang.srt.managers.scheduler.is_health_check_generate_req">is_health_check_generate_req</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.is_work_request" href="#sglang.srt.managers.scheduler.is_work_request">is_work_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.run_scheduler_process" href="#sglang.srt.managers.scheduler.run_scheduler_process">run_scheduler_process</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.managers.scheduler.EmbeddingBatchResult" href="#sglang.srt.managers.scheduler.EmbeddingBatchResult">EmbeddingBatchResult</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.managers.scheduler.EmbeddingBatchResult.bid" href="#sglang.srt.managers.scheduler.EmbeddingBatchResult.bid">bid</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.EmbeddingBatchResult.embeddings" href="#sglang.srt.managers.scheduler.EmbeddingBatchResult.embeddings">embeddings</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult" href="#sglang.srt.managers.scheduler.GenerationBatchResult">GenerationBatchResult</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.bid" href="#sglang.srt.managers.scheduler.GenerationBatchResult.bid">bid</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.can_run_cuda_graph" href="#sglang.srt.managers.scheduler.GenerationBatchResult.can_run_cuda_graph">can_run_cuda_graph</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.extend_input_len_per_req" href="#sglang.srt.managers.scheduler.GenerationBatchResult.extend_input_len_per_req">extend_input_len_per_req</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.extend_logprob_start_len_per_req" href="#sglang.srt.managers.scheduler.GenerationBatchResult.extend_logprob_start_len_per_req">extend_logprob_start_len_per_req</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.logits_output" href="#sglang.srt.managers.scheduler.GenerationBatchResult.logits_output">logits_output</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.next_token_ids" href="#sglang.srt.managers.scheduler.GenerationBatchResult.next_token_ids">next_token_ids</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.GenerationBatchResult.pp_hidden_states_proxy_tensors" href="#sglang.srt.managers.scheduler.GenerationBatchResult.pp_hidden_states_proxy_tensors">pp_hidden_states_proxy_tensors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.managers.scheduler.IdleSleeper" href="#sglang.srt.managers.scheduler.IdleSleeper">IdleSleeper</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.managers.scheduler.IdleSleeper.maybe_sleep" href="#sglang.srt.managers.scheduler.IdleSleeper.maybe_sleep">maybe_sleep</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.managers.scheduler.Scheduler" href="#sglang.srt.managers.scheduler.Scheduler">Scheduler</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.abort_request" href="#sglang.srt.managers.scheduler.Scheduler.abort_request">abort_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.check_memory" href="#sglang.srt.managers.scheduler.Scheduler.check_memory">check_memory</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.check_tree_cache" href="#sglang.srt.managers.scheduler.Scheduler.check_tree_cache">check_tree_cache</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.clear_hicache_storage_wrapped" href="#sglang.srt.managers.scheduler.Scheduler.clear_hicache_storage_wrapped">clear_hicache_storage_wrapped</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.close_session" href="#sglang.srt.managers.scheduler.Scheduler.close_session">close_session</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.current_scheduler_metrics_enabled" href="#sglang.srt.managers.scheduler.Scheduler.current_scheduler_metrics_enabled">current_scheduler_metrics_enabled</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.event_loop_normal" href="#sglang.srt.managers.scheduler.Scheduler.event_loop_normal">event_loop_normal</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.event_loop_overlap" href="#sglang.srt.managers.scheduler.Scheduler.event_loop_overlap">event_loop_overlap</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.event_loop_pp" href="#sglang.srt.managers.scheduler.Scheduler.event_loop_pp">event_loop_pp</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.expert_distribution_handle" href="#sglang.srt.managers.scheduler.Scheduler.expert_distribution_handle">expert_distribution_handle</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.flush_cache" href="#sglang.srt.managers.scheduler.Scheduler.flush_cache">flush_cache</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.flush_cache_wrapped" href="#sglang.srt.managers.scheduler.Scheduler.flush_cache_wrapped">flush_cache_wrapped</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_idle_batch" href="#sglang.srt.managers.scheduler.Scheduler.get_idle_batch">get_idle_batch</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_internal_state" href="#sglang.srt.managers.scheduler.Scheduler.get_internal_state">get_internal_state</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_load" href="#sglang.srt.managers.scheduler.Scheduler.get_load">get_load</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_new_batch_prefill" href="#sglang.srt.managers.scheduler.Scheduler.get_new_batch_prefill">get_new_batch_prefill</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_next_batch_to_run" href="#sglang.srt.managers.scheduler.Scheduler.get_next_batch_to_run">get_next_batch_to_run</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_num_allocatable_reqs" href="#sglang.srt.managers.scheduler.Scheduler.get_num_allocatable_reqs">get_num_allocatable_reqs</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.get_print_prefix" href="#sglang.srt.managers.scheduler.Scheduler.get_print_prefix">get_print_prefix</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_batch_embedding_request" href="#sglang.srt.managers.scheduler.Scheduler.handle_batch_embedding_request">handle_batch_embedding_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_batch_generate_request" href="#sglang.srt.managers.scheduler.Scheduler.handle_batch_generate_request">handle_batch_generate_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_dp_balance_data" href="#sglang.srt.managers.scheduler.Scheduler.handle_dp_balance_data">handle_dp_balance_data</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_embedding_request" href="#sglang.srt.managers.scheduler.Scheduler.handle_embedding_request">handle_embedding_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_freeze_gc" href="#sglang.srt.managers.scheduler.Scheduler.handle_freeze_gc">handle_freeze_gc</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_generate_request" href="#sglang.srt.managers.scheduler.Scheduler.handle_generate_request">handle_generate_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.handle_rpc_request" href="#sglang.srt.managers.scheduler.Scheduler.handle_rpc_request">handle_rpc_request</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.init_disaggregation" href="#sglang.srt.managers.scheduler.Scheduler.init_disaggregation">init_disaggregation</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.init_memory_pool_and_cache" href="#sglang.srt.managers.scheduler.Scheduler.init_memory_pool_and_cache">init_memory_pool_and_cache</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.init_moe_config" href="#sglang.srt.managers.scheduler.Scheduler.init_moe_config">init_moe_config</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.init_tokenizer" href="#sglang.srt.managers.scheduler.Scheduler.init_tokenizer">init_tokenizer</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.load_lora_adapter" href="#sglang.srt.managers.scheduler.Scheduler.load_lora_adapter">load_lora_adapter</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.maybe_send_health_check_signal" href="#sglang.srt.managers.scheduler.Scheduler.maybe_send_health_check_signal">maybe_send_health_check_signal</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.maybe_sleep_on_idle" href="#sglang.srt.managers.scheduler.Scheduler.maybe_sleep_on_idle">maybe_sleep_on_idle</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.move_ready_grammar_requests" href="#sglang.srt.managers.scheduler.Scheduler.move_ready_grammar_requests">move_ready_grammar_requests</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.open_session" href="#sglang.srt.managers.scheduler.Scheduler.open_session">open_session</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.prepare_mlp_sync_batch" href="#sglang.srt.managers.scheduler.Scheduler.prepare_mlp_sync_batch">prepare_mlp_sync_batch</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.prepare_mlp_sync_batch_raw" href="#sglang.srt.managers.scheduler.Scheduler.prepare_mlp_sync_batch_raw">prepare_mlp_sync_batch_raw</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.process_batch_result" href="#sglang.srt.managers.scheduler.Scheduler.process_batch_result">process_batch_result</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.process_input_requests" href="#sglang.srt.managers.scheduler.Scheduler.process_input_requests">process_input_requests</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.recv_requests" href="#sglang.srt.managers.scheduler.Scheduler.recv_requests">recv_requests</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.run_batch" href="#sglang.srt.managers.scheduler.Scheduler.run_batch">run_batch</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.self_check_during_idle" href="#sglang.srt.managers.scheduler.Scheduler.self_check_during_idle">self_check_during_idle</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.set_internal_state" href="#sglang.srt.managers.scheduler.Scheduler.set_internal_state">set_internal_state</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.set_next_batch_sampling_info_done" href="#sglang.srt.managers.scheduler.Scheduler.set_next_batch_sampling_info_done">set_next_batch_sampling_info_done</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.slow_down" href="#sglang.srt.managers.scheduler.Scheduler.slow_down">slow_down</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.unload_lora_adapter" href="#sglang.srt.managers.scheduler.Scheduler.unload_lora_adapter">unload_lora_adapter</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.update_running_batch" href="#sglang.srt.managers.scheduler.Scheduler.update_running_batch">update_running_batch</a></code></li>
<li><code><a title="sglang.srt.managers.scheduler.Scheduler.watchdog_thread" href="#sglang.srt.managers.scheduler.Scheduler.watchdog_thread">watchdog_thread</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
