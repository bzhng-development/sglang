<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.lora.lora_registry API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.lora.lora_registry</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.lora.lora_registry.LoRARef"><code class="flex name class">
<span>class <span class="ident">LoRARef</span></span>
<span>(</span><span>lora_id: str = &lt;factory&gt;,<br>lora_name: str | None = None,<br>lora_path: str | None = None,<br>pinned: bool | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(frozen=True)
class LoRARef:
    &#34;&#34;&#34;
    Reference record for a LoRA model.

    This object guarantees a unique ``lora_id`` and may include ``lora_name``, ``lora_path``, and ``pinned``.
    The ID eliminates conflicts from reused LoRA names or paths and can be used to generate deterministic cache
    keys (e.g., radix cache).
    &#34;&#34;&#34;

    lora_id: str = field(default_factory=lambda: uuid4().hex)
    lora_name: Optional[str] = None
    lora_path: Optional[str] = None
    pinned: Optional[bool] = None

    def __post_init__(self):
        if self.lora_id is None:
            raise ValueError(&#34;lora_id cannot be None&#34;)

    def __str__(self) -&gt; str:
        parts = [
            f&#34;{f.name}={value}&#34;
            for f in fields(self)
            if (value := getattr(self, f.name)) is not None
        ]
        return f&#34;{self.__class__.__name__}({&#39;, &#39;.join(parts)})&#34;</code></pre>
</details>
<div class="desc"><p>Reference record for a LoRA model.</p>
<p>This object guarantees a unique <code>lora_id</code> and may include <code>lora_name</code>, <code>lora_path</code>, and <code>pinned</code>.
The ID eliminates conflicts from reused LoRA names or paths and can be used to generate deterministic cache
keys (e.g., radix cache).</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sglang.srt.lora.lora_registry.LoRARef.lora_id"><code class="name">var <span class="ident">lora_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARef.lora_name"><code class="name">var <span class="ident">lora_name</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARef.lora_path"><code class="name">var <span class="ident">lora_path</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARef.pinned"><code class="name">var <span class="ident">pinned</span> : bool | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry"><code class="flex name class">
<span>class <span class="ident">LoRARegistry</span></span>
<span>(</span><span>lora_paths: List[<a title="sglang.srt.lora.lora_registry.LoRARef" href="#sglang.srt.lora.lora_registry.LoRARef">LoRARef</a>] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoRARegistry:
    &#34;&#34;&#34;
    The central registry to keep track of available LoRA adapters and ongoing LoRA requests.

    The `LoRARegistry` resides in the tokenizer manager process and acts as the single source of truth for all
    available LoRA adapters. It supports concurrent inference and dynamic adapter updates through a two-phase
    update / eventual consistency model between the tokenizer manager process and the scheduler processes.
    &#34;&#34;&#34;

    def __init__(self, lora_paths: Optional[List[LoRARef]] = None):
        assert lora_paths is None or all(
            isinstance(lora, LoRARef) for lora in lora_paths
        ), (
            &#34;server_args.lora_paths should have been normalized to LoRARef objects during server initialization. &#34;
            &#34;Please file an issue if you see this error.&#34;
        )

        # A read-write lock to ensure adapters loading / unloading operations are exclusive.
        # Please note that the counter increment/decrement operations are not synchronized through this
        # lock, as they are designed to be non-blocking and can be performed concurrently.
        self._registry_lock = RWLock()
        # A dictionary to hold LoRARef objects, mapping from LoRA name to LoRARef.
        self._registry: Dict[str, LoRARef] = {}
        # Counters for ongoing requests, mapping from LoRA ID to ConcurrentCounter.
        self._counters: Dict[str, ConcurrentCounter] = {}

        # Initialize the registry with provided LoRA paths, if present.
        if lora_paths:
            for lora_ref in lora_paths:
                self._register_adapter(lora_ref)

    async def register(self, lora_ref: LoRARef):
        &#34;&#34;&#34;
        Register a new LoRARef object in the registry.

        Args:
            lora_ref (LoRARef): The LoRARef object to register.
        &#34;&#34;&#34;
        async with self._registry_lock.writer_lock:
            self._register_adapter(lora_ref)

    async def unregister(self, lora_name: str) -&gt; str:
        &#34;&#34;&#34;
        Unregister a LoRARef object from the registry and returns the removed LoRA ID.

        Args:
            lora_name (str): The name of the LoRA model to unregister.
        &#34;&#34;&#34;
        async with self._registry_lock.writer_lock:
            lora_ref = self._registry.get(lora_name, None)
            if lora_ref is None:
                raise ValueError(
                    f&#34;LoRA with name {lora_name} does not exist. Loaded LoRAs: {self._registry.keys()}&#34;
                )
            del self._registry[lora_name]

        return lora_ref.lora_id

    async def acquire(self, lora_name: Union[str, List[str]]) -&gt; Union[str, List[str]]:
        &#34;&#34;&#34;
        Queries registry for LoRA IDs based on LoRA names and start tracking the usage of the corresponding LoRA adapters
        by incrementing its counter.
        &#34;&#34;&#34;

        def _lookup(name: str) -&gt; str:
            if name is None:
                return None

            lora_ref = self._registry.get(name, None)
            if lora_ref is None:
                raise ValueError(
                    f&#34;The following requested LoRA adapters are not loaded: {name}\n&#34;
                    f&#34;Loaded adapters: {self._registry.keys()}.&#34;
                )
            return lora_ref.lora_id

        async with self._registry_lock.reader_lock:
            if isinstance(lora_name, str):
                lora_id = _lookup(lora_name)
                await self._counters[lora_id].increment(notify_all=False)
                return lora_id
            elif isinstance(lora_name, list):
                lora_ids = [_lookup(name) for name in lora_name]

                # Increment the counters only after all IDs are looked up.
                await asyncio.gather(
                    *[
                        self._counters[id].increment(notify_all=False)
                        for id in lora_ids
                        if id is not None
                    ]
                )
                return lora_ids
            else:
                raise TypeError(
                    &#34;lora_name must be either a string or a list of strings.&#34;
                )

    async def release(self, lora_id: Union[str, List[str]]):
        &#34;&#34;&#34;
        Decrements the usage counter for a LoRA adapter, indicating that it is no longer in use.
        &#34;&#34;&#34;

        async with self._registry_lock.reader_lock:
            if isinstance(lora_id, str):
                await self._counters[lora_id].decrement()
            elif isinstance(lora_id, list):
                await asyncio.gather(
                    *[
                        self._counters[id].decrement()
                        for id in lora_id
                        if id is not None
                    ]
                )
            else:
                raise TypeError(&#34;lora_id must be either a string or a list of strings.&#34;)

    async def wait_for_unload(self, lora_id: str):
        &#34;&#34;&#34;
        Waits until the usage counter for a LoRA adapter reaches zero, indicating that it is no longer in use.
        This is useful for ensuring that a LoRA adapter can be safely unloaded.

        This method itself is not synchronized, which is safe because it should only be called during LoRA unloading,
        which itself is guaranteed to be sequential.
        &#34;&#34;&#34;
        assert (
            lora_id not in self._registry
        ), &#34;wait_for_unload should only be called after the LoRA adapter has been unregistered. &#34;
        assert (
            lora_id in self._counters
        ), &#34;The LoRA ID should still have a counter if it has been registered before.&#34;

        # Wait until no requests are using this LoRA adapter.
        await self._counters[lora_id].wait_for_zero()
        del self._counters[lora_id]

    def _register_adapter(self, lora_ref: LoRARef):
        &#34;&#34;&#34;
        Internal helper method to register a LoRA adapter.
        &#34;&#34;&#34;

        if lora_ref.lora_name in self._registry:
            raise ValueError(
                f&#34;LoRA with name {lora_ref.lora_name} already exists. Loaded LoRAs: {self._registry.keys()}&#34;
            )
        self._registry[lora_ref.lora_name] = lora_ref
        self._counters[lora_ref.lora_id] = ConcurrentCounter()
        return lora_ref

    @property
    def num_registered_loras(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the total number of LoRA adapters currently registered.
        &#34;&#34;&#34;
        return len(self._registry)</code></pre>
</details>
<div class="desc"><p>The central registry to keep track of available LoRA adapters and ongoing LoRA requests.</p>
<p>The <code><a title="sglang.srt.lora.lora_registry.LoRARegistry" href="#sglang.srt.lora.lora_registry.LoRARegistry">LoRARegistry</a></code> resides in the tokenizer manager process and acts as the single source of truth for all
available LoRA adapters. It supports concurrent inference and dynamic adapter updates through a two-phase
update / eventual consistency model between the tokenizer manager process and the scheduler processes.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry.num_registered_loras"><code class="name">prop <span class="ident">num_registered_loras</span> : int</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_registered_loras(self) -&gt; int:
    &#34;&#34;&#34;
    Returns the total number of LoRA adapters currently registered.
    &#34;&#34;&#34;
    return len(self._registry)</code></pre>
</details>
<div class="desc"><p>Returns the total number of LoRA adapters currently registered.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry.acquire"><code class="name flex">
<span>async def <span class="ident">acquire</span></span>(<span>self, lora_name: str | List[str]) ‑> str | List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def acquire(self, lora_name: Union[str, List[str]]) -&gt; Union[str, List[str]]:
    &#34;&#34;&#34;
    Queries registry for LoRA IDs based on LoRA names and start tracking the usage of the corresponding LoRA adapters
    by incrementing its counter.
    &#34;&#34;&#34;

    def _lookup(name: str) -&gt; str:
        if name is None:
            return None

        lora_ref = self._registry.get(name, None)
        if lora_ref is None:
            raise ValueError(
                f&#34;The following requested LoRA adapters are not loaded: {name}\n&#34;
                f&#34;Loaded adapters: {self._registry.keys()}.&#34;
            )
        return lora_ref.lora_id

    async with self._registry_lock.reader_lock:
        if isinstance(lora_name, str):
            lora_id = _lookup(lora_name)
            await self._counters[lora_id].increment(notify_all=False)
            return lora_id
        elif isinstance(lora_name, list):
            lora_ids = [_lookup(name) for name in lora_name]

            # Increment the counters only after all IDs are looked up.
            await asyncio.gather(
                *[
                    self._counters[id].increment(notify_all=False)
                    for id in lora_ids
                    if id is not None
                ]
            )
            return lora_ids
        else:
            raise TypeError(
                &#34;lora_name must be either a string or a list of strings.&#34;
            )</code></pre>
</details>
<div class="desc"><p>Queries registry for LoRA IDs based on LoRA names and start tracking the usage of the corresponding LoRA adapters
by incrementing its counter.</p></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry.register"><code class="name flex">
<span>async def <span class="ident">register</span></span>(<span>self,<br>lora_ref: <a title="sglang.srt.lora.lora_registry.LoRARef" href="#sglang.srt.lora.lora_registry.LoRARef">LoRARef</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def register(self, lora_ref: LoRARef):
    &#34;&#34;&#34;
    Register a new LoRARef object in the registry.

    Args:
        lora_ref (LoRARef): The LoRARef object to register.
    &#34;&#34;&#34;
    async with self._registry_lock.writer_lock:
        self._register_adapter(lora_ref)</code></pre>
</details>
<div class="desc"><p>Register a new LoRARef object in the registry.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lora_ref</code></strong> :&ensp;<code><a title="sglang.srt.lora.lora_registry.LoRARef" href="#sglang.srt.lora.lora_registry.LoRARef">LoRARef</a></code></dt>
<dd>The LoRARef object to register.</dd>
</dl></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry.release"><code class="name flex">
<span>async def <span class="ident">release</span></span>(<span>self, lora_id: str | List[str])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def release(self, lora_id: Union[str, List[str]]):
    &#34;&#34;&#34;
    Decrements the usage counter for a LoRA adapter, indicating that it is no longer in use.
    &#34;&#34;&#34;

    async with self._registry_lock.reader_lock:
        if isinstance(lora_id, str):
            await self._counters[lora_id].decrement()
        elif isinstance(lora_id, list):
            await asyncio.gather(
                *[
                    self._counters[id].decrement()
                    for id in lora_id
                    if id is not None
                ]
            )
        else:
            raise TypeError(&#34;lora_id must be either a string or a list of strings.&#34;)</code></pre>
</details>
<div class="desc"><p>Decrements the usage counter for a LoRA adapter, indicating that it is no longer in use.</p></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry.unregister"><code class="name flex">
<span>async def <span class="ident">unregister</span></span>(<span>self, lora_name: str) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def unregister(self, lora_name: str) -&gt; str:
    &#34;&#34;&#34;
    Unregister a LoRARef object from the registry and returns the removed LoRA ID.

    Args:
        lora_name (str): The name of the LoRA model to unregister.
    &#34;&#34;&#34;
    async with self._registry_lock.writer_lock:
        lora_ref = self._registry.get(lora_name, None)
        if lora_ref is None:
            raise ValueError(
                f&#34;LoRA with name {lora_name} does not exist. Loaded LoRAs: {self._registry.keys()}&#34;
            )
        del self._registry[lora_name]

    return lora_ref.lora_id</code></pre>
</details>
<div class="desc"><p>Unregister a LoRARef object from the registry and returns the removed LoRA ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lora_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the LoRA model to unregister.</dd>
</dl></div>
</dd>
<dt id="sglang.srt.lora.lora_registry.LoRARegistry.wait_for_unload"><code class="name flex">
<span>async def <span class="ident">wait_for_unload</span></span>(<span>self, lora_id: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def wait_for_unload(self, lora_id: str):
    &#34;&#34;&#34;
    Waits until the usage counter for a LoRA adapter reaches zero, indicating that it is no longer in use.
    This is useful for ensuring that a LoRA adapter can be safely unloaded.

    This method itself is not synchronized, which is safe because it should only be called during LoRA unloading,
    which itself is guaranteed to be sequential.
    &#34;&#34;&#34;
    assert (
        lora_id not in self._registry
    ), &#34;wait_for_unload should only be called after the LoRA adapter has been unregistered. &#34;
    assert (
        lora_id in self._counters
    ), &#34;The LoRA ID should still have a counter if it has been registered before.&#34;

    # Wait until no requests are using this LoRA adapter.
    await self._counters[lora_id].wait_for_zero()
    del self._counters[lora_id]</code></pre>
</details>
<div class="desc"><p>Waits until the usage counter for a LoRA adapter reaches zero, indicating that it is no longer in use.
This is useful for ensuring that a LoRA adapter can be safely unloaded.</p>
<p>This method itself is not synchronized, which is safe because it should only be called during LoRA unloading,
which itself is guaranteed to be sequential.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.lora" href="index.html">sglang.srt.lora</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.lora.lora_registry.LoRARef" href="#sglang.srt.lora.lora_registry.LoRARef">LoRARef</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.lora.lora_registry.LoRARef.lora_id" href="#sglang.srt.lora.lora_registry.LoRARef.lora_id">lora_id</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARef.lora_name" href="#sglang.srt.lora.lora_registry.LoRARef.lora_name">lora_name</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARef.lora_path" href="#sglang.srt.lora.lora_registry.LoRARef.lora_path">lora_path</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARef.pinned" href="#sglang.srt.lora.lora_registry.LoRARef.pinned">pinned</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.lora.lora_registry.LoRARegistry" href="#sglang.srt.lora.lora_registry.LoRARegistry">LoRARegistry</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.lora.lora_registry.LoRARegistry.acquire" href="#sglang.srt.lora.lora_registry.LoRARegistry.acquire">acquire</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARegistry.num_registered_loras" href="#sglang.srt.lora.lora_registry.LoRARegistry.num_registered_loras">num_registered_loras</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARegistry.register" href="#sglang.srt.lora.lora_registry.LoRARegistry.register">register</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARegistry.release" href="#sglang.srt.lora.lora_registry.LoRARegistry.release">release</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARegistry.unregister" href="#sglang.srt.lora.lora_registry.LoRARegistry.unregister">unregister</a></code></li>
<li><code><a title="sglang.srt.lora.lora_registry.LoRARegistry.wait_for_unload" href="#sglang.srt.lora.lora_registry.LoRARegistry.wait_for_unload">wait_for_unload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
