================================================================================
FUNCTION INDEX: function_call module
================================================================================
Total Functions: 90
Documented: 48


============================================================
FILE: python/sglang/srt/function_call/base_format_detector.py
Functions: 8
============================================================


CLASS: BaseFormatDetector
----------------------------------------
  L  27: __init__(self)

  L  69: parse_base_json(self, action: Any, tools: List[Tool])
         â†’ List[ToolCallItem]

  L  94: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Parses the text in one go. Returns success=True if the format matches, otherwise False.
            Note that leftover_text here represents "content that this parser will not consume further".

  L 115: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing with tool validation.
            This base implementation works best with formats where:
            1. bot_token is followed immediately by JSON (e.g., bot_token + JSON_array)
            2. JSON can be parsed incrementally using partial_json_loads
            3. Multiple tool calls are separated by "; " or ", "
            Examples of incompatible formats (need custom implementation, may reuse some logic from this class):
            - Each tool call is wrapped in a separate block: See Qwen25Detector
            - Multiple separate blocks: [TOOL_CALLS] [...]
            [TOOL_CALLS] [...]
            - Tool call is Pythonic style
            For incompatible formats, detectors should override this method with custom logic.

  L 318: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the given text contains function call markers specific to this format.

  L 324: supports_structural_tag(self)
         â†’ bool
         ğŸ“ Return True if this detector supports structural tag format.

  L 329: structure_info(self)
         â†’ _GetInfoFunc
         ğŸ“ Return a function that creates StructureInfo for constrained generation.
            The returned function takes a tool name and returns a StructureInfo object
            containing the begin/end patterns and trigger tokens needed for constrained
            generation of function calls in this format.
            Returns:
            A function that takes a tool name (str) and returns StructureInfo

  L 343: build_ebnf(self, tools: List[Tool])
         â†’ str
         ğŸ“ Build an EBNF grammar for constrained generation of function calls.
            This method generates an Extended Backus-Naur Form (EBNF) grammar that
            constrains the model's output to valid function calls in this format.
            The grammar should include all available tools and their parameter schemas.
            Args:
            tools: List of available tools/functions that can be called
            Returns:
            A string containing the EBNF grammar for this function call format
            The EBNF grammar should:
            - Define the overall structure of function calls in this format
            - Include all tool names from the provided tools list
            - Define valid JSON structures for function arguments
            - Handle multiple function calls if the format supports them
            Note:
            Most implementations use EBNFComposer.build_ebnf() utility with
            format-specific parameters rather than writing EBNF from scratch.


============================================================
FILE: python/sglang/srt/function_call/deepseekv31_detector.py
Functions: 6
============================================================


CLASS: DeepSeekV31Detector
----------------------------------------
  L  46: __init__(self)

  L  57: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a deepseek format tool call.

  L  61: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L  91: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing tool calls for DeepSeekV3 format.

  L 207: structure_info(self)
         â†’ _GetInfoFunc

  L 214: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/deepseekv3_detector.py
Functions: 6
============================================================


CLASS: DeepSeekV3Detector
----------------------------------------
  L  46: __init__(self)

  L  55: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a deepseek format tool call.

  L  59: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L  89: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing tool calls for DeepSeekV3 format.

  L 205: structure_info(self)
         â†’ _GetInfoFunc

  L 212: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/ebnf_composer.py
Functions: 3
============================================================


CLASS: EBNFComposer
----------------------------------------
  L  92: get_value_rule(prop: dict, function_format: Literal['pythonic', 'json', 'xml'])
         â†’ str

  L 132: get_type_mapping(function_format: str)
         â†’ Dict[str, str]
         ğŸ“ Get the complete type mapping for a given format.

  L 155: build_ebnf(tools, function_format: Literal['pythonic', 'json', 'xml'], sequence_start_token: Optional[str], sequence_end_token: Optional[str], individual_call_start_token: Optional[str], individual_call_end_token: Optional[str], tool_call_separator: Optional[str], call_rule_fmt: Optional[str], key_value_rule_fmt: Optional[str], key_value_separator: str)
         ğŸ“ Generalized EBNF builder for all detectors.
            Args:
            tools: List of Tool objects to generate EBNF grammar for
            function_format: The format of function calls, either "pythonic" or "json"
            sequence_start_token: Token that wraps the entire sequence of tool calls (start)
            sequence_end_token: Token that wraps the entire sequence of tool calls (end)
            individual_call_start_token: Token that wraps each individual tool call (start)
            individual_call_end_token: Token that wraps each individual tool call (end)
            tool_call_separator: The separator between multiple tool calls
            call_rule_fmt: Optional custom format string for call_{name} rule. It should define each function call's format, with
            the placeholders {name} for the function name and {arguments_rule} for the arguments rule. If None, a default
            format based on function_format will be used.
            key_value_rule_fmt: Optional custom format string for key-value pairs. It should define how each parameter is formatted,
            with placeholders {key} for the parameter name and {valrule} for the value rule. If None, a default format
            based on function_format will be used.


============================================================
FILE: python/sglang/srt/function_call/function_call_parser.py
Functions: 7
============================================================


CLASS: FunctionCallParser
----------------------------------------
  L  50: __init__(self, tools: List[Tool], tool_call_parser: str)

  L  61: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the given text contains a tool call in the format supported by this parser.
            This delegates to the detector's implementation.
            Args:
            text: The text to check for tool calls
            Returns:
            True if the text contains a tool call, False otherwise

  L  74: parse_non_stream(self, full_text: str)
         â†’ Tuple[str, list[ToolCallItem]]
         ğŸ“ One-time parsing of the full text to extract tool calls.
            Args:
            full_text: The complete text to parse
            Returns:
            A tuple containing:
            - The remaining text after parsing that was not consumed by the detector (can be treated as normal text)
            - A list of tool calls parsed from the text

  L  93: parse_stream_chunk(self, chunk_text: str)
         â†’ Tuple[str, list[ToolCallItem]]
         ğŸ“ Streaming incremental parsing of chunks of text as they arrive.
            Args:
            chunk_text: The new chunk of text to parse
            Returns:
            A tuple containing:
            - The normal text that should be displayed to the user
            - A list of tool calls parsed from the chunk

  L 117: get_structure_tag(self)
         â†’ StructuralTagResponseFormat
         ğŸ“ Generate a structural tag response format for all available tools.
            This creates the necessary structural tags that guide the model's output format.

  L 151: get_structure_constraint(self, tool_choice: Union[ToolChoice, Literal['auto', 'required']])
         â†’ Optional[Tuple[str, Any]]
         ğŸ“ Returns the appropriate structure constraint for tool calls based on the tool_choice.
            The constraint is used to guide the model's output format.
            Args:
            tool_choice: The tool choice setting from the request
            Returns:
            A tuple of (constraint_type, constraint_value) to be added to sampling parameters,
            or None if no constraint applies.

  L 178: get_ebnf(self, tool_choice: Union[ToolChoice, Literal['required']])
         â†’ Optional[str]
         ğŸ“ Get the EBNF grammar for the specified tool choice.
            Args:
            tool_choice: The tool choice specification
            Returns:
            EBNF grammar string, or None if no valid tools found
            Note:
            If a specific function is requested but not found in available tools,
            logs a warning and falls back to using all available tools for backward compatibility.


============================================================
FILE: python/sglang/srt/function_call/glm4_moe_detector.py
Functions: 9
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L  19: def get_argument_type(func_name: str, arg_key: str, defined_tools: list)

  L  29: def parse_arguments(json_value)


CLASS: Glm4MoeDetector
----------------------------------------
  L  47: __init__(self)

  L  55: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a glm-4.5 format tool call.

  L  59: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L 101: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing tool calls for GLM-4.5 format.

  L 148: supports_structural_tag(self)
         â†’ bool

  L 151: structure_info(self)
         â†’ _GetInfoFunc

  L 154: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/gpt_oss_detector.py
Functions: 6
============================================================


CLASS: GptOssDetector
----------------------------------------
  L  26: __init__(self)

  L  38: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if text contains TypeScript-style function call markers.

  L  42: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Parse TypeScript-style function calls from complete text.

  L  75: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Parse incremental streaming text for TypeScript-style function calls.

  L 215: structure_info(self)
         â†’ _GetInfoFunc

  L 218: build_ebnf(self, tools: List[Tool])
         â†’ str


============================================================
FILE: python/sglang/srt/function_call/kimik2_detector.py
Functions: 6
============================================================


CLASS: KimiK2Detector
----------------------------------------
  L  34: __init__(self)

  L  53: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a KimiK2 format tool call.

  L  57: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L 100: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing tool calls for KimiK2 format.

  L 217: structure_info(self)
         â†’ _GetInfoFunc
         ğŸ“ Return function that creates StructureInfo for guided generation.

  L 229: build_ebnf(self, tools: List[Tool])
         â†’ str
         ğŸ“ Build EBNF grammar for KimiK2 tool call format.
            NOTE: The call_rule_fmt uses [0-9]+ for the function index to allow the grammar
            to accept any numeric index (0, 1, 2, etc.) for proper sequential indexing in
            multiple function call scenarios, while still maintaining the correct KimiK2
            format structure for constrained generation.


============================================================
FILE: python/sglang/srt/function_call/llama32_detector.py
Functions: 5
============================================================


CLASS: Llama32Detector
----------------------------------------
  L  27: __init__(self)

  L  36: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a Llama 3.2 format tool call.

  L  42: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Parse function calls from text, handling multiple JSON objects.

  L  84: structure_info(self)
         â†’ _GetInfoFunc

  L  91: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/mistral_detector.py
Functions: 5
============================================================


CLASS: MistralDetector
----------------------------------------
  L  33: __init__(self)
         ğŸ“ Initializes the detector with necessary state variables.

  L  43: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a Mistral format tool call.

  L  47: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L 125: structure_info(self)
         â†’ _GetInfoFunc

  L 132: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/pythonic_detector.py
Functions: 7
============================================================


CLASS: PythonicDetector
----------------------------------------
  L  34: __init__(self)

  L  49: has_tool_call(self, text: str)
         â†’ bool

  L  52: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult

  L 157: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing for pythonic tool calls.
            Buffers input until a complete pythonic tool call (from [ to ]) is found,
            then parses and emits any detected calls.

  L 218: supports_structural_tag(self)
         â†’ bool

  L 221: structure_info(self)
         â†’ _GetInfoFunc

  L 224: build_ebnf(self, tools: List[Tool])
         â†’ Optional[str]


============================================================
FILE: python/sglang/srt/function_call/qwen25_detector.py
Functions: 6
============================================================


CLASS: Qwen25Detector
----------------------------------------
  L  34: __init__(self)
         ğŸ“ Initializes the detector with necessary state variables.

  L  44: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a Qwen 2.5 format tool call.

  L  48: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L  76: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing for Qwen 2.5 tool calls.
            Uses base class implementation with buffering to handle partial end tokens.

  L 116: structure_info(self)
         â†’ _GetInfoFunc

  L 123: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/qwen3_coder_detector.py
Functions: 7
============================================================


CLASS: Qwen3CoderDetector
----------------------------------------
  L  44: __init__(self)

  L  69: has_tool_call(self, text: str)
         â†’ bool

  L  72: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult

  L  76: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult

  L 346: supports_structural_tag(self)
         â†’ bool

  L 349: structure_info(self)
         â†’ _GetInfoFunc

  L 352: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/step3_detector.py
Functions: 9
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L  19: def get_argument_type(func_name: str, arg_key: str, defined_tools: List[Tool])
         â†’ str
         ğŸ“ Get the expected type for a function argument from tool schema.

  L  32: def parse_arguments(value: str)
         â†’ tuple[Any, bool]
         ğŸ“ Parse a string value to appropriate type. Returns (parsed_value, success).


CLASS: Step3Detector
----------------------------------------
  L  62: __init__(self)

  L  86: has_tool_call(self, text: str)
         â†’ bool
         ğŸ“ Check if the text contains a Step3 format tool call.

  L 121: detect_and_parse(self, text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ One-time parsing: Detects and parses tool calls in the provided text.

  L 170: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         â†’ StreamingParseResult
         ğŸ“ Streaming incremental parsing for Step3 format.

  L 403: supports_structural_tag(self)
         â†’ bool
         ğŸ“ Return True if this detector supports structural tag format.

  L 407: structure_info(self)
         â†’ _GetInfoFunc

  L 410: build_ebnf(self, tools: List[Tool])
         â†’ str
         ğŸ“ Build EBNF grammar for Step3 tool call format.
