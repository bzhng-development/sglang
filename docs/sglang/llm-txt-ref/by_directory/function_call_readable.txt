================================================================================
FUNCTION INDEX: function_call module
================================================================================
Total Functions: 90
Documented: 48


============================================================
FILE: python/sglang/srt/function_call/base_format_detector.py
Functions: 8
============================================================


CLASS: BaseFormatDetector
----------------------------------------
  L  27: __init__(self)

  L  69: parse_base_json(self, action: Any, tools: List[Tool])
         ‚Üí List[ToolCallItem]

  L  94: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Parses the text in one go. Returns success=True if the format matches, otherwise False.
            Note that leftover_text here represents "content that this parser will not consume further".

  L 115: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing with tool validation.
            This base implementation works best with formats where:
            1. bot_token is followed immediately by JSON (e.g., bot_token + JSON_array)
            2. JSON can be parsed incrementally using partial_json_loads
            3. Multiple tool calls are separated by "; " or ", "
            Examples of incompatible formats (need custom implementation, may reuse some logic from this class):
            - Each tool call is wrapped in a separate block: See Qwen25Detector
            - Multiple separate blocks: [TOOL_CALLS] [...]
            [TOOL_CALLS] [...]
            - Tool call is Pythonic style
            For incompatible formats, detectors should override this method with custom logic.

  L 318: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the given text contains function call markers specific to this format.

  L 324: supports_structural_tag(self)
         ‚Üí bool
         üìù Return True if this detector supports structural tag format.

  L 329: structure_info(self)
         ‚Üí _GetInfoFunc
         üìù Return a function that creates StructureInfo for constrained generation.
            The returned function takes a tool name and returns a StructureInfo object
            containing the begin/end patterns and trigger tokens needed for constrained
            generation of function calls in this format.
            Returns:
            A function that takes a tool name (str) and returns StructureInfo

  L 343: build_ebnf(self, tools: List[Tool])
         ‚Üí str
         üìù Build an EBNF grammar for constrained generation of function calls.
            This method generates an Extended Backus-Naur Form (EBNF) grammar that
            constrains the model's output to valid function calls in this format.
            The grammar should include all available tools and their parameter schemas.
            Args:
            tools: List of available tools/functions that can be called
            Returns:
            A string containing the EBNF grammar for this function call format
            The EBNF grammar should:
            - Define the overall structure of function calls in this format
            - Include all tool names from the provided tools list
            - Define valid JSON structures for function arguments
            - Handle multiple function calls if the format supports them
            Note:
            Most implementations use EBNFComposer.build_ebnf() utility with
            format-specific parameters rather than writing EBNF from scratch.


============================================================
FILE: python/sglang/srt/function_call/deepseekv31_detector.py
Functions: 6
============================================================


CLASS: DeepSeekV31Detector
----------------------------------------
  L  46: __init__(self)

  L  57: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a deepseek format tool call.

  L  61: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L  91: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing tool calls for DeepSeekV3 format.

  L 207: structure_info(self)
         ‚Üí _GetInfoFunc

  L 214: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/deepseekv3_detector.py
Functions: 6
============================================================


CLASS: DeepSeekV3Detector
----------------------------------------
  L  46: __init__(self)

  L  55: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a deepseek format tool call.

  L  59: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L  89: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing tool calls for DeepSeekV3 format.

  L 205: structure_info(self)
         ‚Üí _GetInfoFunc

  L 212: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/ebnf_composer.py
Functions: 3
============================================================


CLASS: EBNFComposer
----------------------------------------
  L  92: get_value_rule(prop: dict, function_format: Literal['pythonic', 'json', 'xml'])
         ‚Üí str

  L 132: get_type_mapping(function_format: str)
         ‚Üí Dict[str, str]
         üìù Get the complete type mapping for a given format.

  L 155: build_ebnf(tools, function_format: Literal['pythonic', 'json', 'xml'], sequence_start_token: Optional[str], sequence_end_token: Optional[str], individual_call_start_token: Optional[str], individual_call_end_token: Optional[str], tool_call_separator: Optional[str], call_rule_fmt: Optional[str], key_value_rule_fmt: Optional[str], key_value_separator: str)
         üìù Generalized EBNF builder for all detectors.
            Args:
            tools: List of Tool objects to generate EBNF grammar for
            function_format: The format of function calls, either "pythonic" or "json"
            sequence_start_token: Token that wraps the entire sequence of tool calls (start)
            sequence_end_token: Token that wraps the entire sequence of tool calls (end)
            individual_call_start_token: Token that wraps each individual tool call (start)
            individual_call_end_token: Token that wraps each individual tool call (end)
            tool_call_separator: The separator between multiple tool calls
            call_rule_fmt: Optional custom format string for call_{name} rule. It should define each function call's format, with
            the placeholders {name} for the function name and {arguments_rule} for the arguments rule. If None, a default
            format based on function_format will be used.
            key_value_rule_fmt: Optional custom format string for key-value pairs. It should define how each parameter is formatted,
            with placeholders {key} for the parameter name and {valrule} for the value rule. If None, a default format
            based on function_format will be used.


============================================================
FILE: python/sglang/srt/function_call/function_call_parser.py
Functions: 7
============================================================


CLASS: FunctionCallParser
----------------------------------------
  L  50: __init__(self, tools: List[Tool], tool_call_parser: str)

  L  61: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the given text contains a tool call in the format supported by this parser.
            This delegates to the detector's implementation.
            Args:
            text: The text to check for tool calls
            Returns:
            True if the text contains a tool call, False otherwise

  L  74: parse_non_stream(self, full_text: str)
         ‚Üí Tuple[str, list[ToolCallItem]]
         üìù One-time parsing of the full text to extract tool calls.
            Args:
            full_text: The complete text to parse
            Returns:
            A tuple containing:
            - The remaining text after parsing that was not consumed by the detector (can be treated as normal text)
            - A list of tool calls parsed from the text

  L  93: parse_stream_chunk(self, chunk_text: str)
         ‚Üí Tuple[str, list[ToolCallItem]]
         üìù Streaming incremental parsing of chunks of text as they arrive.
            Args:
            chunk_text: The new chunk of text to parse
            Returns:
            A tuple containing:
            - The normal text that should be displayed to the user
            - A list of tool calls parsed from the chunk

  L 117: get_structure_tag(self)
         ‚Üí StructuralTagResponseFormat
         üìù Generate a structural tag response format for all available tools.
            This creates the necessary structural tags that guide the model's output format.

  L 151: get_structure_constraint(self, tool_choice: Union[ToolChoice, Literal['auto', 'required']])
         ‚Üí Optional[Tuple[str, Any]]
         üìù Returns the appropriate structure constraint for tool calls based on the tool_choice.
            The constraint is used to guide the model's output format.
            Args:
            tool_choice: The tool choice setting from the request
            Returns:
            A tuple of (constraint_type, constraint_value) to be added to sampling parameters,
            or None if no constraint applies.

  L 178: get_ebnf(self, tool_choice: Union[ToolChoice, Literal['required']])
         ‚Üí Optional[str]
         üìù Get the EBNF grammar for the specified tool choice.
            Args:
            tool_choice: The tool choice specification
            Returns:
            EBNF grammar string, or None if no valid tools found
            Note:
            If a specific function is requested but not found in available tools,
            logs a warning and falls back to using all available tools for backward compatibility.


============================================================
FILE: python/sglang/srt/function_call/glm4_moe_detector.py
Functions: 9
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L  19: def get_argument_type(func_name: str, arg_key: str, defined_tools: list)

  L  29: def parse_arguments(json_value)


CLASS: Glm4MoeDetector
----------------------------------------
  L  47: __init__(self)

  L  55: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a glm-4.5 format tool call.

  L  59: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L 101: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing tool calls for GLM-4.5 format.

  L 148: supports_structural_tag(self)
         ‚Üí bool

  L 151: structure_info(self)
         ‚Üí _GetInfoFunc

  L 154: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/gpt_oss_detector.py
Functions: 6
============================================================


CLASS: GptOssDetector
----------------------------------------
  L  26: __init__(self)

  L  38: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if text contains TypeScript-style function call markers.

  L  42: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Parse TypeScript-style function calls from complete text.

  L  75: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Parse incremental streaming text for TypeScript-style function calls.

  L 215: structure_info(self)
         ‚Üí _GetInfoFunc

  L 218: build_ebnf(self, tools: List[Tool])
         ‚Üí str


============================================================
FILE: python/sglang/srt/function_call/kimik2_detector.py
Functions: 6
============================================================


CLASS: KimiK2Detector
----------------------------------------
  L  34: __init__(self)

  L  53: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a KimiK2 format tool call.

  L  57: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L 100: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing tool calls for KimiK2 format.

  L 217: structure_info(self)
         ‚Üí _GetInfoFunc
         üìù Return function that creates StructureInfo for guided generation.

  L 229: build_ebnf(self, tools: List[Tool])
         ‚Üí str
         üìù Build EBNF grammar for KimiK2 tool call format.
            NOTE: The call_rule_fmt uses [0-9]+ for the function index to allow the grammar
            to accept any numeric index (0, 1, 2, etc.) for proper sequential indexing in
            multiple function call scenarios, while still maintaining the correct KimiK2
            format structure for constrained generation.


============================================================
FILE: python/sglang/srt/function_call/llama32_detector.py
Functions: 5
============================================================


CLASS: Llama32Detector
----------------------------------------
  L  27: __init__(self)

  L  36: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a Llama 3.2 format tool call.

  L  42: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Parse function calls from text, handling multiple JSON objects.

  L  84: structure_info(self)
         ‚Üí _GetInfoFunc

  L  91: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/mistral_detector.py
Functions: 5
============================================================


CLASS: MistralDetector
----------------------------------------
  L  33: __init__(self)
         üìù Initializes the detector with necessary state variables.

  L  43: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a Mistral format tool call.

  L  47: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L 125: structure_info(self)
         ‚Üí _GetInfoFunc

  L 132: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/pythonic_detector.py
Functions: 7
============================================================


CLASS: PythonicDetector
----------------------------------------
  L  34: __init__(self)

  L  49: has_tool_call(self, text: str)
         ‚Üí bool

  L  52: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult

  L 157: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing for pythonic tool calls.
            Buffers input until a complete pythonic tool call (from [ to ]) is found,
            then parses and emits any detected calls.

  L 218: supports_structural_tag(self)
         ‚Üí bool

  L 221: structure_info(self)
         ‚Üí _GetInfoFunc

  L 224: build_ebnf(self, tools: List[Tool])
         ‚Üí Optional[str]


============================================================
FILE: python/sglang/srt/function_call/qwen25_detector.py
Functions: 6
============================================================


CLASS: Qwen25Detector
----------------------------------------
  L  34: __init__(self)
         üìù Initializes the detector with necessary state variables.

  L  44: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a Qwen 2.5 format tool call.

  L  48: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.
            :param text: The complete text to parse.
            :param tools: List of available tools.
            :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.

  L  76: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing for Qwen 2.5 tool calls.
            Uses base class implementation with buffering to handle partial end tokens.

  L 116: structure_info(self)
         ‚Üí _GetInfoFunc

  L 123: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/qwen3_coder_detector.py
Functions: 7
============================================================


CLASS: Qwen3CoderDetector
----------------------------------------
  L  44: __init__(self)

  L  69: has_tool_call(self, text: str)
         ‚Üí bool

  L  72: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult

  L  76: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult

  L 346: supports_structural_tag(self)
         ‚Üí bool

  L 349: structure_info(self)
         ‚Üí _GetInfoFunc

  L 352: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/step3_detector.py
Functions: 9
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L  19: def get_argument_type(func_name: str, arg_key: str, defined_tools: List[Tool])
         ‚Üí str
         üìù Get the expected type for a function argument from tool schema.

  L  32: def parse_arguments(value: str)
         ‚Üí tuple[Any, bool]
         üìù Parse a string value to appropriate type. Returns (parsed_value, success).


CLASS: Step3Detector
----------------------------------------
  L  62: __init__(self)

  L  86: has_tool_call(self, text: str)
         ‚Üí bool
         üìù Check if the text contains a Step3 format tool call.

  L 121: detect_and_parse(self, text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù One-time parsing: Detects and parses tool calls in the provided text.

  L 170: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         ‚Üí StreamingParseResult
         üìù Streaming incremental parsing for Step3 format.

  L 403: supports_structural_tag(self)
         ‚Üí bool
         üìù Return True if this detector supports structural tag format.

  L 407: structure_info(self)
         ‚Üí _GetInfoFunc

  L 410: build_ebnf(self, tools: List[Tool])
         ‚Üí str
         üìù Build EBNF grammar for Step3 tool call format.
