
# python/sglang/srt/eplb/eplb_algorithms/__init__.py
rebalance_experts(tokens_per_expert: torch.Tensor, num_physical_experts: int, num_local_physical_experts: int, num_groups: Optional[int], num_nodes: int, algorithm: EplbAlgorithm)
compute_algorithm(raw_algorithm: str, num_groups: Optional[int], num_nodes: int) -> EplbAlgorithm

# python/sglang/srt/eplb/eplb_algorithms/deepseek.py
balanced_packing(weight: torch.Tensor, num_packs: int) -> Tuple[torch.Tensor, torch.Tensor]
replicate_experts(weight: torch.Tensor, num_phy: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]
rebalance_experts_hierarchical(weight: torch.Tensor, num_physical_experts: int, num_groups: int, num_nodes: int, num_gpus: int)
rebalance_experts(weight: torch.Tensor, num_replicas: int, num_groups: int, num_nodes: int, num_gpus: int, enable_hierarchical: bool) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]

# python/sglang/srt/eplb/eplb_algorithms/deepseek_vec.py
pack_groups(tokens_per_group: torch.Tensor, num_nodes: int) -> torch.Tensor
make_redundant_experts_chunkwise(tokens_per_expert: torch.Tensor, num_physical_experts: int, num_local_physical_experts: int, num_physical_experts_per_chunk: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]
decode_rebalance_experts(tokens_per_expert: torch.Tensor, num_physical_experts: int, num_local_physical_experts: int)
prefill_rebalance_experts(tokens_per_expert: torch.Tensor, num_physical_experts: int, num_local_physical_experts: int, num_groups: int, num_nodes: int)
rebalance_experts(tokens_per_expert: torch.Tensor, num_physical_experts: int, num_local_physical_experts: int, num_groups: Optional[int], num_nodes: int, enable_hierarchical: bool)
