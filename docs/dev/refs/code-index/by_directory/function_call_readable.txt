================================================================================
FUNCTION INDEX: function_call module
================================================================================
Total Functions: 90
Documented: 48


============================================================
FILE: python/sglang/srt/function_call/base_format_detector.py
Functions: 8
============================================================


CLASS: BaseFormatDetector
----------------------------------------
  L  27: __init__(self)

  L  69: parse_base_json(self, action: Any, tools: List[Tool])
         → List[ToolCallItem]

  L  94: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Parses the text in one go. Returns success=True if the format matches,

  L 115: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝        Streaming incremental parsing with tool validation.

  L 318: has_tool_call(self, text: str)
         → bool
         📝 Check if the given text contains function call markers specific to thi

  L 324: supports_structural_tag(self)
         → bool
         📝 Return True if this detector supports structural tag format.

  L 329: structure_info(self)
         → _GetInfoFunc
         📝 Return a function that creates StructureInfo for constrained generatio

  L 343: build_ebnf(self, tools: List[Tool])
         → str
         📝 Build an EBNF grammar for constrained generation of function calls.


============================================================
FILE: python/sglang/srt/function_call/deepseekv31_detector.py
Functions: 6
============================================================


CLASS: DeepSeekV31Detector
----------------------------------------
  L  46: __init__(self)

  L  57: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a deepseek format tool call.

  L  61: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L  91: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing tool calls for DeepSeekV3 format.

  L 207: structure_info(self)
         → _GetInfoFunc

  L 214: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/deepseekv3_detector.py
Functions: 6
============================================================


CLASS: DeepSeekV3Detector
----------------------------------------
  L  46: __init__(self)

  L  55: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a deepseek format tool call.

  L  59: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L  89: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing tool calls for DeepSeekV3 format.

  L 205: structure_info(self)
         → _GetInfoFunc

  L 212: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/ebnf_composer.py
Functions: 3
============================================================


CLASS: EBNFComposer
----------------------------------------
  L  92: get_value_rule(prop: dict, function_format: Literal['pythonic', 'json', 'xml'])
         → str

  L 132: get_type_mapping(function_format: str)
         → Dict[str, str]
         📝 Get the complete type mapping for a given format.

  L 155: build_ebnf(tools, function_format: Literal['pythonic', 'json', 'xml'], sequence_start_token: Optional[str], sequence_end_token: Optional[str], individual_call_start_token: Optional[str], individual_call_end_token: Optional[str], tool_call_separator: Optional[str], call_rule_fmt: Optional[str], key_value_rule_fmt: Optional[str], key_value_separator: str)
         📝 Generalized EBNF builder for all detectors.


============================================================
FILE: python/sglang/srt/function_call/function_call_parser.py
Functions: 7
============================================================


CLASS: FunctionCallParser
----------------------------------------
  L  50: __init__(self, tools: List[Tool], tool_call_parser: str)

  L  61: has_tool_call(self, text: str)
         → bool
         📝 Check if the given text contains a tool call in the format supported b

  L  74: parse_non_stream(self, full_text: str)
         → Tuple[str, list[ToolCallItem]]
         📝 One-time parsing of the full text to extract tool calls.

  L  93: parse_stream_chunk(self, chunk_text: str)
         → Tuple[str, list[ToolCallItem]]
         📝 Streaming incremental parsing of chunks of text as they arrive.

  L 117: get_structure_tag(self)
         → StructuralTagResponseFormat
         📝 Generate a structural tag response format for all available tools.

  L 151: get_structure_constraint(self, tool_choice: Union[ToolChoice, Literal['auto', 'required']])
         → Optional[Tuple[str, Any]]
         📝 Returns the appropriate structure constraint for tool calls based on t

  L 178: get_ebnf(self, tool_choice: Union[ToolChoice, Literal['required']])
         → Optional[str]
         📝 Get the EBNF grammar for the specified tool choice.


============================================================
FILE: python/sglang/srt/function_call/glm4_moe_detector.py
Functions: 9
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L  19: def get_argument_type(func_name: str, arg_key: str, defined_tools: list)

  L  29: def parse_arguments(json_value)


CLASS: Glm4MoeDetector
----------------------------------------
  L  47: __init__(self)

  L  55: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a glm-4.5 format tool call.

  L  59: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L 101: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing tool calls for GLM-4.5 format.

  L 148: supports_structural_tag(self)
         → bool

  L 151: structure_info(self)
         → _GetInfoFunc

  L 154: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/gpt_oss_detector.py
Functions: 6
============================================================


CLASS: GptOssDetector
----------------------------------------
  L  26: __init__(self)

  L  38: has_tool_call(self, text: str)
         → bool
         📝 Check if text contains TypeScript-style function call markers.

  L  42: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Parse TypeScript-style function calls from complete text.

  L  75: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Parse incremental streaming text for TypeScript-style function calls.

  L 215: structure_info(self)
         → _GetInfoFunc

  L 218: build_ebnf(self, tools: List[Tool])
         → str


============================================================
FILE: python/sglang/srt/function_call/kimik2_detector.py
Functions: 6
============================================================


CLASS: KimiK2Detector
----------------------------------------
  L  34: __init__(self)

  L  53: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a KimiK2 format tool call.

  L  57: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L 100: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing tool calls for KimiK2 format.

  L 217: structure_info(self)
         → _GetInfoFunc
         📝 Return function that creates StructureInfo for guided generation.

  L 229: build_ebnf(self, tools: List[Tool])
         → str
         📝 Build EBNF grammar for KimiK2 tool call format.


============================================================
FILE: python/sglang/srt/function_call/llama32_detector.py
Functions: 5
============================================================


CLASS: Llama32Detector
----------------------------------------
  L  27: __init__(self)

  L  36: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a Llama 3.2 format tool call.

  L  42: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Parse function calls from text, handling multiple JSON objects.

  L  84: structure_info(self)
         → _GetInfoFunc

  L  91: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/mistral_detector.py
Functions: 5
============================================================


CLASS: MistralDetector
----------------------------------------
  L  33: __init__(self)
         📝 Initializes the detector with necessary state variables.

  L  43: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a Mistral format tool call.

  L  47: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L 125: structure_info(self)
         → _GetInfoFunc

  L 132: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/pythonic_detector.py
Functions: 7
============================================================


CLASS: PythonicDetector
----------------------------------------
  L  34: __init__(self)

  L  49: has_tool_call(self, text: str)
         → bool

  L  52: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult

  L 157: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing for pythonic tool calls.

  L 218: supports_structural_tag(self)
         → bool

  L 221: structure_info(self)
         → _GetInfoFunc

  L 224: build_ebnf(self, tools: List[Tool])
         → Optional[str]


============================================================
FILE: python/sglang/srt/function_call/qwen25_detector.py
Functions: 6
============================================================


CLASS: Qwen25Detector
----------------------------------------
  L  34: __init__(self)
         📝 Initializes the detector with necessary state variables.

  L  44: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a Qwen 2.5 format tool call.

  L  48: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L  76: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing for Qwen 2.5 tool calls.

  L 116: structure_info(self)
         → _GetInfoFunc

  L 123: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/qwen3_coder_detector.py
Functions: 7
============================================================


CLASS: Qwen3CoderDetector
----------------------------------------
  L  44: __init__(self)

  L  69: has_tool_call(self, text: str)
         → bool

  L  72: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult

  L  76: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult

  L 346: supports_structural_tag(self)
         → bool

  L 349: structure_info(self)
         → _GetInfoFunc

  L 352: build_ebnf(self, tools: List[Tool])


============================================================
FILE: python/sglang/srt/function_call/step3_detector.py
Functions: 9
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L  19: def get_argument_type(func_name: str, arg_key: str, defined_tools: List[Tool])
         → str
         📝 Get the expected type for a function argument from tool schema.

  L  32: def parse_arguments(value: str)
         → tuple[Any, bool]
         📝 Parse a string value to appropriate type. Returns (parsed_value, succe


CLASS: Step3Detector
----------------------------------------
  L  62: __init__(self)

  L  86: has_tool_call(self, text: str)
         → bool
         📝 Check if the text contains a Step3 format tool call.

  L 121: detect_and_parse(self, text: str, tools: List[Tool])
         → StreamingParseResult
         📝 One-time parsing: Detects and parses tool calls in the provided text.

  L 170: parse_streaming_increment(self, new_text: str, tools: List[Tool])
         → StreamingParseResult
         📝 Streaming incremental parsing for Step3 format.

  L 403: supports_structural_tag(self)
         → bool
         📝 Return True if this detector supports structural tag format.

  L 407: structure_info(self)
         → _GetInfoFunc

  L 410: build_ebnf(self, tools: List[Tool])
         → str
         📝 Build EBNF grammar for Step3 tool call format.
