================================================================================
FUNCTION INDEX: quark module
================================================================================
Total Functions: 25
Documented: 4


============================================================
FILE: python/sglang/srt/layers/quantization/quark/quark.py
Functions: 16
============================================================


CLASS: QuarkConfig
----------------------------------------
  L  29: __init__(self, quant_config: dict[str, Any], kv_cache_group: Optional[list[str]], kv_cache_config: Optional[dict[str, Any]], pack_method: str)

  L  46: get_linear_method(self)
         ‚Üí 'QuarkLinearMethod'

  L  50: get_supported_act_dtypes(cls)
         ‚Üí list[torch.dtype]

  L  54: get_min_capability(cls)
         ‚Üí int

  L  57: get_name(self)
         ‚Üí str

  L  60: get_quant_method(self, layer: torch.nn.Module, prefix: str)
         ‚Üí Optional['QuantizeMethodBase']

  L  86: from_config(cls, config: dict[str, Any])
         ‚Üí 'QuarkConfig'

  L 153: get_config_filenames(cls)
         ‚Üí list[str]

  L 289: get_scheme(self, layer: torch.nn.Module, layer_name: str)
         ‚Üí 'QuarkScheme'

  L 302: get_scaled_act_names(self)
         ‚Üí List[str]


CLASS: QuarkKVCacheMethod
----------------------------------------
  L 363: __init__(self, quant_config: QuarkConfig)

  L 368: validate_kv_cache_config(kv_cache_config: Optional[dict[str, Any]])
         üìù Validator for the kv cache configuration. Useful for controlling the


CLASS: QuarkLinearMethod
----------------------------------------
  L 308: __init__(self, quantization_config: QuarkConfig)

  L 311: process_weights_after_loading(self, layer: torch.nn.Module)
         ‚Üí None

  L 314: create_weights(self, layer: torch.nn.Module, input_size_per_partition: int, output_partition_sizes: list[int], input_size: int, output_size: int, params_dtype: torch.dtype)
         üìù Use the CompressedTensorsScheme associated with each layer to create

  L 340: apply(self, layer: torch.nn.Module, x: torch.Tensor, bias: Optional[torch.Tensor])
         üìù Use the output of create_weights and the CompressedTensorsScheme


============================================================
FILE: python/sglang/srt/layers/quantization/quark/quark_moe.py
Functions: 6
============================================================


CLASS: QuarkMoEMethod
----------------------------------------
  L  26: __new__(cls)

  L  45: get_moe_method(quant_config: 'QuarkConfig', module: torch.nn.Module, layer_name: str)
         ‚Üí 'QuarkMoEMethod'


CLASS: QuarkW4A4MXFp4MoEMethod
----------------------------------------
  L  69: __init__(self, weight_config: dict[str, Any], input_config: dict[str, Any])

  L  85: create_weights(self, layer: torch.nn.Module, num_experts: int, hidden_size: int, intermediate_size_per_partition: int, params_dtype: torch.dtype)

  L 157: process_weights_after_loading(self, layer: torch.nn.Module)
         ‚Üí None

  L 173: apply(self, layer: torch.nn.Module, x: torch.Tensor, topk_output: TopKOutput, moe_runner_config: MoeRunnerConfig)
         ‚Üí torch.Tensor


============================================================
FILE: python/sglang/srt/layers/quantization/quark/utils.py
Functions: 3
============================================================

MODULE FUNCTIONS:
----------------------------------------
  L   9: def deep_compare(dict1: Any, dict2: Any)
         ‚Üí bool

  L  22: def should_ignore_layer(layer_name: Optional[str],
        ignore: Iterable[str],
        fused_mapping: Mapping[str,
        list[str]])
         ‚Üí bool

  L  78: def check_equal_or_regex_match(layer_name: str, targets: Iterable[str])
         ‚Üí bool
         üìù Checks whether a layer_name is exactly equal or a regex match for
