eplb/eplb_algorithms/__init__.py:
  compute_algorithm(raw_algorithm,num_groups,num_nodes)
  rebalance_experts(tokens_per_expert,num_physical_experts,num_local_physical_experts,num_groups,num_nodes,algorithm)
eplb/eplb_algorithms/deepseek.py:
  balanced_packing(weight,num_packs)
  inverse(perm)
  rebalance_experts(weight,num_replicas,num_groups,num_nodes,num_gpus,enable_hierarchical)
  rebalance_experts_hierarchical(weight,num_physical_experts,num_groups,num_nodes,num_gpus)
  replicate_experts(weight,num_phy)
eplb/eplb_algorithms/deepseek_vec.py:
  decode_rebalance_experts(tokens_per_expert,num_physical_experts,num_local_physical_experts)
  key_func(rank)
  make_redundant_experts_chunkwise(tokens_per_expert,num_physical_experts,num_local_physical_experts,num_physical_experts_per_chunk)
  pack_groups(tokens_per_group,num_nodes)
  prefill_rebalance_experts(tokens_per_expert,num_physical_experts,num_local_physical_experts,num_groups,num_nodes)
  rebalance_experts(tokens_per_expert,num_physical_experts,num_local_physical_experts,num_groups,num_nodes,enable_hierarchical)
eplb/eplb_manager.py:
  EPLBManager.__init__(self,model_runner)
  EPLBManager._check_rebalance_needed(self,average_utilization_rate_over_window)
  EPLBManager._compute_update_layer_ids_chunks(self)
  EPLBManager._entrypoint(self)
  EPLBManager.on_forward_pass_end(self)
  EPLBManager.rebalance(self)
  _chunk_list(items,chunk_size)
eplb/eplb_simulator/reader.py:
  read_mode_per_pass(dir_data)
eplb/expert_distribution.py:
  ExpertDistributionRecorder._on_not_implemented(self)
  ExpertDistributionRecorder.disable_this_region(self)
  ExpertDistributionRecorder.dump_record(self,output_mode)
  ExpertDistributionRecorder.init_new(server_args,expert_location_metadata,rank)
  ExpertDistributionRecorder.on_deepep_dispatch_low_latency(self,local_physical_count_of_layer)
  ExpertDistributionRecorder.on_deepep_dispatch_normal(self,local_physical_count_of_layer,num_tokens_per_rank,num_tokens_per_rdma_rank,num_tokens_per_expert)
  ExpertDistributionRecorder.on_select_experts(self,topk_ids)
  ExpertDistributionRecorder.recording(self)
  ExpertDistributionRecorder.start_record(self)
  ExpertDistributionRecorder.stop_record(self)
  ExpertDistributionRecorder.with_current_layer(self,layer_idx)
  ExpertDistributionRecorder.with_debug_name(self,debug_name)
  ExpertDistributionRecorder.with_forward_pass(self,forward_pass_id,forward_batch)
  _Accumulator.__init__(self,server_args,expert_location_metadata,rank)
  _Accumulator.append(self,forward_pass_id,gatherer_key,single_pass_data)
  _Accumulator.dump(self,output_mode)
  _Accumulator.get_class(server_args)
  _Accumulator.get_single_pass_gatherer_key(self,debug_name)
  _Accumulator.get_single_pass_gatherer_keys(self)
  _Accumulator.init_new(server_args,expert_location_metadata,rank)
  _Accumulator.reset(self)
  _Buffer.append(self,value)
  _Buffer.get_all(self)
  _Buffer.init_new(item_shape,buffer_size,dtype,device)
  _Buffer.reset(self)
  _CircularBuffer.__init__(self,item_shape,buffer_size,dtype,device)
  _CircularBuffer.append(self,value)
  _CircularBuffer.get_all(self)
  _CircularBuffer.reset(self)
  _DeepepLowLatencySinglePassGatherer.__init__(self,*args,**kwargs)
  _DeepepLowLatencySinglePassGatherer.on_deepep_dispatch_low_latency(self,layer_idx,local_physical_count_of_layer)
  _DeepepNormalSinglePassGatherer.__init__(self,*args,**kwargs)
  _DeepepNormalSinglePassGatherer.collect(self)
  _DeepepNormalSinglePassGatherer.on_deepep_dispatch_normal(self,layer_idx,local_physical_count_of_layer,num_tokens_per_rank,num_tokens_per_rdma_rank,num_tokens_per_expert)
  _DequeCollection.__init__(self,maxlens)
  _DequeCollection.append(self,value)
  _DequeCollection.clear(self)
  _DequeCollection.mean(self)
  _DetailAccumulator.__init__(self,*args,**kwargs)
  _DetailAccumulator._process_object(obj)
  _DetailAccumulator.append(self,forward_pass_id,gatherer_key,single_pass_data)
  _DetailAccumulator.dump(self,output_mode)
  _DetailAccumulator.get_single_pass_gatherer_key(self,debug_name)
  _DetailAccumulator.get_single_pass_gatherer_keys(self)
  _DetailAccumulator.reset(self)
  _DetailSinglePassGatherer.__init__(self,server_args,expert_location_metadata,rank)
  _DetailSinglePassGatherer.collect(self)
  _DetailSinglePassGatherer.on_deepep_dispatch_normal(self,layer_idx,local_physical_count_of_layer,num_tokens_per_rank,num_tokens_per_rdma_rank,num_tokens_per_expert)
  _DetailSinglePassGatherer.on_forward_pass_start(self,forward_batch)
  _DetailSinglePassGatherer.on_select_experts(self,layer_idx,topk_ids)
  _DetailSinglePassGatherer.reset(self)
  _ExpertDistributionRecorderReal.__init__(self,server_args,expert_location_metadata,rank)
  _ExpertDistributionRecorderReal._on_forward_pass_end(self,forward_pass_id)
  _ExpertDistributionRecorderReal._on_forward_pass_start(self,forward_batch)
  _ExpertDistributionRecorderReal._on_hook(self,hook_name,**kwargs)
  _ExpertDistributionRecorderReal._reset(self)
  _ExpertDistributionRecorderReal.disable_this_region(self)
  _ExpertDistributionRecorderReal.dump_record(self,output_mode)
  _ExpertDistributionRecorderReal.on_deepep_dispatch_low_latency(self,local_physical_count_of_layer)
  _ExpertDistributionRecorderReal.on_deepep_dispatch_normal(self,local_physical_count_of_layer,num_tokens_per_rank,num_tokens_per_rdma_rank,num_tokens_per_expert)
  _ExpertDistributionRecorderReal.on_select_experts(self,topk_ids)
  _ExpertDistributionRecorderReal.recording(self)
  _ExpertDistributionRecorderReal.start_record(self)
  _ExpertDistributionRecorderReal.stop_record(self)
  _ExpertDistributionRecorderReal.with_current_layer(self,layer_idx)
  _ExpertDistributionRecorderReal.with_debug_name(self,debug_name)
  _ExpertDistributionRecorderReal.with_forward_pass(self,forward_pass_id,forward_batch)
  _InfiniteBuffer.__init__(self,item_shape,dtype,device)
  _InfiniteBuffer.append(self,value)
  _InfiniteBuffer.get_all(self)
  _InfiniteBuffer.reset(self)
  _LayerBasedCpuSinglePassGatherer.__init__(self,*args,**kwargs)
  _LayerBasedCpuSinglePassGatherer._collect_objects(self,pad_len)
  _LayerBasedCpuSinglePassGatherer._on_layer_data(self,layer_idx,objects)
  _LayerBasedCpuSinglePassGatherer.reset(self)
  _LayerBasedGpuSinglePassGatherer.__init__(self,*args,enable_global_physical_experts,**kwargs)
  _LayerBasedGpuSinglePassGatherer.collect(self)
  _LayerBasedGpuSinglePassGatherer.reset(self)
  _SelectExpertsSinglePassGatherer.__init__(self,*args,**kwargs)
  _SelectExpertsSinglePassGatherer.on_select_experts(self,layer_idx,topk_ids)
  _SinglePassGatherer.__init__(self,expert_location_metadata,rank)
  _SinglePassGatherer.collect(self)
  _SinglePassGatherer.init_new(server_args,expert_location_metadata,rank)
  _SinglePassGatherer.on_deepep_dispatch_low_latency(self,layer_idx,local_physical_count_of_layer)
  _SinglePassGatherer.on_deepep_dispatch_normal(self,layer_idx,local_physical_count_of_layer,num_tokens_per_rank,num_tokens_per_rdma_rank,num_tokens_per_expert)
  _SinglePassGatherer.on_forward_pass_start(self,forward_batch)
  _SinglePassGatherer.on_select_experts(self,layer_idx,topk_ids)
  _SinglePassGatherer.reset(self)
  _StatAccumulator.__init__(self,*args,**kwargs)
  _StatAccumulator._get_global_average_utilization_rate(self)
  _StatAccumulator.append(self,forward_pass_id,gatherer_key,single_pass_data)
  _StatAccumulator.dump(self,output_mode)
  _StatAccumulator.reset(self)
  _UtilizationRateAccumulatorMixin.__init__(self,*args,**kwargs)
  _UtilizationRateAccumulatorMixin._append_utilization_rate(self,forward_pass_id,single_pass_global_physical_count)
  _UtilizationRateAccumulatorMixin.append(self,forward_pass_id,gatherer_key,single_pass_data)
  _UtilizationRateAccumulatorMixin.reset(self)
  _convert_global_physical_count_to_logical_count(global_physical_count,num_layers,num_logical_experts,physical_to_logical_map)
  _convert_local_to_global_physical_count(local_physical_count,rank,num_local_physical_experts,num_physical_experts)
  _dump_to_file(name,data)
  _list_sum(a,b)
  compute_gpu_physical_count(physical_count_of_whatever,num_gpu)
  compute_utilization_rate(gpu_physical_count_of_batch)
  get_global_expert_distribution_recorder()
  set_global_expert_distribution_recorder(value)
eplb/expert_location.py:
  ExpertLocationMetadata.__post_init__(self)
  ExpertLocationMetadata._init_common(server_args,model_config)
  ExpertLocationMetadata._init_raw(server_args,ep_size,physical_to_logical_map,logical_to_all_physical_map)
  ExpertLocationMetadata.ep_size(self)
  ExpertLocationMetadata.init_by_eplb(server_args,model_config,logical_count)
  ExpertLocationMetadata.init_by_mapping(server_args,model_config,physical_to_logical_map)
  ExpertLocationMetadata.init_trivial(server_args,model_config)
  ExpertLocationMetadata.logical_to_all_physical(self,layer_id,logical_expert_id)
  ExpertLocationMetadata.num_layers(self)
  ExpertLocationMetadata.num_local_physical_experts(self)
  ExpertLocationMetadata.num_logical_experts(self)
  ExpertLocationMetadata.num_physical_experts(self)
  ExpertLocationMetadata.update(self,other,update_layer_ids)
  ModelConfigForExpertLocation.from_model_config(model_config)
  _compute_gpu_id_of_physical_expert(physical_expert_id,num_local_physical_experts)
  _compute_logical_to_all_physical_map(physical_to_logical_map,num_logical_experts)
  _fair_choices(arr,k,r)
  _logical_to_all_physical_raw(logical_to_all_physical_map,layer_id,logical_expert_id)
  _pad_nested_array(arr,pad_value)
  compute_initial_expert_location_metadata(server_args,model_config)
  compute_logical_to_rank_dispatch_physical_map(logical_to_all_physical_map,num_gpus,num_physical_experts,ep_rank,seed)
  get_global_expert_location_metadata()
  set_global_expert_location_metadata(value)
eplb/expert_location_dispatch.py:
  ExpertLocationDispatchInfo.init_new(cls,layer_id)
  _topk_ids_logical_to_physical_dynamic(topk_ids,info)
  _topk_ids_logical_to_physical_static(topk_ids,info)
  topk_ids_logical_to_physical(topk_ids,info)
  transform_select_experts_inputs(router_logits,correction_bias,info)
eplb/expert_location_updater.py:
  ExpertLocationUpdater.__init__(self)
  ExpertLocationUpdater.update(self,routed_experts_weights_of_layer,new_expert_location_metadata,update_layer_ids,nnodes,rank)
  _ChunkUtils.__init__(self,chunk_values,element_values)
  _ChunkUtils._chunk_index_from_element_index(num_elements,num_chunks,element_index)
  _ChunkUtils._element_slice_from_chunk_index(num_elements,num_chunks,chunk_index)
  _ChunkUtils.chunk_value_from_element_value(self,element_value)
  _ChunkUtils.element_values_from_chunk_value(self,chunk_value)
  _compute_comm_info(logical_expert_id)
  _create_isend_ops(p2p_op_infos)
  _create_isend_ops_of_logical_expert_id(logical_expert_id,src_expert_location,p2p_op_infos)
  _create_p2p_recv_and_buffer2weight_copy(buffer2weight_copy_infos,p2p_op_infos,logical_expert_id,src_rank,dst_expert_location)
  _deduplicate_ordered(arr)
  _entrypoint()
  _execute_buffer2weight_copies(buffer2weight_copy_infos)
  _execute_p2p_ops(p2p_op_infos)
  _get_canary_value(meta,layer_id)
  _get_direction_from_op(op)
  _get_local_expert_location(expert_location)
  _get_tensor(tensors,tensor_index,expert_location)
  _group_by(items,keyfunc)
  _handle_recv(buffer2weight_copy_infos,p2p_op_infos)
  _handle_recv_of_dst_expert_location(dst_expert_location,buffer2weight_copy_infos,p2p_op_infos)
  _log_p2p_op_metrics(p2p_op_infos,num_gpu_per_node,world_size,self_node_id)
  _update_expert_weights(**kwargs)
  _update_expert_weights_raw(routed_experts_weights_of_layer,old_expert_location_metadata,new_expert_location_metadata,update_layer_ids,nnodes,rank)
  _update_expert_weights_with_canary(routed_experts_weights_of_layer,old_expert_location_metadata,new_expert_location_metadata,update_layer_ids,nnodes,rank)
  create_temp_buffers(sample_tensors)
  update_expert_weights_single_layer(routed_experts_weights,temp_buffers,old_physical_to_logical_map,new_physical_to_logical_map,num_local_physical_experts,num_gpu_per_node,rank,world_size,debug,log_metrics)
