AST Function Index
Root: /Users/vincentzed/Documents/Github/open_source/sglang/python/sglang/srt
Excluded directories:

File: mem_cache/allocator.py
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, device: str, kvcache: KVCache, need_sort: bool)
    class: BaseTokenToKVPoolAllocator
  - name: debug_print
    signature: (self)
    return: str
    class: BaseTokenToKVPoolAllocator
  - name: available_size
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: get_kvcache
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: restore_state
    signature: (self, state)
    class: BaseTokenToKVPoolAllocator
  - name: backup_state
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: free_group_begin
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: free_group_end
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: merge_and_sort_free
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: get_cpu_copy
    signature: (self, *args, **kwargs)
    class: BaseTokenToKVPoolAllocator
  - name: load_cpu_copy
    signature: (self, *args, **kwargs)
    class: BaseTokenToKVPoolAllocator
  - name: alloc_extend
    signature: (self, *args, **kwargs)
    class: BaseTokenToKVPoolAllocator
  - name: alloc_decode
    signature: (self, *args, **kwargs)
    class: BaseTokenToKVPoolAllocator
  - name: clear
    signature: (self)
    class: BaseTokenToKVPoolAllocator
  - name: alloc
    signature: (self, need_size: int)
    class: BaseTokenToKVPoolAllocator
  - name: free
    signature: (self, free_index: torch.Tensor)
    class: BaseTokenToKVPoolAllocator
  - name: __init__
    signature: (self, size: int, dtype: torch.dtype, device: str, kvcache: KVCache, need_sort: bool)
    class: TokenToKVPoolAllocator
  - name: clear
    signature: (self)
    class: TokenToKVPoolAllocator
  - name: available_size
    signature: (self)
    class: TokenToKVPoolAllocator
  - name: alloc
    signature: (self, need_size: int)
    class: TokenToKVPoolAllocator
  - name: free
    signature: (self, free_index: torch.Tensor)
    class: TokenToKVPoolAllocator
  - name: get_cpu_copy
    signature: (self, indices)
    class: TokenToKVPoolAllocator
  - name: load_cpu_copy
    signature: (self, kv_cache_cpu, indices)
    class: TokenToKVPoolAllocator
  - name: __init__
    signature: (self, size: int, size_swa: int, dtype: torch.dtype, device: str, kvcache: SWAKVPool, need_sort: bool)
    class: SWATokenToKVPoolAllocator
  - name: available_size
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: full_available_size
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: swa_available_size
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: size_full
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: size_swa
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: debug_print
    signature: (self)
    return: str
    class: SWATokenToKVPoolAllocator
  - name: get_kvcache
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: translate_loc_from_full_to_swa
    signature: (self, kv_indices: torch.Tensor)
    class: SWATokenToKVPoolAllocator
  - name: alloc
    signature: (self, need_size: int)
    class: SWATokenToKVPoolAllocator
  - name: free
    signature: (self, free_index: torch.Tensor)
    class: SWATokenToKVPoolAllocator
  - name: free_swa
    signature: (self, free_index: torch.Tensor)
    class: SWATokenToKVPoolAllocator
  - name: backup_state
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: restore_state
    signature: (self, state)
    class: SWATokenToKVPoolAllocator
  - name: clear
    signature: (self)
    class: SWATokenToKVPoolAllocator
  - name: alloc_extend_kernel
    signature: (pre_lens_ptr, seq_lens_ptr, last_loc_ptr, free_page_ptr, out_indices, ret_values, bs_upper: tl.constexpr, page_size: tl.constexpr, max_num_extend_tokens: tl.constexpr)
  - name: alloc_decode_kernel
    signature: (seq_lens_ptr, last_loc_ptr, free_page_ptr, out_indices, ret_values, bs_upper: tl.constexpr, page_size: tl.constexpr)
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, device: str, kvcache: KVCache, need_sort: bool)
    class: PagedTokenToKVPoolAllocator
  - name: alloc
    signature: (self, need_size: int)
    class: PagedTokenToKVPoolAllocator
  - name: alloc_extend
    signature: (self, prefix_lens: torch.Tensor, seq_lens: torch.Tensor, last_loc: torch.Tensor, extend_num_tokens: int)
    class: PagedTokenToKVPoolAllocator
  - name: alloc_decode
    signature: (self, seq_lens: torch.Tensor, last_loc: torch.Tensor)
    class: PagedTokenToKVPoolAllocator
  - name: free
    signature: (self, free_index: torch.Tensor)
    class: PagedTokenToKVPoolAllocator
  - name: clear
    signature: (self)
    class: PagedTokenToKVPoolAllocator
  - name: get_cpu_copy
    signature: (self, indices)
    class: PagedTokenToKVPoolAllocator
  - name: load_cpu_copy
    signature: (self, kv_cache_cpu, indices)
    class: PagedTokenToKVPoolAllocator

File: mem_cache/allocator_ascend.py
  - name: alloc_extend_kernel_ascend
    signature: (prefix_lens, seq_lens, last_loc, free_pages, out_indices, page_size, device)
  - name: alloc_extend
    signature: (self, prefix_lens: torch.Tensor, seq_lens: torch.Tensor, last_loc: torch.Tensor, extend_num_tokens: int)
    class: AscendPagedTokenToKVPoolAllocator
  - name: alloc_decode
    signature: (self, seq_lens: torch.Tensor, last_loc: torch.Tensor)
    class: AscendPagedTokenToKVPoolAllocator

File: mem_cache/base_prefix_cache.py
  - name: reset
    signature: (self)
    class: BasePrefixCache
  - name: match_prefix
    signature: (self, key: List[int], **kwargs)
    return: MatchResult
    class: BasePrefixCache
  - name: cache_finished_req
    signature: (self, req: Req, **kwargs)
    class: BasePrefixCache
  - name: cache_unfinished_req
    signature: (self, req: Req, **kwargs)
    class: BasePrefixCache
  - name: evict
    signature: (self, num_tokens: int)
    class: BasePrefixCache
  - name: inc_lock_ref
    signature: (self, node: Any)
    class: BasePrefixCache
  - name: dec_lock_ref
    signature: (self, node: Any, swa_uuid_for_lock: Optional[str] = None)
    class: BasePrefixCache
  - name: evictable_size
    signature: (self)
    class: BasePrefixCache
  - name: full_evictable_size
    signature: (self)
    class: BasePrefixCache
  - name: swa_evictable_size
    signature: (self)
    class: BasePrefixCache
  - name: protected_size
    signature: (self)
    class: BasePrefixCache
  - name: full_protected_size
    signature: (self)
    class: BasePrefixCache
  - name: swa_protected_size
    signature: (self)
    class: BasePrefixCache
  - name: total_size
    signature: (self)
    class: BasePrefixCache
  - name: pretty_print
    signature: (self)
    class: BasePrefixCache
  - name: init_load_back
    signature: (self, last_host_node: Any, host_hit_length: int)
    return: Tuple[torch.Tensor, Any]
    class: BasePrefixCache
    doc: Preparing KV cache loading from host to device.
  - name: ready_to_load_host_cache
    signature: (self)
    return: Any
    class: BasePrefixCache
    doc: Notify the cache controller to start the KV cache loading
  - name: check_hicache_events
    signature: (self)
    return: Any
    class: BasePrefixCache
    doc: Check HiCache related activities to update radix tree and synchronize across TP workers if needed
  - name: take_events
    signature: (self)
    class: BasePrefixCache

File: mem_cache/chunk_cache.py
  - name: __init__
    signature: (self, req_to_token_pool: ReqToTokenPool, token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator, page_size: int)
    class: ChunkCache
  - name: reset
    signature: (self)
    class: ChunkCache
  - name: match_prefix
    signature: (self, **unused_kwargs)
    return: MatchResult
    class: ChunkCache
  - name: cache_finished_req
    signature: (self, req: Req)
    class: ChunkCache
  - name: cache_unfinished_req
    signature: (self, req: Req, chunked = False)
    class: ChunkCache
  - name: evict
    signature: (self, num_tokens: int)
    class: ChunkCache
  - name: inc_lock_ref
    signature: (self, node: Any)
    class: ChunkCache
  - name: dec_lock_ref
    signature: (self, node: Any, swa_uuid_for_lock: Optional[str] = None)
    class: ChunkCache
  - name: pretty_print
    signature: (self)
    class: ChunkCache
  - name: __init__
    signature: (self, req_to_token_pool: ReqToTokenPool, token_to_kv_pool_allocator: SWATokenToKVPoolAllocator, page_size: int)
    class: SWAChunkCache
  - name: evict_swa
    signature: (self, req: Req, prelen: int, attention_chunk_size: int)
    class: SWAChunkCache
  - name: evict
    signature: (self, num_tokens: int)
    class: SWAChunkCache

File: mem_cache/cpp_radix_tree/radix_tree.py
  - name: __init__
    signature: (self, disabled: bool, host_size: Optional[int], page_size: int, write_through_threshold: int)
    class: RadixTreeCpp
    doc: Initializes the RadixTreeCpp instance.
  - name: match_prefix
    signature: (self, prefix: List[int])
    return: Tuple[List[torch.Tensor], int, TreeNodeCpp, TreeNodeCpp]
    class: RadixTreeCpp
    doc: Matches a prefix in the radix tree.
  - name: evict
    signature: (self, num_tokens: int)
    return: List[torch.Tensor]
    class: RadixTreeCpp
    doc: Evicts a number of tokens from the radix tree.
  - name: lock_ref
    signature: (self, handle: TreeNodeCpp, lock: bool)
    return: None
    class: RadixTreeCpp
    doc: Locks or unlocks a reference to a tree node.
  - name: writing_through
    signature: (self, key: List[int], indices: torch.Tensor)
    return: Tuple[List[Tuple[IOHandle, torch.Tensor, torch.Tensor]], int]
    class: RadixTreeCpp
    doc: Inserts a key-value pair into the radix tree and perform write-through check.
  - name: loading_onboard
    signature: (self, host_node: TreeNodeCpp, new_device_indices: torch.Tensor)
    return: Tuple[IOHandle, List[torch.Tensor]]
    class: RadixTreeCpp
    doc: Updates the device indices of tree nodes within a range on the tree.
  - name: commit_writing_through
    signature: (self, handle: IOHandle, success: bool)
    return: None
    class: RadixTreeCpp
    doc: Commits the write-through process for a tree node.
  - name: commit_loading_onboard
    signature: (self, handle: IOHandle, success: bool)
    return: None
    class: RadixTreeCpp
    doc: Commits the load onboard process for tree nodes within a range on the tree.
  - name: evictable_size
    signature: (self)
    return: int
    class: RadixTreeCpp
    doc: Returns the size of the evictable part of the radix tree.
  - name: protected_size
    signature: (self)
    return: int
    class: RadixTreeCpp
    doc: Returns the size of the protected part of the radix tree.
  - name: total_size
    signature: (self)
    return: int
    class: RadixTreeCpp
    doc: Returns the total size of the radix tree (including CPU nodes).
  - name: reset
    signature: (self)
    return: None
    class: RadixTreeCpp
    doc: Resets the radix tree, clearing all nodes and indices.
  - name: debug_print
    signature: (self)
    return: None
    class: RadixTreeCpp
    doc: Prints the internal state of the radix tree for debugging purposes.

File: mem_cache/flush_cache.py
  (no function definitions found)
File: mem_cache/hicache_storage.py
  - name: get_hash_str
    signature: (token_ids: List[int], prior_hash: str = None)
    return: str
  - name: get
    signature: (self, key: str, target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: torch.Tensor | None
    class: HiCacheStorage
    doc: Retrieve the value associated with the given key.
  - name: batch_get
    signature: (self, keys: List[str], target_locations: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: List[torch.Tensor | None] | int
    class: HiCacheStorage
    doc: Retrieve values for multiple keys.
  - name: set
    signature: (self, key: str, value: Optional[Any] = None, target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: HiCacheStorage
    doc: Store the value associated with the given key.
  - name: batch_set
    signature: (self, keys: List[str], values: Optional[Any] = None, target_locations: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: HiCacheStorage
    doc: Store multiple key-value pairs.
  - name: exists
    signature: (self, key: str)
    return: bool
    class: HiCacheStorage
    doc: Check if the key exists in the storage.
  - name: delete
    signature: (self, key: str)
    return: bool
    class: HiCacheStorage
    doc: Delete the entry associated with the given key.
  - name: clear
    signature: (self)
    return: bool
    class: HiCacheStorage
    doc: Clear all entries in the storage.
  - name: batch_exists
    signature: (self, keys: List[str])
    return: int
    class: HiCacheStorage
    doc: Check if the keys exist in the storage.
  - name: __init__
    signature: (self, storage_config: HiCacheStorageConfig, file_path: str = '/tmp/hicache')
    class: HiCacheFile
  - name: _get_suffixed_key
    signature: (self, key: str)
    return: str
    class: HiCacheFile
  - name: get
    signature: (self, key: str, target_location: torch.Tensor, target_sizes: Optional[Any] = None)
    return: torch.Tensor | None
    class: HiCacheFile
  - name: batch_get
    signature: (self, keys: List[str], target_locations: List[torch.Tensor], target_sizes: Optional[Any] = None)
    return: List[torch.Tensor | None]
    class: HiCacheFile
  - name: set
    signature: (self, key: str, value: Optional[Any] = None, target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: HiCacheFile
  - name: batch_set
    signature: (self, keys: List[str], values: Optional[Any] = None, target_locations: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: HiCacheFile
  - name: exists
    signature: (self, key: str)
    return: bool
    class: HiCacheFile
  - name: delete
    signature: (self, key: str)
    return: None
    class: HiCacheFile
  - name: clear
    signature: (self)
    return: bool
    class: HiCacheFile

File: mem_cache/hiradix_cache.py
  - name: __init__
    signature: (self, req_to_token_pool: ReqToTokenPool, token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator, tp_cache_group: torch.distributed.ProcessGroup, page_size: int, hicache_ratio: float, hicache_size: int, hicache_write_policy: str, hicache_io_backend: str, hicache_mem_layout: str, hicache_storage_backend: Optional[str] = None, hicache_storage_prefetch_policy: Optional[str] = 'best_effort', model_name: Optional[str] = None, storage_backend_extra_config: Optional[str] = None)
    class: HiRadixCache
  - name: reset
    signature: (self)
    class: HiRadixCache
  - name: get_height
    signature: (self, node: TreeNode)
    class: HiRadixCache
  - name: clear_storage_backend
    signature: (self)
    class: HiRadixCache
  - name: write_backup
    signature: (self, node: TreeNode, write_back = False)
    class: HiRadixCache
  - name: write_backup_storage
    signature: (self, node: TreeNode)
    class: HiRadixCache
  - name: _inc_hit_count
    signature: (self, node: TreeNode, chunked = False)
    class: HiRadixCache
  - name: writing_check
    signature: (self, write_back = False)
    class: HiRadixCache
  - name: loading_check
    signature: (self)
    class: HiRadixCache
  - name: evictable_size
    signature: (self)
    class: HiRadixCache
  - name: evict
    signature: (self, num_tokens: int)
    class: HiRadixCache
  - name: _evict_backuped
    signature: (self, node: TreeNode)
    class: HiRadixCache
  - name: _evict_regular
    signature: (self, node: TreeNode)
    class: HiRadixCache
  - name: evict_host
    signature: (self, num_tokens: int)
    class: HiRadixCache
  - name: load_back
    signature: (self, node: TreeNode, mem_quota: Optional[int] = None)
    return: Optional[torch.Tensor]
    class: HiRadixCache
  - name: init_load_back
    signature: (self, last_node: TreeNode, host_hit_length: int, mem_quota: Optional[int] = None)
    class: HiRadixCache
  - name: ready_to_load_host_cache
    signature: (self)
    class: HiRadixCache
  - name: check_hicache_events
    signature: (self)
    class: HiRadixCache
  - name: check_revoked_prefetch
    signature: (self)
    class: HiRadixCache
  - name: check_backup_progress
    signature: (self)
    class: HiRadixCache
  - name: can_terminate_prefetch
    signature: (self, operation: PrefetchOperation)
    class: HiRadixCache
  - name: check_prefetch_progress
    signature: (self, req_id: str)
    return: bool
    class: HiRadixCache
  - name: match_prefix
    signature: (self, key: List[int], **kwargs)
    class: HiRadixCache
  - name: prefetch_from_storage
    signature: (self, req_id: str, last_host_node: TreeNode, new_input_tokens: List[int], last_hash: Optional[str] = None)
    class: HiRadixCache
  - name: _insert_helper_host
    signature: (self, node: TreeNode, key: List, host_value, hash_value)
    class: HiRadixCache
  - name: _match_prefix_helper
    signature: (self, node: TreeNode, key: List)
    class: HiRadixCache
  - name: _split_node
    signature: (self, key, child: TreeNode, split_len: int)
    class: HiRadixCache
  - name: insert
    signature: (self, key: List, value, chunked = False)
    class: HiRadixCache
  - name: _collect_leaves_device
    signature: (self)
    class: HiRadixCache
  - name: is_leaf
    signature: (node)
    class: HiRadixCache

File: mem_cache/lora_radix_cache.py
  - name: __init__
    signature: (self, lora_id: str, token_ids: List[int])
    class: LoRAKey
  - name: __len__
    signature: (self)
    class: LoRAKey
  - name: get_child_key
    signature: (key: LoRAKey)
  - name: __init__
    signature: (self, id: Optional[int] = None)
    class: LoRATreeNode
  - name: evicted
    signature: (self)
    class: LoRATreeNode
  - name: __lt__
    signature: (self, other: 'LoRATreeNode')
    class: LoRATreeNode
  - name: _key_match
    signature: (key0: LoRAKey, key1: LoRAKey)
  - name: __init__
    signature: (self, req_to_token_pool: ReqToTokenPool, token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator, page_size: int, disable: bool = False)
    class: LoRARadixCache
  - name: reset
    signature: (self)
    class: LoRARadixCache
  - name: match_prefix
    signature: (self, key: List[int], **kwargs)
    return: MatchResult
    class: LoRARadixCache
  - name: match_prefix_with_lora_id
    signature: (self, key: LoRAKey, **kwargs)
    return: MatchResult
    class: LoRARadixCache
    doc: Find the matching prefix from the lora radix tree.
  - name: insert
    signature: (self, key: LoRAKey, value = None)
    class: LoRARadixCache
  - name: cache_finished_req
    signature: (self, req: Req)
    class: LoRARadixCache
    doc: Cache request when it finishes.
  - name: cache_unfinished_req
    signature: (self, req: Req, chunked = False)
    class: LoRARadixCache
    doc: Cache request when it is unfinished.
  - name: pretty_print
    signature: (self)
    class: LoRARadixCache
  - name: total_size
    signature: (self)
    class: LoRARadixCache
  - name: evict
    signature: (self, num_tokens: int)
    class: LoRARadixCache
  - name: inc_lock_ref
    signature: (self, node: LoRATreeNode)
    class: LoRARadixCache
  - name: dec_lock_ref
    signature: (self, node: LoRATreeNode)
    class: LoRARadixCache
  - name: evictable_size
    signature: (self)
    class: LoRARadixCache
  - name: protected_size
    signature: (self)
    class: LoRARadixCache
  - name: all_values_flatten
    signature: (self)
    class: LoRARadixCache
  - name: _dfs_helper
    signature: (node: LoRATreeNode)
    class: LoRARadixCache
  - name: _match_prefix_helper
    signature: (self, node: LoRATreeNode, key: LoRAKey)
    class: LoRARadixCache
  - name: _split_node
    signature: (self, key: LoRAKey, child: LoRATreeNode, split_len: int)
    class: LoRARadixCache
  - name: _insert_helper
    signature: (self, node: LoRATreeNode, key: LoRAKey, value)
    class: LoRARadixCache
  - name: _print_helper
    signature: (self, node: LoRATreeNode, indent: int)
    class: LoRARadixCache
    doc: Prints the radix tree in a human-readable format.
  - name: _delete_leaf
    signature: (self, node)
    class: LoRARadixCache
  - name: _total_size_helper
    signature: (self)
    class: LoRARadixCache
  - name: _collect_leaves
    signature: (self)
    class: LoRARadixCache

File: mem_cache/memory_pool.py
  - name: __init__
    signature: (self, size: int, max_context_len: int, device: str, enable_memory_saver: bool)
    class: ReqToTokenPool
  - name: write
    signature: (self, indices, values)
    class: ReqToTokenPool
  - name: available_size
    signature: (self)
    class: ReqToTokenPool
  - name: alloc
    signature: (self, need_size: int)
    return: List[int]
    class: ReqToTokenPool
  - name: free
    signature: (self, free_index: Union[int, List[int]])
    class: ReqToTokenPool
  - name: clear
    signature: (self)
    class: ReqToTokenPool
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, layer_num: int, device: str, enable_memory_saver: bool, start_layer: Optional[int] = None, end_layer: Optional[int] = None)
    class: KVCache
  - name: get_key_buffer
    signature: (self, layer_id: int)
    return: torch.Tensor
    class: KVCache
  - name: get_value_buffer
    signature: (self, layer_id: int)
    return: torch.Tensor
    class: KVCache
  - name: get_kv_buffer
    signature: (self, layer_id: int)
    return: Tuple[torch.Tensor, torch.Tensor]
    class: KVCache
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor)
    return: None
    class: KVCache
  - name: register_layer_transfer_counter
    signature: (self, layer_transfer_counter)
    class: KVCache
  - name: get_cpu_copy
    signature: (self, indices)
    class: KVCache
  - name: load_cpu_copy
    signature: (self, kv_cache_cpu, indices)
    class: KVCache
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, head_num: int, head_dim: int, layer_num: int, device: str, enable_memory_saver: bool, start_layer: Optional[int] = None, end_layer: Optional[int] = None)
    class: MHATokenToKVPool
  - name: _create_buffers
    signature: (self)
    class: MHATokenToKVPool
  - name: _clear_buffers
    signature: (self)
    class: MHATokenToKVPool
  - name: get_kv_size_bytes
    signature: (self)
    class: MHATokenToKVPool
  - name: get_contiguous_buf_infos
    signature: (self)
    class: MHATokenToKVPool
  - name: maybe_get_custom_mem_pool
    signature: (self)
    class: MHATokenToKVPool
  - name: get_cpu_copy
    signature: (self, indices)
    class: MHATokenToKVPool
  - name: load_cpu_copy
    signature: (self, kv_cache_cpu, indices)
    class: MHATokenToKVPool
  - name: _get_key_buffer
    signature: (self, layer_id: int)
    class: MHATokenToKVPool
  - name: get_key_buffer
    signature: (self, layer_id: int)
    class: MHATokenToKVPool
  - name: _get_value_buffer
    signature: (self, layer_id: int)
    class: MHATokenToKVPool
  - name: get_value_buffer
    signature: (self, layer_id: int)
    class: MHATokenToKVPool
  - name: get_kv_buffer
    signature: (self, layer_id: int)
    class: MHATokenToKVPool
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor, k_scale: Optional[float] = None, v_scale: Optional[float] = None, layer_id_override: Optional[int] = None)
    class: MHATokenToKVPool
  - name: move_kv_cache
    signature: (self, tgt_loc: torch.Tensor, src_loc: torch.Tensor)
    class: MHATokenToKVPool
  - name: __init__
    signature: (self, size: int, size_swa: int, dtype: torch.dtype, head_num: int, head_dim: int, swa_attention_layer_ids: List[int], full_attention_layer_ids: List[int], enable_kvcache_transpose: bool, device: str)
    class: SWAKVPool
  - name: get_kv_size_bytes
    signature: (self)
    class: SWAKVPool
  - name: get_contiguous_buf_infos
    signature: (self)
    class: SWAKVPool
  - name: get_key_buffer
    signature: (self, layer_id: int)
    class: SWAKVPool
  - name: get_value_buffer
    signature: (self, layer_id: int)
    class: SWAKVPool
  - name: get_kv_buffer
    signature: (self, layer_id: int)
    class: SWAKVPool
  - name: translate_loc_from_full_to_swa
    signature: (self, kv_indices: torch.Tensor)
    class: SWAKVPool
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor, k_scale: float = 1.0, v_scale: float = 1.0)
    class: SWAKVPool
  - name: _create_buffers
    signature: (self)
    class: AscendTokenToKVPool
  - name: get_contiguous_buf_infos
    signature: (self)
    class: AscendTokenToKVPool
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor, k_scale: Optional[float] = None, v_scale: Optional[float] = None)
    class: AscendTokenToKVPool
  - name: set_mla_kv_buffer_kernel
    signature: (kv_buffer_ptr, cache_k_nope_ptr, cache_k_rope_ptr, loc_ptr, buffer_stride: tl.constexpr, nope_stride: tl.constexpr, rope_stride: tl.constexpr, nope_dim: tl.constexpr, rope_dim: tl.constexpr, BLOCK: tl.constexpr)
  - name: set_mla_kv_buffer_triton
    signature: (kv_buffer: torch.Tensor, loc: torch.Tensor, cache_k_nope: torch.Tensor, cache_k_rope: torch.Tensor)
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, kv_lora_rank: int, qk_rope_head_dim: int, layer_num: int, device: str, enable_memory_saver: bool, start_layer: Optional[int] = None, end_layer: Optional[int] = None)
    class: MLATokenToKVPool
  - name: get_kv_size_bytes
    signature: (self)
    class: MLATokenToKVPool
  - name: get_contiguous_buf_infos
    signature: (self)
    class: MLATokenToKVPool
  - name: maybe_get_custom_mem_pool
    signature: (self)
    class: MLATokenToKVPool
  - name: get_key_buffer
    signature: (self, layer_id: int)
    class: MLATokenToKVPool
  - name: get_value_buffer
    signature: (self, layer_id: int)
    class: MLATokenToKVPool
  - name: get_kv_buffer
    signature: (self, layer_id: int)
    class: MLATokenToKVPool
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor)
    class: MLATokenToKVPool
  - name: set_mla_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k_nope: torch.Tensor, cache_k_rope: torch.Tensor)
    class: MLATokenToKVPool
  - name: get_cpu_copy
    signature: (self, indices)
    class: MLATokenToKVPool
  - name: load_cpu_copy
    signature: (self, kv_cache_cpu, indices)
    class: MLATokenToKVPool
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, kv_lora_rank: int, qk_rope_head_dim: int, layer_num: int, device: str, enable_memory_saver: bool, start_layer: Optional[int] = None, end_layer: Optional[int] = None)
    class: AscendMLAPagedTokenToKVPool
  - name: get_kv_size_bytes
    signature: (self)
    class: AscendMLAPagedTokenToKVPool
  - name: get_kv_buffer
    signature: (self, layer_id: int)
    class: AscendMLAPagedTokenToKVPool
  - name: get_key_buffer
    signature: (self, layer_id: int)
    class: AscendMLAPagedTokenToKVPool
  - name: get_value_buffer
    signature: (self, layer_id: int)
    class: AscendMLAPagedTokenToKVPool
  - name: get_contiguous_buf_infos
    signature: (self)
    class: AscendMLAPagedTokenToKVPool
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor)
    class: AscendMLAPagedTokenToKVPool
  - name: __init__
    signature: (self, size: int, page_size: int, dtype: torch.dtype, head_num: int, head_dim: int, layer_num: int, device: str, heavy_channel_num: int, enable_memory_saver: bool, start_layer: Optional[int] = None, end_layer: Optional[int] = None)
    class: DoubleSparseTokenToKVPool
  - name: get_key_buffer
    signature: (self, layer_id: int)
    class: DoubleSparseTokenToKVPool
  - name: get_value_buffer
    signature: (self, layer_id: int)
    class: DoubleSparseTokenToKVPool
  - name: get_label_buffer
    signature: (self, layer_id: int)
    class: DoubleSparseTokenToKVPool
  - name: get_kv_buffer
    signature: (self, layer_id: int)
    class: DoubleSparseTokenToKVPool
  - name: set_kv_buffer
    signature: (self, layer: RadixAttention, loc: torch.Tensor, cache_k: torch.Tensor, cache_v: torch.Tensor, cache_label: torch.Tensor)
    class: DoubleSparseTokenToKVPool
  - name: copy_all_layer_kv_cache
    signature: (data_ptrs, strides, tgt_loc_ptr, src_loc_ptr, num_locs, num_locs_upper: tl.constexpr)

File: mem_cache/memory_pool_host.py
  - name: synchronized
    signature: (debug_only = False)
  - name: _decorator
    signature: (func)
  - name: wrapper
    signature: (self, *args, **kwargs)
  - name: __init__
    signature: (self, device_pool: KVCache, host_to_device_ratio: float, host_size: int, page_size: int, layout: str, pin_memory: bool, device: str)
    class: HostKVCache
  - name: get_size_per_token
    signature: (self)
    class: HostKVCache
  - name: init_kv_buffer
    signature: (self)
    class: HostKVCache
  - name: load_to_device_per_layer
    signature: (self, device_pool, host_indices, device_indices, layer_id, io_backend)
    return: None
    class: HostKVCache
    doc: Load KV data from the host memory pool to the device memory pool for a specific layer.
  - name: backup_from_device_all_layer
    signature: (self, device_pool, host_indices, device_indices, io_backend)
    return: None
    class: HostKVCache
    doc: Backup KV data from the device memory pool to the host memory pool for all layers.
  - name: get_flat_data_page
    signature: (self, index)
    return: torch.Tensor
    class: HostKVCache
    doc: Get a flat data page from the host memory pool.
  - name: get_dummy_flat_data_page
    signature: (self)
    return: torch.Tensor
    class: HostKVCache
    doc: Get a dummy flat data page from the host memory pool.
  - name: set_from_flat_data_page
    signature: (self, index: int, data_page: torch.Tensor)
    return: None
    class: HostKVCache
    doc: Set a flat data page to the host memory pool.
  - name: clear
    signature: (self)
    class: HostKVCache
  - name: available_size
    signature: (self)
    class: HostKVCache
  - name: alloc
    signature: (self, need_size: int)
    return: torch.Tensor
    class: HostKVCache
  - name: free
    signature: (self, indices: torch.Tensor)
    return: int
    class: HostKVCache
  - name: get_state
    signature: (self, indices: torch.Tensor)
    return: MemoryStateInt
    class: HostKVCache
  - name: is_reserved
    signature: (self, indices: torch.Tensor)
    return: bool
    class: HostKVCache
  - name: is_protected
    signature: (self, indices: torch.Tensor)
    return: bool
    class: HostKVCache
  - name: is_synced
    signature: (self, indices: torch.Tensor)
    return: bool
    class: HostKVCache
  - name: is_backup
    signature: (self, indices: torch.Tensor)
    return: bool
    class: HostKVCache
  - name: update_backup
    signature: (self, indices: torch.Tensor)
    class: HostKVCache
  - name: update_prefetch
    signature: (self, indices: torch.Tensor)
    class: HostKVCache
  - name: update_synced
    signature: (self, indices: torch.Tensor)
    class: HostKVCache
  - name: protect_write
    signature: (self, indices: torch.Tensor)
    class: HostKVCache
  - name: protect_load
    signature: (self, indices: torch.Tensor)
    class: HostKVCache
  - name: complete_io
    signature: (self, indices: torch.Tensor)
    class: HostKVCache
  - name: __init__
    signature: (self, device_pool: MHATokenToKVPool, host_to_device_ratio: float, host_size: int, page_size: int, layout: str, pin_memory: bool = True, device: str = 'cpu')
    class: MHATokenToKVPoolHost
  - name: get_size_per_token
    signature: (self)
    class: MHATokenToKVPoolHost
  - name: get_ksize_per_token
    signature: (self)
    class: MHATokenToKVPoolHost
  - name: init_kv_buffer
    signature: (self)
    class: MHATokenToKVPoolHost
  - name: k_buffer
    signature: (self)
    class: MHATokenToKVPoolHost
  - name: v_buffer
    signature: (self)
    class: MHATokenToKVPoolHost
  - name: load_to_device_per_layer
    signature: (self, device_pool, host_indices, device_indices, layer_id, io_backend)
    class: MHATokenToKVPoolHost
  - name: backup_from_device_all_layer
    signature: (self, device_pool, host_indices, device_indices, io_backend)
    class: MHATokenToKVPoolHost
  - name: get_flat_data_page
    signature: (self, index)
    return: torch.Tensor
    class: MHATokenToKVPoolHost
  - name: get_dummy_flat_data_page
    signature: (self)
    return: torch.Tensor
    class: MHATokenToKVPoolHost
  - name: set_from_flat_data_page
    signature: (self, index: int, data_page: torch.Tensor)
    return: None
    class: MHATokenToKVPoolHost
  - name: get_buffer_meta
    signature: (self, keys, indices, local_rank)
    class: MHATokenToKVPoolHost
  - name: get_buffer_with_hash
    signature: (self, keys, indices)
    class: MHATokenToKVPoolHost
  - name: __init__
    signature: (self, device_pool: MLATokenToKVPool, host_to_device_ratio: float, host_size: int, page_size: int, layout: str, pin_memory: bool = True, device: str = 'cpu')
    class: MLATokenToKVPoolHost
  - name: get_size_per_token
    signature: (self)
    class: MLATokenToKVPoolHost
  - name: get_ksize_per_token
    signature: (self)
    class: MLATokenToKVPoolHost
  - name: init_kv_buffer
    signature: (self)
    class: MLATokenToKVPoolHost
  - name: load_to_device_per_layer
    signature: (self, device_pool, host_indices, device_indices, layer_id, io_backend)
    class: MLATokenToKVPoolHost
  - name: backup_from_device_all_layer
    signature: (self, device_pool, host_indices, device_indices, io_backend)
    class: MLATokenToKVPoolHost
  - name: get_flat_data_page
    signature: (self, index)
    return: torch.Tensor
    class: MLATokenToKVPoolHost
  - name: get_dummy_flat_data_page
    signature: (self)
    return: torch.Tensor
    class: MLATokenToKVPoolHost
  - name: set_from_flat_data_page
    signature: (self, index: int, data_page: torch.Tensor)
    return: None
    class: MLATokenToKVPoolHost
  - name: get_buffer_meta
    signature: (self, keys, indices, local_rank)
    class: MLATokenToKVPoolHost
  - name: get_buffer_with_hash
    signature: (self, keys, indices)
    class: MLATokenToKVPoolHost

File: mem_cache/multimodal_cache.py
  - name: __init__
    signature: (self, max_size: int)
    class: MultiModalCache
  - name: _allocate
    signature: (self, embedding_size: int)
    return: bool
    class: MultiModalCache
    doc: Allocate space by evicting least recently used entries
  - name: put
    signature: (self, mm_hash: int, embedding: torch.Tensor)
    return: bool
    class: MultiModalCache
  - name: has
    signature: (self, mm_hash: int)
    return: bool
    class: MultiModalCache
  - name: get
    signature: (self, mm_hash: int)
    return: torch.Tensor
    class: MultiModalCache
    doc: Get embedding and update LRU order
  - name: clear
    signature: (self)
    class: MultiModalCache
  - name: _get_tensor_size
    signature: (self, embedding: torch.Tensor)
    class: MultiModalCache
  - name: __len__
    signature: (self)
    class: MultiModalCache

File: mem_cache/radix_cache.py
  - name: __init__
    signature: (self, id: Optional[int] = None)
    class: TreeNode
  - name: evicted
    signature: (self)
    class: TreeNode
  - name: backuped
    signature: (self)
    class: TreeNode
  - name: protect_host
    signature: (self)
    class: TreeNode
    doc: Protect the host value from eviction.
  - name: release_host
    signature: (self)
    class: TreeNode
    doc: Release the host value, allowing it to be evicted.
  - name: get_last_hash_value
    signature: (self)
    return: Optional[str]
    class: TreeNode
    doc: Returns the hash value of the last page in this node.
  - name: __lt__
    signature: (self, other: 'TreeNode')
    class: TreeNode
  - name: _key_match_page_size1
    signature: (key0: List, key1: List)
  - name: _key_match_paged
    signature: (key0: List, key1: List, page_size: int)
  - name: __init__
    signature: (self, req_to_token_pool: ReqToTokenPool, token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator, page_size: int, disable: bool = False, enable_kv_cache_events: bool = False)
    class: RadixCache
  - name: reset
    signature: (self)
    class: RadixCache
  - name: match_prefix
    signature: (self, key: List[int], **kwargs)
    return: MatchResult
    class: RadixCache
    doc: Find the matching prefix from the radix tree.
  - name: insert
    signature: (self, key: List, value = None, chunked = False)
    class: RadixCache
  - name: cache_finished_req
    signature: (self, req: Req)
    class: RadixCache
    doc: Cache request when it finishes.
  - name: cache_unfinished_req
    signature: (self, req: Req, chunked = False)
    class: RadixCache
    doc: Cache request when it is unfinished.
  - name: pretty_print
    signature: (self)
    class: RadixCache
  - name: total_size
    signature: (self)
    class: RadixCache
  - name: evict
    signature: (self, num_tokens: int)
    class: RadixCache
  - name: inc_lock_ref
    signature: (self, node: TreeNode)
    class: RadixCache
  - name: dec_lock_ref
    signature: (self, node: TreeNode)
    class: RadixCache
  - name: evictable_size
    signature: (self)
    class: RadixCache
  - name: protected_size
    signature: (self)
    class: RadixCache
  - name: all_values_flatten
    signature: (self)
    class: RadixCache
  - name: _dfs_helper
    signature: (node: TreeNode)
    class: RadixCache
  - name: _match_prefix_helper
    signature: (self, node: TreeNode, key: List)
    class: RadixCache
  - name: _split_node
    signature: (self, key, child: TreeNode, split_len: int)
    class: RadixCache
  - name: _insert_helper
    signature: (self, node: TreeNode, key: List, value)
    class: RadixCache
  - name: _print_helper
    signature: (self, node: TreeNode, indent: int)
    class: RadixCache
    doc: Prints the radix tree in a human-readable format.
  - name: _delete_leaf
    signature: (self, node)
    class: RadixCache
  - name: _total_size_helper
    signature: (self)
    class: RadixCache
  - name: _collect_leaves
    signature: (self)
    class: RadixCache
  - name: _record_store_event
    signature: (self, node: TreeNode)
    class: RadixCache
  - name: _record_remove_event
    signature: (self, node: TreeNode)
    class: RadixCache
  - name: _record_all_cleared_event
    signature: (self)
    class: RadixCache
  - name: take_events
    signature: (self)
    class: RadixCache
    doc: Atomically takes all events and clears the queue.

File: mem_cache/radix_cache_cpp.py
  - name: _merge_tensor
    signature: (self, l: List[torch.Tensor])
    return: torch.Tensor
    class: RadixCacheCpp
    doc: Merge a list of tensors into a single tensor.
  - name: __init__
    signature: (self, disable: bool, use_hicache: bool, req_to_token_pool: ReqToTokenPool, token_to_kv_pool: BaseTokenToKVPoolAllocator, tp_cache_group: torch.distributed.ProcessGroup, page_size: int, hicache_ratio: float, hicache_size: int, hicache_write_policy: str, enable_kv_cache_events: bool = False, hicache_oracle: bool = False, enable_write_cancel: bool = False)
    class: RadixCacheCpp
  - name: reset
    signature: (self)
    class: RadixCacheCpp
  - name: match_prefix
    signature: (self, key: List[int], **kwargs)
    return: MatchResult
    class: RadixCacheCpp
  - name: _insert
    signature: (self, key: List[int], value: torch.Tensor)
    return: int
    class: RadixCacheCpp
    doc: Insert a key-value pair into the radix tree.
  - name: dec_lock_ref
    signature: (self, node: TreeNodeCpp)
    class: RadixCacheCpp
    doc: Decrement the reference count of a node to root of the radix tree.
  - name: inc_lock_ref
    signature: (self, node: TreeNodeCpp)
    class: RadixCacheCpp
    doc: Increment the reference count of from a node to root of the radix tree.
  - name: evict
    signature: (self, num_tokens: int)
    class: RadixCacheCpp
  - name: evictable_size
    signature: (self)
    class: RadixCacheCpp
  - name: protected_size
    signature: (self)
    class: RadixCacheCpp
  - name: total_size
    signature: (self)
    class: RadixCacheCpp
  - name: cache_finished_req
    signature: (self, req: Req)
    class: RadixCacheCpp
    doc: Cache request when it finishes.
  - name: cache_unfinished_req
    signature: (self, req: Req, chunked = False)
    class: RadixCacheCpp
    doc: Cache request when it is unfinished.
  - name: pretty_print
    signature: (self)
    class: RadixCacheCpp

File: mem_cache/storage/hf3fs/client_hf3fs.py
  - name: rsynchronized
    signature: ()
  - name: _decorator
    signature: (func)
  - name: wrapper
    signature: (self, *args, **kwargs)
  - name: wsynchronized
    signature: ()
  - name: _decorator
    signature: (func)
  - name: wrapper
    signature: (self, *args, **kwargs)
  - name: __init__
    signature: (self, path: str, size: int, bytes_per_page: int, entries: int)
    class: Hf3fsClient
  - name: batch_read
    signature: (self, offsets: List[int], tensors: List[torch.Tensor])
    return: List[int]
    class: Hf3fsClient
  - name: batch_write
    signature: (self, offsets: List[int], tensors: List[torch.Tensor])
    return: List[int]
    class: Hf3fsClient
  - name: check
    signature: (self, offsets: List[int], tensors: List[torch.Tensor])
    return: None
    class: Hf3fsClient
  - name: get_size
    signature: (self)
    return: int
    class: Hf3fsClient
  - name: close
    signature: (self)
    return: None
    class: Hf3fsClient
  - name: flush
    signature: (self)
    return: None
    class: Hf3fsClient

File: mem_cache/storage/hf3fs/mini_3fs_metadata_server.py
  - name: __init__
    signature: (self, num_pages: int)
    class: RankMetadata
  - name: exists_keys
    signature: (self, keys: List[str])
    return: List[bool]
    class: RankMetadata
    doc: Check if keys exist in metadata.
  - name: reserve_and_allocate_page_indices
    signature: (self, keys: List[Tuple[str, str]])
    return: List[Tuple[bool, int]]
    class: RankMetadata
    doc: Reserve and allocate page indices for keys.
  - name: confirm_write
    signature: (self, written_keys_to_confirm: List[Tuple[str, int]], pages_to_release: List[int])
    return: None
    class: RankMetadata
    doc: Confirm write operations and release pages.
  - name: delete_keys
    signature: (self, keys: List[str])
    return: int
    class: RankMetadata
    doc: Delete keys and return count of deleted keys.
  - name: clear_all
    signature: (self)
    return: None
    class: RankMetadata
    doc: Clear all metadata.
  - name: get_page_indices
    signature: (self, keys: List[str])
    return: List[Optional[int]]
    class: RankMetadata
    doc: Get page indices for keys.
  - name: __init__
    signature: (self, persistence_path: Optional[str], save_interval: int)
    class: GlobalMetadataState
  - name: load_from_disk
    signature: (self)
    class: GlobalMetadataState
  - name: save_to_disk
    signature: (self)
    class: GlobalMetadataState
  - name: schedule_save
    signature: (self)
    class: GlobalMetadataState
  - name: shutdown
    signature: (self)
    class: GlobalMetadataState
  - name: __init__
    signature: (self, persistence_path: Optional[str] = None, save_interval: int = 60)
    class: Hf3fsMetadataServer
  - name: _setup_routes
    signature: (self)
    class: Hf3fsMetadataServer
    doc: Setup FastAPI routes.
  - name: get_rank_metadata
    signature: (self, rank: int)
    return: RankMetadata
    class: Hf3fsMetadataServer
    doc: Get rank metadata with proper error handling.
  - name: initialize
    signature: (self, rank: int, request: Request)
    class: Hf3fsMetadataServer
    doc: Initialize a rank with specified number of pages.
  - name: exists
    signature: (self, rank: int, request: Request)
    class: Hf3fsMetadataServer
    doc: Check if keys exist in metadata.
  - name: reserve_and_allocate_page_indices
    signature: (self, rank: int, request: Request)
    class: Hf3fsMetadataServer
    doc: Reserve and allocate page indices for keys.
  - name: confirm_write
    signature: (self, rank: int, request: Request)
    class: Hf3fsMetadataServer
    doc: Confirm write operations and release pages.
  - name: delete_keys
    signature: (self, rank: int, request: Request)
    class: Hf3fsMetadataServer
    doc: Delete keys from metadata.
  - name: clear
    signature: (self, rank: int)
    class: Hf3fsMetadataServer
    doc: Clear all metadata for a rank.
  - name: get_page_indices
    signature: (self, rank: int, request: Request)
    class: Hf3fsMetadataServer
    doc: Get page indices for keys.
  - name: run
    signature: (self, host: str = '0.0.0.0', port: int = 18000)
    class: Hf3fsMetadataServer
    doc: Run the metadata server.
  - name: __init__
    signature: (self, base_url: str, max_retries: int = 3)
    class: Hf3fsGlobalMetadataClient
  - name: _post
    signature: (self, endpoint: str, json_data: dict)
    return: dict
    class: Hf3fsGlobalMetadataClient
  - name: initialize
    signature: (self, rank: int, num_pages: int)
    return: None
    class: Hf3fsGlobalMetadataClient
  - name: reserve_and_allocate_page_indices
    signature: (self, rank: int, keys: List[Tuple[str, str]])
    return: List[Tuple[bool, int]]
    class: Hf3fsGlobalMetadataClient
  - name: confirm_write
    signature: (self, rank: int, written_keys_to_confirm: List[Tuple[str, int]], pages_to_release: List[int])
    return: None
    class: Hf3fsGlobalMetadataClient
  - name: delete_keys
    signature: (self, rank: int, keys: List[str])
    return: None
    class: Hf3fsGlobalMetadataClient
  - name: exists
    signature: (self, rank: int, keys: List[str])
    return: List[bool]
    class: Hf3fsGlobalMetadataClient
  - name: clear
    signature: (self, rank: int)
    return: None
    class: Hf3fsGlobalMetadataClient
  - name: get_page_indices
    signature: (self, rank: int, keys: List[str])
    return: List[Optional[int]]
    class: Hf3fsGlobalMetadataClient
  - name: __init__
    signature: (self)
    class: Hf3fsLocalMetadataClient
  - name: initialize
    signature: (self, rank: int, num_pages: int)
    return: None
    class: Hf3fsLocalMetadataClient
  - name: reserve_and_allocate_page_indices
    signature: (self, rank: int, keys: List[Tuple[str, str]])
    return: List[Tuple[bool, int]]
    class: Hf3fsLocalMetadataClient
    doc: Reserve and allocate page indices for keys.
  - name: confirm_write
    signature: (self, rank: int, written_keys_to_confirm: List[Tuple[str, int]], pages_to_release: List[int])
    return: None
    class: Hf3fsLocalMetadataClient
    doc: Confirm write operations.
  - name: delete_keys
    signature: (self, rank: int, keys: List[str])
    return: None
    class: Hf3fsLocalMetadataClient
    doc: Delete keys.
  - name: exists
    signature: (self, rank: int, keys: List[str])
    return: List[bool]
    class: Hf3fsLocalMetadataClient
    doc: Check if keys exist.
  - name: clear
    signature: (self, rank: int)
    return: None
    class: Hf3fsLocalMetadataClient
    doc: Clear all metadata for rank.
  - name: get_page_indices
    signature: (self, rank: int, keys: List[str])
    return: List[Optional[int]]
    class: Hf3fsLocalMetadataClient
    doc: Get page indices for keys.
  - name: run_metadata_server
    signature: (host: str = '0.0.0.0', port: int = 18000, persistence_path: Optional[str] = None, save_interval: int = 60)
    doc: Run the HF3FS metadata server.

File: mem_cache/storage/hf3fs/storage_hf3fs.py
  - name: initialize
    signature: (self, rank: int, num_pages: int)
    return: None
    class: Hf3fsMetadataInterface
    doc: Initialize the metadata service with specified number of pages.
  - name: reserve_and_allocate_page_indices
    signature: (self, rank: int, keys: List[Tuple[str, str]])
    return: List[Tuple[bool, int]]
    class: Hf3fsMetadataInterface
    doc: Reserve and allocate page indices for the specified keys.
  - name: confirm_write
    signature: (self, rank: int, written_keys_to_confirm: List[Tuple[str, int]], pages_to_release: List[int])
    return: None
    class: Hf3fsMetadataInterface
    doc: Confirm that key-value pairs have been successfully written to storage.
  - name: get_page_indices
    signature: (self, rank: int, keys: List[str])
    return: List[Optional[int]]
    class: Hf3fsMetadataInterface
    doc: Get page indices for the specified keys.
  - name: delete_keys
    signature: (self, rank: int, keys: List[str])
    return: None
    class: Hf3fsMetadataInterface
    doc: Delete specified keys and their associated pages.
  - name: exists
    signature: (self, rank: int, keys: List[str])
    return: List[bool]
    class: Hf3fsMetadataInterface
    doc: Check if the specified keys exist.
  - name: clear
    signature: (self, rank: int)
    return: None
    class: Hf3fsMetadataInterface
    doc: Clear all key-value pairs and page allocations for the specified rank.
  - name: __init__
    signature: (self, n: int)
    class: AtomicCounter
  - name: next
    signature: (self)
    return: int
    class: AtomicCounter
  - name: synchronized
    signature: ()
  - name: _decorator
    signature: (func)
  - name: wrapper
    signature: (self, *args, **kwargs)
  - name: __init__
    signature: (self, rank: int, file_path: str, file_size: int, numjobs: int, bytes_per_page: int, entries: int, dtype: torch.dtype, metadata_client: Hf3fsMetadataInterface, is_mla_model: bool = False)
    class: HiCacheHF3FS
  - name: from_env_config
    signature: (bytes_per_page: int, dtype: torch.dtype, storage_config: HiCacheStorageConfig = None)
    return: 'HiCacheHF3FS'
    class: HiCacheHF3FS
  - name: get
    signature: (self, key: str, target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: torch.Tensor | None
    class: HiCacheHF3FS
  - name: batch_get
    signature: (self, keys: List[str], target_locations: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: List[torch.Tensor | None]
    class: HiCacheHF3FS
  - name: set
    signature: (self, key: str, value: Optional[Any] = None, target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: HiCacheHF3FS
  - name: batch_set
    signature: (self, keys: List[str], values: Optional[Any] = None, target_locations: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: HiCacheHF3FS
  - name: delete
    signature: (self, key: str)
    return: None
    class: HiCacheHF3FS
  - name: exists
    signature: (self, key: str)
    return: bool
    class: HiCacheHF3FS
  - name: batch_exists
    signature: (self, keys: List[str])
    return: int
    class: HiCacheHF3FS
  - name: clear
    signature: (self)
    return: bool
    class: HiCacheHF3FS
  - name: close
    signature: (self)
    return: None
    class: HiCacheHF3FS

File: mem_cache/storage/hf3fs/test_hf3fs_utils.py
  - name: test_rw_shm
    signature: ()

File: mem_cache/storage/mooncake_store/mooncake_store.py
  - name: from_file
    signature: ()
    return: 'MooncakeStoreConfig'
    class: MooncakeStoreConfig
    doc: Load the config from a JSON file.
  - name: load_from_env
    signature: ()
    return: 'MooncakeStoreConfig'
    class: MooncakeStoreConfig
    doc: Load config from a file specified in the environment variable.
  - name: __post_init__
    signature: (self)
    class: MooncakeStoreConfig
  - name: __init__
    signature: (self, storage_config: HiCacheStorageConfig = None)
    class: MooncakeStore
  - name: warmup
    signature: (self)
    class: MooncakeStore
  - name: register_buffer
    signature: (self, buffer: torch.Tensor)
    return: None
    class: MooncakeStore
  - name: set
    signature: (self, key, value: Optional[Any] = None, target_location: Optional[List[int]] = None, target_sizes: Optional[List[int]] = None)
    return: bool
    class: MooncakeStore
  - name: batch_set
    signature: (self, keys: List[str], values: Optional[List[torch.Tensor]] = None, target_location: Optional[List[int]] = None, target_sizes: Optional[List[int]] = None)
    return: bool
    class: MooncakeStore
  - name: get
    signature: (self, key, target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: bool
    class: MooncakeStore
  - name: batch_get
    signature: (self, keys: List[str], target_location: Optional[Any] = None, target_sizes: Optional[Any] = None)
    return: int
    class: MooncakeStore
  - name: exists
    signature: (self, key)
    return: bool
    class: MooncakeStore
  - name: batch_exists
    signature: (self, keys)
    return: int
    class: MooncakeStore
  - name: delete
    signature: (self, key)
    return: None
    class: MooncakeStore
  - name: close
    signature: (self)
    class: MooncakeStore
  - name: clear
    signature: (self)
    return: None
    class: MooncakeStore
  - name: _put_batch_zero_copy_impl
    signature: (self, key_strs: List[str], buffer_ptrs: List[int], buffer_sizes: List[int])
    return: List[int]
    class: MooncakeStore
  - name: _get_batch_zero_copy_impl
    signature: (self, key_strs: List[str], buffer_ptrs: List[int], buffer_sizes: List[int])
    return: List[int]
    class: MooncakeStore
  - name: _batch_exist
    signature: (self, key_strs: List[str])
    return: List[int]
    class: MooncakeStore

File: mem_cache/storage/mooncake_store/unit_test.py
  - name: test_init_and_warmup
    signature: ()
  - name: test_register_buffer
    signature: ()
  - name: test_set_and_get
    signature: ()
  - name: test_exists
    signature: ()

File: mem_cache/storage/nixl/hicache_nixl.py
  - name: __init__
    signature: (self, file_path: str = '/tmp/hicache_storage', plugin: str = 'auto')
    class: HiCacheNixl
    doc: Initialize NIXL storage connector.
  - name: register_buffers
    signature: (self, buffers: Union[torch.Tensor, List[torch.Tensor], List[tuple]])
    return: Optional[Any]
    class: HiCacheNixl
    doc: Register tensor(s) or target locations in host memory (list of addr,len tuples) with NIXL.
  - name: register_files
    signature: (self, file_paths: List[str], open_file: Optional[bool] = True)
    return: Optional[Any]
    class: HiCacheNixl
    doc: Register files with NIXL.
  - name: register_objects
    signature: (self, keys: List[str], sizes: Optional[List[int]] = None)
    return: Optional[Any]
    class: HiCacheNixl
    doc: Register objects with NIXL.
  - name: _execute_transfer
    signature: (self, buffers: Optional[List[torch.Tensor | tuple]], keys: List[str], direction: str)
    return: bool
    class: HiCacheNixl
  - name: get
    signature: (self, key: str, target_location: Optional[torch.Tensor | int] = None, target_sizes: Optional[int] = None)
    return: torch.Tensor | None
    class: HiCacheNixl
  - name: batch_get
    signature: (self, keys: List[str], target_locations: Optional[List[torch.Tensor | int]] = None, target_sizes: Optional[List[int]] = None)
    return: List[torch.Tensor | None]
    class: HiCacheNixl
  - name: set
    signature: (self, key: str, value: Optional[torch.Tensor] = None, target_location: Optional[int] = None, target_sizes: Optional[int] = None)
    return: bool
    class: HiCacheNixl
  - name: batch_set
    signature: (self, keys: List[str], values: Optional[List[torch.Tensor]] = None, target_locations: Optional[List[int]] = None, target_sizes: Optional[List[int]] = None)
    return: bool
    class: HiCacheNixl
  - name: exists
    signature: (self, key: str)
    return: bool
    class: HiCacheNixl

File: mem_cache/storage/nixl/nixl_utils.py
  - name: __init__
    signature: (self, plugin: str = 'auto')
    class: NixlBackendSelection
    doc: Initialize backend selection.
  - name: set_bucket
    signature: (self, bucket_name: str)
    return: None
    class: NixlBackendSelection
    doc: Set AWS bucket name in environment variable.
  - name: create_backend
    signature: (self, agent)
    return: bool
    class: NixlBackendSelection
    doc: Create the appropriate NIXL backend based on configuration.
  - name: __init__
    signature: (self, agent)
    class: NixlRegistration
  - name: create_query_tuples
    signature: (self, key: str, mem_type: str, file_manager = None)
    return: List[Tuple]
    class: NixlRegistration
    doc: Create NIXL tuples for querying memory.
  - name: _register_memory
    signature: (self, items: Union[List[tuple], torch.Tensor, List[torch.Tensor]], mem_type: Optional[str] = None)
    return: Optional[Any]
    class: NixlRegistration
    doc: Common registration logic for files, objects, and buffers.
  - name: __init__
    signature: (self, base_dir: str)
    class: NixlFileManager
    doc: Initialize file manager.
  - name: get_file_path
    signature: (self, key: str)
    return: str
    class: NixlFileManager
    doc: Get full file path for a given key.
  - name: create_file
    signature: (self, file_path: str)
    return: bool
    class: NixlFileManager
    doc: Create a file if it doesn't exist.
  - name: open_file
    signature: (self, file_path: str)
    return: Optional[int]
    class: NixlFileManager
    doc: Open a file and return its file descriptor.
  - name: close_file
    signature: (self, fd: int)
    return: bool
    class: NixlFileManager
    doc: Close a file descriptor.
  - name: files_to_nixl_tuples
    signature: (self, file_paths: List[str])
    return: List[Tuple[int, int, int, str]]
    class: NixlFileManager
    doc: Create NIXL tuples (offset, length, fd, file_path) for given files.

File: mem_cache/storage/nixl/test_hicache_nixl_storage.py
  - name: setUp
    signature: (self)
    class: TestNixlUnified
    doc: Set up test environment.
  - name: tearDown
    signature: (self)
    class: TestNixlUnified
    doc: Clean up test directories.
  - name: delete_test_file
    signature: (self, file_path: str)
    return: bool
    class: TestNixlUnified
    doc: Helper method to delete a test file.
  - name: verify_tensors_equal
    signature: (self, expected: torch.Tensor, actual: torch.Tensor)
    class: TestNixlUnified
    doc: Helper to verify tensor equality.
  - name: verify_tensor_lists_equal
    signature: (self, expected: List[torch.Tensor], actual: List[torch.Tensor])
    class: TestNixlUnified
    doc: Helper to verify lists of tensors are equal.
  - name: test_single_set_get
    signature: (self)
    class: TestNixlUnified
    doc: Test single tensor set/get operations.
  - name: test_batch_set_get
    signature: (self)
    class: TestNixlUnified
    doc: Test batch tensor set/get operations.
  - name: test_mixed_operations
    signature: (self)
    class: TestNixlUnified
    doc: Test mixing single and batch operations.
  - name: test_data_integrity
    signature: (self)
    class: TestNixlUnified
    doc: Test data integrity across operations.
  - name: test_basic_file_operations
    signature: (self)
    class: TestNixlUnified
    doc: Test basic file operations.
  - name: test_create_nixl_tuples
    signature: (self)
    class: TestNixlUnified
    doc: Test creation of NIXL tuples.
  - name: test_error_handling
    signature: (self)
    class: TestNixlUnified
    doc: Test error handling in file operations.
  - name: test_register_buffers
    signature: (self)
    class: TestNixlUnified
    doc: Test registration of memory buffers.
  - name: test_register_files_with_tuples
    signature: (self)
    class: TestNixlUnified
    doc: Test registration of files using NIXL tuples.

File: mem_cache/swa_radix_cache.py
  - name: __init__
    signature: (self, id: Optional[int] = None)
    class: TreeNode
  - name: evicted
    signature: (self)
    class: TreeNode
  - name: backuped
    signature: (self)
    class: TreeNode
  - name: __lt__
    signature: (self, other: 'TreeNode')
    class: TreeNode
  - name: _key_match_page_size1
    signature: (key0: List, key1: List)
  - name: _key_match_paged
    signature: (key0: List, key1: List, page_size: int)
  - name: gen_swa_uuid
    signature: ()
    return: int
  - name: __init__
    signature: (self, swa: bool = False)
    class: LRUList
  - name: _add_node
    signature: (self, node)
    class: LRUList
    doc: Helper to add node right after head (most recently used)
  - name: _add_node_after
    signature: (self, old_node, new_node)
    class: LRUList
    doc: Helper to add node right after old_node
  - name: _remove_node
    signature: (self, node)
    class: LRUList
    doc: Helper to remove node from linked list
  - name: _get_lru
    signature: (self)
    return: Optional[TreeNode]
    class: LRUList
    doc: Get the least recently used node
  - name: reset_node_mru
    signature: (self, node)
    class: LRUList
    doc: Move a (existing) node to most recently used position
  - name: reset_node_and_parents_mru
    signature: (self, node, root_node)
    class: LRUList
    doc: Move an (existing) node and its parents to most recently used position. Child node is
  - name: insert_mru
    signature: (self, node)
    class: LRUList
    doc: Insert a (new) node as most recently used
  - name: remove_node
    signature: (self, node: TreeNode)
    class: LRUList
    doc: Remove node from lru list
  - name: get_lru_no_lock
    signature: (self)
    return: Optional[TreeNode]
    class: LRUList
    doc: Get the least recently used node that is not locked
  - name: get_leaf_lru_no_lock
    signature: (self)
    return: Optional[TreeNode]
    class: LRUList
    doc: Get the least recently used leaf node that is not locked
  - name: get_prev_no_lock
    signature: (self, node: TreeNode, check_id: bool = True)
    return: Optional[TreeNode]
    class: LRUList
    doc: Get the previous (i.e. more recently used) node that is not locked
  - name: get_prev_leaf_no_lock
    signature: (self, node: TreeNode, check_id: bool = True)
    class: LRUList
    doc: Get the previous (i.e. more recently used) leaf node that is not locked
  - name: in_list
    signature: (self, node: Optional[TreeNode])
    class: LRUList
    doc: Check if the node is in the lru list
  - name: sanity_check_evictable_size
    signature: (self)
    class: LRUList
    doc: Check the evictable size (i.e. the size of the nodes that are not locked)
  - name: sanity_check
    signature: (self, tree_cache: 'SWARadixCache')
    class: LRUList
    doc: Check if the lru list is valid by rebuilding the lru list from the tree, heapifying it, and
  - name: __init__
    signature: (self, req_to_token_pool: ReqToTokenPool, token_to_kv_pool_allocator: SWATokenToKVPoolAllocator, sliding_window_size: int, page_size: int, disable: bool = False)
    class: SWARadixCache
  - name: reset
    signature: (self)
    return: None
    class: SWARadixCache
  - name: match_prefix
    signature: (self, key: List[int], **kwargs)
    return: MatchResult
    class: SWARadixCache
    doc: Find the matching prefix from the radix tree.
  - name: insert
    signature: (self, key: List, value = None, prev_prefix_len: int = 0)
    return: int
    class: SWARadixCache
  - name: cache_finished_req
    signature: (self, req: Req)
    return: None
    class: SWARadixCache
    doc: Cache request when it finishes.
  - name: cache_unfinished_req
    signature: (self, req: Req, chunked = False)
    return: None
    class: SWARadixCache
    doc: Cache request when it is unfinished.
  - name: pretty_print
    signature: (self)
    return: None
    class: SWARadixCache
  - name: total_size
    signature: (self)
    return: Tuple[int, int]
    class: SWARadixCache
  - name: evict
    signature: (self, full_num_tokens: int, swa_num_tokens: int = 0)
    return: None
    class: SWARadixCache
  - name: inc_lock_ref
    signature: (self, node: TreeNode)
    return: Optional[int]
    class: SWARadixCache
    doc: Increment the lock reference count for the node. Returns the swa_uuid_for_lock, which needs
  - name: dec_lock_ref
    signature: (self, node: TreeNode, swa_uuid_for_lock: Optional[int] = None)
    class: SWARadixCache
    doc: Decrement the lock reference count for the node.
  - name: sanity_check
    signature: (self)
    class: SWARadixCache
  - name: evictable_size
    signature: (self)
    return: Tuple[int, int]
    class: SWARadixCache
  - name: full_evictable_size
    signature: (self)
    return: int
    class: SWARadixCache
  - name: swa_evictable_size
    signature: (self)
    return: int
    class: SWARadixCache
  - name: full_lru_list_evictable_size
    signature: (self)
    return: int
    class: SWARadixCache
  - name: swa_lru_list_evictable_size
    signature: (self)
    return: int
    class: SWARadixCache
  - name: protected_size
    signature: (self)
    return: Tuple[int, int]
    class: SWARadixCache
  - name: full_protected_size
    signature: (self)
    return: int
    class: SWARadixCache
  - name: swa_protected_size
    signature: (self)
    return: int
    class: SWARadixCache
  - name: all_values_flatten
    signature: (self)
    return: torch.Tensor
    class: SWARadixCache
  - name: _dfs_helper
    signature: (node: TreeNode)
    class: SWARadixCache
  - name: _match_prefix_helper
    signature: (self, key: List)
    return: Tuple[List[torch.Tensor], TreeNode]
    class: SWARadixCache
    doc: SWA prefix matching helper. It factors in the sliding window size such that
  - name: _split_node
    signature: (self, key: List[int], child: TreeNode, split_len: int)
    return: TreeNode
    class: SWARadixCache
  - name: _insert_helper
    signature: (self, node: TreeNode, key: List, value, update_kv_after_len: int)
    return: int
    class: SWARadixCache
  - name: _iteratively_delete_tombstone_leaf
    signature: (self, node: TreeNode)
    return: Tuple[TreeNode, int]
    class: SWARadixCache
  - name: _delete_leaf
    signature: (self, node: TreeNode)
    return: None
    class: SWARadixCache
  - name: _tombstone_internal_node
    signature: (self, node: TreeNode)
    return: None
    class: SWARadixCache
  - name: _delete_tombstone_leaf
    signature: (self, node: TreeNode)
    return: None
    class: SWARadixCache
  - name: _collect_leaves
    signature: (self)
    return: List[TreeNode]
    class: SWARadixCache
  - name: _collect_nontombstone_nodes
    signature: (self)
    return: List[TreeNode]
    class: SWARadixCache
  - name: _collect_all_nodes
    signature: (self)
    return: List[TreeNode]
    class: SWARadixCache
  - name: _print_helper
    signature: (self, node: TreeNode, indent: int)
    return: None
    class: SWARadixCache
    doc: Prints the radix tree in a human-readable format.
  - name: _total_size_helper
    signature: (self)
    return: Tuple[int, int]
    class: SWARadixCache
