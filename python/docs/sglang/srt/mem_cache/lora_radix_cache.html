<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.mem_cache.lora_radix_cache API documentation</title>
<meta name="description" content="Radix cache for LoRA. It&#39;s modified based on RadixCache with lora_id added to the key of nodes.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.mem_cache.lora_radix_cache</code></h1>
</header>
<section id="section-intro">
<p>Radix cache for LoRA. It's modified based on RadixCache with lora_id added to the key of nodes.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sglang.srt.mem_cache.lora_radix_cache.get_child_key"><code class="name flex">
<span>def <span class="ident">get_child_key</span></span>(<span>key: <a title="sglang.srt.mem_cache.lora_radix_cache.LoRAKey" href="#sglang.srt.mem_cache.lora_radix_cache.LoRAKey">LoRAKey</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_child_key(key: LoRAKey):
    # Here the key of children dict is the hash of lora_id + str(token_ids[0])
    # So the child key can be matched only when lora_id and token_ids[0] are the same
    if key.lora_id is None:
        return hash(str(key.token_ids[0]))
    else:
        return hash(key.lora_id + str(key.token_ids[0]))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRAKey"><code class="flex name class">
<span>class <span class="ident">LoRAKey</span></span>
<span>(</span><span>lora_id: str, token_ids: List[int])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoRAKey:

    def __init__(self, lora_id: str, token_ids: List[int]):
        self.lora_id = (
            lora_id  # lora_id of adaptor, should be hash value of adaptor path
        )
        self.token_ids = token_ids  # token_ids of the key

    def __len__(self):
        return len(self.token_ids)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache"><code class="flex name class">
<span>class <span class="ident">LoRARadixCache</span></span>
<span>(</span><span>req_to_token_pool: <a title="sglang.srt.mem_cache.memory_pool.ReqToTokenPool" href="memory_pool.html#sglang.srt.mem_cache.memory_pool.ReqToTokenPool">ReqToTokenPool</a>,<br>token_to_kv_pool_allocator: <a title="sglang.srt.mem_cache.allocator.BaseTokenToKVPoolAllocator" href="allocator.html#sglang.srt.mem_cache.allocator.BaseTokenToKVPoolAllocator">BaseTokenToKVPoolAllocator</a>,<br>page_size: int,<br>disable: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoRARadixCache(BasePrefixCache):

    def __init__(
        self,
        req_to_token_pool: ReqToTokenPool,
        token_to_kv_pool_allocator: BaseTokenToKVPoolAllocator,
        page_size: int,
        disable: bool = False,
    ):
        if page_size &gt; 1:
            raise ValueError(&#34;LoRARadixCache currently only supports page_size = 1&#34;)

        if token_to_kv_pool_allocator is None:
            raise ValueError(
                &#34;token_to_kv_pool_allocator is required to run LoraRadixCache&#34;
            )

        self.req_to_token_pool = req_to_token_pool
        self.token_to_kv_pool_allocator = token_to_kv_pool_allocator
        self.page_size = page_size
        self.disable = disable
        self.device = self.token_to_kv_pool_allocator.device

        self.key_match_fn = _key_match
        self.get_child_key_fn = get_child_key
        self.reset()

    def reset(self):
        self.root_node = LoRATreeNode()
        self.root_node.key = LoRAKey(lora_id=&#34;&#34;, token_ids=[])
        self.root_node.value = None
        self.evictable_size_ = 0
        self.protected_size_ = 0

    def match_prefix(self, key: List[int], **kwargs) -&gt; MatchResult:
        raise ValueError(
            &#34;LoRARadixCache needs both token ids and lora id as inputs for matching. Please use match_prefix_with_lora_id instead.&#34;
        )

    def match_prefix_with_lora_id(self, key: LoRAKey, **kwargs) -&gt; MatchResult:
        &#34;&#34;&#34;Find the matching prefix from the lora radix tree.
        Args:
            key: A LoRAKey to find a matching prefix.
        Returns:
            A tuple of a tensor of matching prefix token IDs and
            the last node that contains the prefix values. Note that
            this API can modify the internal state of the Radix tree.
            The last node create a new child if the prefix is shorter
            than the last node&#39;s value.
        &#34;&#34;&#34;
        if self.disable or len(key) == 0:
            return MatchResult(
                device_indices=torch.empty(
                    (0,),
                    dtype=torch.int64,
                    device=self.device,
                ),
                last_device_node=self.root_node,
                last_host_node=self.root_node,
            )

        value, last_node = self._match_prefix_helper(self.root_node, key)
        if value:
            value = torch.cat(value)
        else:
            value = torch.empty((0,), dtype=torch.int64, device=self.device)
        return MatchResult(
            device_indices=value,
            last_device_node=last_node,
            last_host_node=last_node,
        )

    def insert(self, key: LoRAKey, value=None):
        if self.disable:
            return 0

        if value is None:
            value = [x for x in key.token_ids]
        return self._insert_helper(self.root_node, key, value)

    def cache_finished_req(self, req: Req):
        &#34;&#34;&#34;Cache request when it finishes.&#34;&#34;&#34;
        if self.disable:
            kv_indices = self.req_to_token_pool.req_to_token[
                req.req_pool_idx, : len(req.origin_input_ids) + len(req.output_ids) - 1
            ]
            self.token_to_kv_pool_allocator.free(kv_indices)
            self.req_to_token_pool.free(req.req_pool_idx)
            return

        token_ids = (req.origin_input_ids + req.output_ids)[:-1]
        kv_indices = self.req_to_token_pool.req_to_token[
            req.req_pool_idx, : len(token_ids)
        ]

        page_aligned_len = len(kv_indices)
        page_aligned_kv_indices = kv_indices.to(dtype=torch.int64, copy=True)

        # Radix Cache takes one ref in memory pool
        lora_key = LoRAKey(lora_id=req.lora_id, token_ids=token_ids[:page_aligned_len])
        new_prefix_len = self.insert(lora_key, page_aligned_kv_indices)
        self.token_to_kv_pool_allocator.free(
            kv_indices[len(req.prefix_indices) : new_prefix_len]
        )

        # Remove req slot release the cache lock
        self.req_to_token_pool.free(req.req_pool_idx)
        self.dec_lock_ref(req.last_node)

    def cache_unfinished_req(self, req: Req, chunked=False):
        &#34;&#34;&#34;Cache request when it is unfinished.&#34;&#34;&#34;
        if self.disable:
            return

        token_ids = req.fill_ids
        kv_indices = self.req_to_token_pool.req_to_token[
            req.req_pool_idx, : len(token_ids)
        ]

        page_aligned_len = len(kv_indices)
        page_aligned_kv_indices = kv_indices.to(dtype=torch.int64, copy=True)
        page_aligned_token_ids = token_ids[:page_aligned_len]

        # Radix Cache takes one ref in memory pool
        inserted_key = LoRAKey(lora_id=req.lora_id, token_ids=page_aligned_token_ids)
        new_prefix_len = self.insert(inserted_key, page_aligned_kv_indices)
        self.token_to_kv_pool_allocator.free(
            kv_indices[len(req.prefix_indices) : new_prefix_len]
        )

        # The prefix indices could be updated, reuse it
        new_indices, new_last_node, _, _ = self.match_prefix_with_lora_id(inserted_key)
        self.req_to_token_pool.write(
            (req.req_pool_idx, slice(len(req.prefix_indices), len(new_indices))),
            new_indices[len(req.prefix_indices) :],
        )

        self.dec_lock_ref(req.last_node)
        self.inc_lock_ref(new_last_node)

        # `req.prefix_indices` will be used in `PrefillAdder::add_chunked_req` later
        req.prefix_indices = new_indices
        req.last_node = new_last_node

    def pretty_print(self):
        self._print_helper(self.root_node, 0)
        print(f&#34;#tokens: {self.total_size()}&#34;)

    def total_size(self):
        return self._total_size_helper()

    def evict(self, num_tokens: int):
        if self.disable:
            return

        leaves = self._collect_leaves()
        heapq.heapify(leaves)

        num_evicted = 0
        while num_evicted &lt; num_tokens and len(leaves):
            x = heapq.heappop(leaves)

            if x == self.root_node:
                break
            if x.lock_ref &gt; 0:
                continue

            self.token_to_kv_pool_allocator.free(x.value)
            num_evicted += len(x.value)
            self._delete_leaf(x)

            if len(x.parent.children) == 0:
                heapq.heappush(leaves, x.parent)

    def inc_lock_ref(self, node: LoRATreeNode):
        if self.disable:
            return 0

        delta = 0
        while node != self.root_node:
            if node.lock_ref == 0:
                self.evictable_size_ -= len(node.value)
                self.protected_size_ += len(node.value)
                delta -= len(node.value)
            node.lock_ref += 1
            node = node.parent
        return delta

    def dec_lock_ref(self, node: LoRATreeNode):
        if self.disable:
            return 0

        delta = 0
        while node != self.root_node:
            if node.lock_ref == 1:
                self.evictable_size_ += len(node.value)
                self.protected_size_ -= len(node.value)
                delta += len(node.value)
            node.lock_ref -= 1
            node = node.parent
        return delta

    def evictable_size(self):
        return self.evictable_size_

    def protected_size(self):
        # protected size refers to the size of the cache that is locked
        return self.protected_size_

    def all_values_flatten(self):
        values = []

        def _dfs_helper(node: LoRATreeNode):
            for _, child in node.children.items():
                values.append(child.value)
                _dfs_helper(child)

        _dfs_helper(self.root_node)
        return torch.cat(values)

    ##### Internal Helper Functions #####

    def _match_prefix_helper(self, node: LoRATreeNode, key: LoRAKey):
        node.last_access_time = time.monotonic()

        child_key = self.get_child_key_fn(key)

        value = []
        while len(key) &gt; 0 and child_key in node.children.keys():
            child = node.children[child_key]
            child.last_access_time = time.monotonic()
            prefix_len = self.key_match_fn(child.key, key)
            if prefix_len &lt; len(child.key):
                new_node = self._split_node(child.key, child, prefix_len)
                value.append(new_node.value)
                node = new_node
                break
            else:
                value.append(child.value)
                node = child
                key = LoRAKey(lora_id=key.lora_id, token_ids=key.token_ids[prefix_len:])

                if len(key):
                    child_key = self.get_child_key_fn(key)

        return value, node

    def _split_node(self, key: LoRAKey, child: LoRATreeNode, split_len: int):
        # new_node -&gt; child
        new_node = LoRATreeNode()
        key_split_1 = LoRAKey(lora_id=key.lora_id, token_ids=key.token_ids[:split_len])
        key_split_2 = LoRAKey(lora_id=key.lora_id, token_ids=key.token_ids[split_len:])
        new_node.children = {self.get_child_key_fn(key_split_2): child}
        new_node.parent = child.parent
        new_node.lock_ref = child.lock_ref
        new_node.key = key_split_1
        new_node.value = child.value[:split_len]
        child.parent = new_node
        child.key = key_split_2
        child.value = child.value[split_len:]
        new_node.parent.children[self.get_child_key_fn(key)] = new_node

        return new_node

    def _insert_helper(self, node: LoRATreeNode, key: LoRAKey, value):
        node.last_access_time = time.monotonic()
        if len(key) == 0:
            return 0

        child_key = self.get_child_key_fn(key)

        total_prefix_length = 0
        while len(key) &gt; 0 and child_key in node.children.keys():
            node = node.children[child_key]
            node.last_access_time = time.monotonic()
            prefix_len = self.key_match_fn(node.key, key)
            total_prefix_length += prefix_len
            key = LoRAKey(lora_id=key.lora_id, token_ids=key.token_ids[prefix_len:])
            value = value[prefix_len:]

            if prefix_len &lt; len(node.key):
                new_node = self._split_node(node.key, node, prefix_len)
                node = new_node

            if len(key):
                child_key = self.get_child_key_fn(key)

        if len(key):
            new_node = LoRATreeNode()
            new_node.parent = node
            new_node.key = key
            new_node.value = value
            node.children[child_key] = new_node
            self.evictable_size_ += len(value)
        return total_prefix_length

    def _print_helper(self, node: LoRATreeNode, indent: int):
        &#34;&#34;&#34;Prints the radix tree in a human-readable format.&#34;&#34;&#34;
        stack = [(node, indent)]
        while stack:
            current_node, current_indent = stack.pop()
            print(
                &#34; &#34; * current_indent,
                len(current_node.key),
                current_node.key.token_ids[:10],
                f&#34;r={current_node.lock_ref}&#34;,
            )
            for key, child in current_node.children.items():
                stack.append((child, current_indent + 2))

                assert key == self.get_child_key_fn(
                    child.key
                ), f&#34;{key=}, {self.get_child_key_fn(child.key)=}&#34;

    def _delete_leaf(self, node):
        for k, v in node.parent.children.items():
            if v == node:
                break
        del node.parent.children[k]
        self.evictable_size_ -= len(node.key)

    def _total_size_helper(self):
        total_size = 0
        stack = [self.root_node]
        while stack:
            current_node = stack.pop()
            total_size += len(current_node.value)
            for child in current_node.children.values():
                if child.evicted:
                    continue
                stack.append(child)
        return total_size

    def _collect_leaves(self):
        ret_list = []
        stack = [self.root_node]

        while stack:
            cur_node = stack.pop()
            if len(cur_node.children) == 0:
                ret_list.append(cur_node)
            else:
                stack.extend(cur_node.children.values())

        return ret_list</code></pre>
</details>
<div class="desc"><p>Cache can be indexed by either rid or key.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache">BasePrefixCache</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.all_values_flatten"><code class="name flex">
<span>def <span class="ident">all_values_flatten</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all_values_flatten(self):
    values = []

    def _dfs_helper(node: LoRATreeNode):
        for _, child in node.children.items():
            values.append(child.value)
            _dfs_helper(child)

    _dfs_helper(self.root_node)
    return torch.cat(values)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.cache_finished_req"><code class="name flex">
<span>def <span class="ident">cache_finished_req</span></span>(<span>self, req: Any)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_finished_req(self, req: Req):
    &#34;&#34;&#34;Cache request when it finishes.&#34;&#34;&#34;
    if self.disable:
        kv_indices = self.req_to_token_pool.req_to_token[
            req.req_pool_idx, : len(req.origin_input_ids) + len(req.output_ids) - 1
        ]
        self.token_to_kv_pool_allocator.free(kv_indices)
        self.req_to_token_pool.free(req.req_pool_idx)
        return

    token_ids = (req.origin_input_ids + req.output_ids)[:-1]
    kv_indices = self.req_to_token_pool.req_to_token[
        req.req_pool_idx, : len(token_ids)
    ]

    page_aligned_len = len(kv_indices)
    page_aligned_kv_indices = kv_indices.to(dtype=torch.int64, copy=True)

    # Radix Cache takes one ref in memory pool
    lora_key = LoRAKey(lora_id=req.lora_id, token_ids=token_ids[:page_aligned_len])
    new_prefix_len = self.insert(lora_key, page_aligned_kv_indices)
    self.token_to_kv_pool_allocator.free(
        kv_indices[len(req.prefix_indices) : new_prefix_len]
    )

    # Remove req slot release the cache lock
    self.req_to_token_pool.free(req.req_pool_idx)
    self.dec_lock_ref(req.last_node)</code></pre>
</details>
<div class="desc"><p>Cache request when it finishes.</p></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.cache_unfinished_req"><code class="name flex">
<span>def <span class="ident">cache_unfinished_req</span></span>(<span>self, req: Any, chunked=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_unfinished_req(self, req: Req, chunked=False):
    &#34;&#34;&#34;Cache request when it is unfinished.&#34;&#34;&#34;
    if self.disable:
        return

    token_ids = req.fill_ids
    kv_indices = self.req_to_token_pool.req_to_token[
        req.req_pool_idx, : len(token_ids)
    ]

    page_aligned_len = len(kv_indices)
    page_aligned_kv_indices = kv_indices.to(dtype=torch.int64, copy=True)
    page_aligned_token_ids = token_ids[:page_aligned_len]

    # Radix Cache takes one ref in memory pool
    inserted_key = LoRAKey(lora_id=req.lora_id, token_ids=page_aligned_token_ids)
    new_prefix_len = self.insert(inserted_key, page_aligned_kv_indices)
    self.token_to_kv_pool_allocator.free(
        kv_indices[len(req.prefix_indices) : new_prefix_len]
    )

    # The prefix indices could be updated, reuse it
    new_indices, new_last_node, _, _ = self.match_prefix_with_lora_id(inserted_key)
    self.req_to_token_pool.write(
        (req.req_pool_idx, slice(len(req.prefix_indices), len(new_indices))),
        new_indices[len(req.prefix_indices) :],
    )

    self.dec_lock_ref(req.last_node)
    self.inc_lock_ref(new_last_node)

    # `req.prefix_indices` will be used in `PrefillAdder::add_chunked_req` later
    req.prefix_indices = new_indices
    req.last_node = new_last_node</code></pre>
</details>
<div class="desc"><p>Cache request when it is unfinished.</p></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.dec_lock_ref"><code class="name flex">
<span>def <span class="ident">dec_lock_ref</span></span>(<span>self,<br>node: <a title="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode" href="#sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode">LoRATreeNode</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dec_lock_ref(self, node: LoRATreeNode):
    if self.disable:
        return 0

    delta = 0
    while node != self.root_node:
        if node.lock_ref == 1:
            self.evictable_size_ += len(node.value)
            self.protected_size_ -= len(node.value)
            delta += len(node.value)
        node.lock_ref -= 1
        node = node.parent
    return delta</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.evict"><code class="name flex">
<span>def <span class="ident">evict</span></span>(<span>self, num_tokens: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evict(self, num_tokens: int):
    if self.disable:
        return

    leaves = self._collect_leaves()
    heapq.heapify(leaves)

    num_evicted = 0
    while num_evicted &lt; num_tokens and len(leaves):
        x = heapq.heappop(leaves)

        if x == self.root_node:
            break
        if x.lock_ref &gt; 0:
            continue

        self.token_to_kv_pool_allocator.free(x.value)
        num_evicted += len(x.value)
        self._delete_leaf(x)

        if len(x.parent.children) == 0:
            heapq.heappush(leaves, x.parent)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.evictable_size"><code class="name flex">
<span>def <span class="ident">evictable_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evictable_size(self):
    return self.evictable_size_</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.inc_lock_ref"><code class="name flex">
<span>def <span class="ident">inc_lock_ref</span></span>(<span>self,<br>node: <a title="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode" href="#sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode">LoRATreeNode</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inc_lock_ref(self, node: LoRATreeNode):
    if self.disable:
        return 0

    delta = 0
    while node != self.root_node:
        if node.lock_ref == 0:
            self.evictable_size_ -= len(node.value)
            self.protected_size_ += len(node.value)
            delta -= len(node.value)
        node.lock_ref += 1
        node = node.parent
    return delta</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self,<br>key: <a title="sglang.srt.mem_cache.lora_radix_cache.LoRAKey" href="#sglang.srt.mem_cache.lora_radix_cache.LoRAKey">LoRAKey</a>,<br>value=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, key: LoRAKey, value=None):
    if self.disable:
        return 0

    if value is None:
        value = [x for x in key.token_ids]
    return self._insert_helper(self.root_node, key, value)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.match_prefix"><code class="name flex">
<span>def <span class="ident">match_prefix</span></span>(<span>self, key: List[int], **kwargs) ‑> <a title="sglang.srt.mem_cache.base_prefix_cache.MatchResult" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.MatchResult">MatchResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_prefix(self, key: List[int], **kwargs) -&gt; MatchResult:
    raise ValueError(
        &#34;LoRARadixCache needs both token ids and lora id as inputs for matching. Please use match_prefix_with_lora_id instead.&#34;
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.match_prefix_with_lora_id"><code class="name flex">
<span>def <span class="ident">match_prefix_with_lora_id</span></span>(<span>self,<br>key: <a title="sglang.srt.mem_cache.lora_radix_cache.LoRAKey" href="#sglang.srt.mem_cache.lora_radix_cache.LoRAKey">LoRAKey</a>,<br>**kwargs) ‑> <a title="sglang.srt.mem_cache.base_prefix_cache.MatchResult" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.MatchResult">MatchResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_prefix_with_lora_id(self, key: LoRAKey, **kwargs) -&gt; MatchResult:
    &#34;&#34;&#34;Find the matching prefix from the lora radix tree.
    Args:
        key: A LoRAKey to find a matching prefix.
    Returns:
        A tuple of a tensor of matching prefix token IDs and
        the last node that contains the prefix values. Note that
        this API can modify the internal state of the Radix tree.
        The last node create a new child if the prefix is shorter
        than the last node&#39;s value.
    &#34;&#34;&#34;
    if self.disable or len(key) == 0:
        return MatchResult(
            device_indices=torch.empty(
                (0,),
                dtype=torch.int64,
                device=self.device,
            ),
            last_device_node=self.root_node,
            last_host_node=self.root_node,
        )

    value, last_node = self._match_prefix_helper(self.root_node, key)
    if value:
        value = torch.cat(value)
    else:
        value = torch.empty((0,), dtype=torch.int64, device=self.device)
    return MatchResult(
        device_indices=value,
        last_device_node=last_node,
        last_host_node=last_node,
    )</code></pre>
</details>
<div class="desc"><p>Find the matching prefix from the lora radix tree.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>A LoRAKey to find a matching prefix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A tuple of a tensor of matching prefix token IDs and
the last node that contains the prefix values. Note that
this API can modify the internal state of the Radix tree.
The last node create a new child if the prefix is shorter
than the last node's value.</p></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.pretty_print"><code class="name flex">
<span>def <span class="ident">pretty_print</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pretty_print(self):
    self._print_helper(self.root_node, 0)
    print(f&#34;#tokens: {self.total_size()}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.protected_size"><code class="name flex">
<span>def <span class="ident">protected_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protected_size(self):
    # protected size refers to the size of the cache that is locked
    return self.protected_size_</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.root_node = LoRATreeNode()
    self.root_node.key = LoRAKey(lora_id=&#34;&#34;, token_ids=[])
    self.root_node.value = None
    self.evictable_size_ = 0
    self.protected_size_ = 0</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.total_size"><code class="name flex">
<span>def <span class="ident">total_size</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def total_size(self):
    return self._total_size_helper()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache">BasePrefixCache</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache.check_hicache_events" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache.check_hicache_events">check_hicache_events</a></code></li>
<li><code><a title="sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache.init_load_back" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache.init_load_back">init_load_back</a></code></li>
<li><code><a title="sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache.ready_to_load_host_cache" href="base_prefix_cache.html#sglang.srt.mem_cache.base_prefix_cache.BasePrefixCache.ready_to_load_host_cache">ready_to_load_host_cache</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode"><code class="flex name class">
<span>class <span class="ident">LoRATreeNode</span></span>
<span>(</span><span>id: int | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoRATreeNode:

    counter = 0

    def __init__(self, id: Optional[int] = None):
        self.children = defaultdict(LoRATreeNode)
        self.parent: LoRATreeNode = None
        self.key: LoRAKey = None
        self.value: Optional[torch.Tensor] = None
        self.lock_ref = 0
        self.last_access_time = time.monotonic()

        self.id = LoRATreeNode.counter if id is None else id
        LoRATreeNode.counter += 1

    @property
    def evicted(self):
        return self.value is None

    def __lt__(self, other: &#34;LoRATreeNode&#34;):
        return self.last_access_time &lt; other.last_access_time</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode.counter"><code class="name">var <span class="ident">counter</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode.evicted"><code class="name">prop <span class="ident">evicted</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def evicted(self):
    return self.value is None</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.mem_cache" href="index.html">sglang.srt.mem_cache</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.get_child_key" href="#sglang.srt.mem_cache.lora_radix_cache.get_child_key">get_child_key</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRAKey" href="#sglang.srt.mem_cache.lora_radix_cache.LoRAKey">LoRAKey</a></code></h4>
</li>
<li>
<h4><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache">LoRARadixCache</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.all_values_flatten" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.all_values_flatten">all_values_flatten</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.cache_finished_req" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.cache_finished_req">cache_finished_req</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.cache_unfinished_req" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.cache_unfinished_req">cache_unfinished_req</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.dec_lock_ref" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.dec_lock_ref">dec_lock_ref</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.evict" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.evict">evict</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.evictable_size" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.evictable_size">evictable_size</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.inc_lock_ref" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.inc_lock_ref">inc_lock_ref</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.insert" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.insert">insert</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.match_prefix" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.match_prefix">match_prefix</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.match_prefix_with_lora_id" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.match_prefix_with_lora_id">match_prefix_with_lora_id</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.pretty_print" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.pretty_print">pretty_print</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.protected_size" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.protected_size">protected_size</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.reset" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.reset">reset</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.total_size" href="#sglang.srt.mem_cache.lora_radix_cache.LoRARadixCache.total_size">total_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode" href="#sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode">LoRATreeNode</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode.counter" href="#sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode.counter">counter</a></code></li>
<li><code><a title="sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode.evicted" href="#sglang.srt.mem_cache.lora_radix_cache.LoRATreeNode.evicted">evicted</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
