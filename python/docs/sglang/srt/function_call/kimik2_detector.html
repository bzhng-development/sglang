<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.function_call.kimik2_detector API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.function_call.kimik2_detector</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.function_call.kimik2_detector.KimiK2Detector"><code class="flex name class">
<span>class <span class="ident">KimiK2Detector</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KimiK2Detector(BaseFormatDetector):
    &#34;&#34;&#34;
    Detector for Kimi K2 model function call format.

    Format Structure:
    ```
    &lt;|tool_calls_section_begin|&gt;
    &lt;|tool_call_begin|&gt;functions.{func_name}:{index}&lt;|tool_call_argument_begin|&gt;{json_args}&lt;|tool_call_end|&gt;
    &lt;|tool_calls_section_end|&gt;
    ```

    Reference: https://huggingface.co/moonshotai/Kimi-K2-Instruct/blob/main/docs/tool_call_guidance.md
    &#34;&#34;&#34;

    def __init__(self):
        super().__init__()

        self.bot_token: str = &#34;&lt;|tool_calls_section_begin|&gt;&#34;
        self.eot_token: str = &#34;&lt;|tool_calls_section_end|&gt;&#34;

        self.tool_call_start_token: str = &#34;&lt;|tool_call_begin|&gt;&#34;
        self.tool_call_end_token: str = &#34;&lt;|tool_call_end|&gt;&#34;

        self.tool_call_regex = re.compile(
            r&#34;&lt;\|tool_call_begin\|&gt;\s*(?P&lt;tool_call_id&gt;[\w\.]+:\d+)\s*&lt;\|tool_call_argument_begin\|&gt;\s*(?P&lt;function_arguments&gt;\{.*?\})\s*&lt;\|tool_call_end\|&gt;&#34;
        )

        self.stream_tool_call_portion_regex = re.compile(
            r&#34;&lt;\|tool_call_begin\|&gt;\s*(?P&lt;tool_call_id&gt;[\w\.]+:\d+)\s*&lt;\|tool_call_argument_begin\|&gt;\s*(?P&lt;function_arguments&gt;\{.*)&#34;
        )

        self._last_arguments = &#34;&#34;

    def has_tool_call(self, text: str) -&gt; bool:
        &#34;&#34;&#34;Check if the text contains a KimiK2 format tool call.&#34;&#34;&#34;
        return self.bot_token in text

    def detect_and_parse(self, text: str, tools: List[Tool]) -&gt; StreamingParseResult:
        &#34;&#34;&#34;
        One-time parsing: Detects and parses tool calls in the provided text.

        :param text: The complete text to parse.
        :param tools: List of available tools.
        :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.
        &#34;&#34;&#34;
        if self.bot_token not in text:
            return StreamingParseResult(normal_text=text, calls=[])
        try:
            # there are two possible captures - between tags, or between a
            # tag and end-of-string so the result of
            # findall is an array of tuples where one is a function call and
            # the other is None
            function_call_tuples = self.tool_call_regex.findall(text)

            logger.debug(&#34;function_call_tuples: %s&#34;, function_call_tuples)

            tool_calls = []
            for match in function_call_tuples:
                function_id, function_args = match
                function_name = function_id.split(&#34;.&#34;)[1].split(&#34;:&#34;)[0]
                function_idx = int(function_id.split(&#34;.&#34;)[1].split(&#34;:&#34;)[1])

                logger.info(f&#34;function_name {function_name}&#34;)

                tool_calls.append(
                    ToolCallItem(
                        tool_index=function_idx,  # Use the call index in the response, not tool position
                        name=function_name,
                        parameters=function_args,
                    )
                )

            content = text[: text.find(self.bot_token)]
            return StreamingParseResult(normal_text=content, calls=tool_calls)

        except Exception as e:
            logger.error(f&#34;Error in detect_and_parse: {e}&#34;)
            # return the normal text if parsing fails
            return StreamingParseResult(normal_text=text)

    def parse_streaming_increment(
        self, new_text: str, tools: List[Tool]
    ) -&gt; StreamingParseResult:
        &#34;&#34;&#34;
        Streaming incremental parsing tool calls for KimiK2 format.
        &#34;&#34;&#34;
        self._buffer += new_text
        current_text = self._buffer

        # Check if we have a tool call (either the start token or individual tool call)
        has_tool_call = (
            self.bot_token in current_text or self.tool_call_start_token in current_text
        )

        if not has_tool_call:
            self._buffer = &#34;&#34;
            for e_token in [self.eot_token, self.tool_call_end_token]:
                if e_token in new_text:
                    new_text = new_text.replace(e_token, &#34;&#34;)
            return StreamingParseResult(normal_text=new_text)

        if not hasattr(self, &#34;_tool_indices&#34;):
            self._tool_indices = self._get_tool_indices(tools)

        calls: list[ToolCallItem] = []
        try:
            match = self.stream_tool_call_portion_regex.search(current_text)
            if match:
                function_id = match.group(&#34;tool_call_id&#34;)
                function_args = match.group(&#34;function_arguments&#34;)

                function_name = function_id.split(&#34;.&#34;)[1].split(&#34;:&#34;)[0]

                # Initialize state if this is the first tool call
                if self.current_tool_id == -1:
                    self.current_tool_id = 0
                    self.prev_tool_call_arr = []
                    self.streamed_args_for_tool = [&#34;&#34;]

                # Ensure we have enough entries in our tracking arrays
                while len(self.prev_tool_call_arr) &lt;= self.current_tool_id:
                    self.prev_tool_call_arr.append({})
                while len(self.streamed_args_for_tool) &lt;= self.current_tool_id:
                    self.streamed_args_for_tool.append(&#34;&#34;)

                if not self.current_tool_name_sent:
                    calls.append(
                        ToolCallItem(
                            tool_index=self.current_tool_id,
                            name=function_name,
                            parameters=&#34;&#34;,
                        )
                    )
                    self.current_tool_name_sent = True
                    # Store the tool call info for serving layer completions endpoint
                    self.prev_tool_call_arr[self.current_tool_id] = {
                        &#34;name&#34;: function_name,
                        &#34;arguments&#34;: {},
                    }
                else:
                    argument_diff = (
                        function_args[len(self._last_arguments) :]
                        if function_args.startswith(self._last_arguments)
                        else function_args
                    )

                    parsed_args_diff = argument_diff.split(&#34;&lt;|tool_call_end|&gt;&#34;, 1)[0]

                    if parsed_args_diff:

                        calls.append(
                            ToolCallItem(
                                tool_index=self.current_tool_id,
                                name=None,
                                parameters=parsed_args_diff,
                            )
                        )
                        self._last_arguments += argument_diff
                        self.streamed_args_for_tool[
                            self.current_tool_id
                        ] += parsed_args_diff

                    parsed_args = function_args.split(&#34;&lt;|tool_call_end|&gt;&#34;, 1)[0]
                    if _is_complete_json(parsed_args):
                        try:
                            parsed_args = json.loads(parsed_args)
                            self.prev_tool_call_arr[self.current_tool_id][
                                &#34;arguments&#34;
                            ] = parsed_args
                        except json.JSONDecodeError:
                            pass

                        # Find the end of the current tool call and remove only that part from buffer
                        tool_call_end_pattern = (
                            r&#34;&lt;\|tool_call_begin\|&gt;.*?&lt;\|tool_call_end\|&gt;&#34;
                        )
                        match = re.search(
                            tool_call_end_pattern, current_text, re.DOTALL
                        )
                        if match:
                            # Remove the completed tool call from buffer, keep any remaining content
                            self._buffer = current_text[match.end() :]
                        else:
                            self._buffer = &#34;&#34;

                        result = StreamingParseResult(normal_text=&#34;&#34;, calls=calls)
                        self.current_tool_id += 1
                        self._last_arguments = &#34;&#34;
                        self.current_tool_name_sent = False
                        return result

            return StreamingParseResult(normal_text=&#34;&#34;, calls=calls)

        except Exception as e:
            logger.error(f&#34;Error in parse_streaming_increment: {e}&#34;)
            return StreamingParseResult(normal_text=current_text)

    def structure_info(self) -&gt; _GetInfoFunc:
        &#34;&#34;&#34;Return function that creates StructureInfo for guided generation.&#34;&#34;&#34;

        def get_info(name: str) -&gt; StructureInfo:
            return StructureInfo(
                begin=f&#34;&lt;|tool_calls_section_begin|&gt;&lt;|tool_call_begin|&gt;functions.{name}:0&lt;|tool_call_argument_begin|&gt;&#34;,
                end=&#34;&lt;|tool_call_end|&gt;&lt;|tool_calls_section_end|&gt;&#34;,
                trigger=&#34;&lt;|tool_calls_section_begin|&gt;&#34;,
            )

        return get_info

    def build_ebnf(self, tools: List[Tool]) -&gt; str:
        &#34;&#34;&#34;
        Build EBNF grammar for KimiK2 tool call format.

        NOTE: The call_rule_fmt uses [0-9]+ for the function index to allow the grammar
        to accept any numeric index (0, 1, 2, etc.) for proper sequential indexing in
        multiple function call scenarios, while still maintaining the correct KimiK2
        format structure for constrained generation.
        &#34;&#34;&#34;
        return EBNFComposer.build_ebnf(
            tools,
            sequence_start_token=self.bot_token,
            sequence_end_token=self.eot_token,
            tool_call_separator=&#34;&#34;,
            call_rule_fmt=&#39;&#34;&lt;|tool_call_begin|&gt;functions.{name}:&#34;[0-9]+&#34;&lt;|tool_call_argument_begin|&gt;&#34;{arguments_rule}&#34;&lt;|tool_call_end|&gt;&#34;&#39;,
            function_format=&#34;json&#34;,
        )</code></pre>
</details>
<div class="desc"><p>Detector for Kimi K2 model function call format.</p>
<p>Format Structure:</p>
<pre><code>&lt;|tool_calls_section_begin|&gt;
&lt;|tool_call_begin|&gt;functions.{func_name}:{index}&lt;|tool_call_argument_begin|&gt;{json_args}&lt;|tool_call_end|&gt;
&lt;|tool_calls_section_end|&gt;
</code></pre>
<p>Reference: <a href="https://huggingface.co/moonshotai/Kimi-K2-Instruct/blob/main/docs/tool_call_guidance.md">https://huggingface.co/moonshotai/Kimi-K2-Instruct/blob/main/docs/tool_call_guidance.md</a></p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.function_call.base_format_detector.BaseFormatDetector" href="base_format_detector.html#sglang.srt.function_call.base_format_detector.BaseFormatDetector">BaseFormatDetector</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.function_call.kimik2_detector.KimiK2Detector.build_ebnf"><code class="name flex">
<span>def <span class="ident">build_ebnf</span></span>(<span>self,<br>tools: List[<a title="sglang.srt.entrypoints.openai.protocol.Tool" href="../entrypoints/openai/protocol.html#sglang.srt.entrypoints.openai.protocol.Tool">Tool</a>]) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_ebnf(self, tools: List[Tool]) -&gt; str:
    &#34;&#34;&#34;
    Build EBNF grammar for KimiK2 tool call format.

    NOTE: The call_rule_fmt uses [0-9]+ for the function index to allow the grammar
    to accept any numeric index (0, 1, 2, etc.) for proper sequential indexing in
    multiple function call scenarios, while still maintaining the correct KimiK2
    format structure for constrained generation.
    &#34;&#34;&#34;
    return EBNFComposer.build_ebnf(
        tools,
        sequence_start_token=self.bot_token,
        sequence_end_token=self.eot_token,
        tool_call_separator=&#34;&#34;,
        call_rule_fmt=&#39;&#34;&lt;|tool_call_begin|&gt;functions.{name}:&#34;[0-9]+&#34;&lt;|tool_call_argument_begin|&gt;&#34;{arguments_rule}&#34;&lt;|tool_call_end|&gt;&#34;&#39;,
        function_format=&#34;json&#34;,
    )</code></pre>
</details>
<div class="desc"><p>Build EBNF grammar for KimiK2 tool call format.</p>
<p>NOTE: The call_rule_fmt uses [0-9]+ for the function index to allow the grammar
to accept any numeric index (0, 1, 2, etc.) for proper sequential indexing in
multiple function call scenarios, while still maintaining the correct KimiK2
format structure for constrained generation.</p></div>
</dd>
<dt id="sglang.srt.function_call.kimik2_detector.KimiK2Detector.detect_and_parse"><code class="name flex">
<span>def <span class="ident">detect_and_parse</span></span>(<span>self,<br>text: str,<br>tools: List[<a title="sglang.srt.entrypoints.openai.protocol.Tool" href="../entrypoints/openai/protocol.html#sglang.srt.entrypoints.openai.protocol.Tool">Tool</a>]) ‑> <a title="sglang.srt.function_call.core_types.StreamingParseResult" href="core_types.html#sglang.srt.function_call.core_types.StreamingParseResult">StreamingParseResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def detect_and_parse(self, text: str, tools: List[Tool]) -&gt; StreamingParseResult:
    &#34;&#34;&#34;
    One-time parsing: Detects and parses tool calls in the provided text.

    :param text: The complete text to parse.
    :param tools: List of available tools.
    :return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.
    &#34;&#34;&#34;
    if self.bot_token not in text:
        return StreamingParseResult(normal_text=text, calls=[])
    try:
        # there are two possible captures - between tags, or between a
        # tag and end-of-string so the result of
        # findall is an array of tuples where one is a function call and
        # the other is None
        function_call_tuples = self.tool_call_regex.findall(text)

        logger.debug(&#34;function_call_tuples: %s&#34;, function_call_tuples)

        tool_calls = []
        for match in function_call_tuples:
            function_id, function_args = match
            function_name = function_id.split(&#34;.&#34;)[1].split(&#34;:&#34;)[0]
            function_idx = int(function_id.split(&#34;.&#34;)[1].split(&#34;:&#34;)[1])

            logger.info(f&#34;function_name {function_name}&#34;)

            tool_calls.append(
                ToolCallItem(
                    tool_index=function_idx,  # Use the call index in the response, not tool position
                    name=function_name,
                    parameters=function_args,
                )
            )

        content = text[: text.find(self.bot_token)]
        return StreamingParseResult(normal_text=content, calls=tool_calls)

    except Exception as e:
        logger.error(f&#34;Error in detect_and_parse: {e}&#34;)
        # return the normal text if parsing fails
        return StreamingParseResult(normal_text=text)</code></pre>
</details>
<div class="desc"><p>One-time parsing: Detects and parses tool calls in the provided text.</p>
<p>:param text: The complete text to parse.
:param tools: List of available tools.
:return: ParseResult indicating success or failure, consumed text, leftover text, and parsed calls.</p></div>
</dd>
<dt id="sglang.srt.function_call.kimik2_detector.KimiK2Detector.has_tool_call"><code class="name flex">
<span>def <span class="ident">has_tool_call</span></span>(<span>self, text: str) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_tool_call(self, text: str) -&gt; bool:
    &#34;&#34;&#34;Check if the text contains a KimiK2 format tool call.&#34;&#34;&#34;
    return self.bot_token in text</code></pre>
</details>
<div class="desc"><p>Check if the text contains a KimiK2 format tool call.</p></div>
</dd>
<dt id="sglang.srt.function_call.kimik2_detector.KimiK2Detector.parse_streaming_increment"><code class="name flex">
<span>def <span class="ident">parse_streaming_increment</span></span>(<span>self,<br>new_text: str,<br>tools: List[<a title="sglang.srt.entrypoints.openai.protocol.Tool" href="../entrypoints/openai/protocol.html#sglang.srt.entrypoints.openai.protocol.Tool">Tool</a>]) ‑> <a title="sglang.srt.function_call.core_types.StreamingParseResult" href="core_types.html#sglang.srt.function_call.core_types.StreamingParseResult">StreamingParseResult</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_streaming_increment(
    self, new_text: str, tools: List[Tool]
) -&gt; StreamingParseResult:
    &#34;&#34;&#34;
    Streaming incremental parsing tool calls for KimiK2 format.
    &#34;&#34;&#34;
    self._buffer += new_text
    current_text = self._buffer

    # Check if we have a tool call (either the start token or individual tool call)
    has_tool_call = (
        self.bot_token in current_text or self.tool_call_start_token in current_text
    )

    if not has_tool_call:
        self._buffer = &#34;&#34;
        for e_token in [self.eot_token, self.tool_call_end_token]:
            if e_token in new_text:
                new_text = new_text.replace(e_token, &#34;&#34;)
        return StreamingParseResult(normal_text=new_text)

    if not hasattr(self, &#34;_tool_indices&#34;):
        self._tool_indices = self._get_tool_indices(tools)

    calls: list[ToolCallItem] = []
    try:
        match = self.stream_tool_call_portion_regex.search(current_text)
        if match:
            function_id = match.group(&#34;tool_call_id&#34;)
            function_args = match.group(&#34;function_arguments&#34;)

            function_name = function_id.split(&#34;.&#34;)[1].split(&#34;:&#34;)[0]

            # Initialize state if this is the first tool call
            if self.current_tool_id == -1:
                self.current_tool_id = 0
                self.prev_tool_call_arr = []
                self.streamed_args_for_tool = [&#34;&#34;]

            # Ensure we have enough entries in our tracking arrays
            while len(self.prev_tool_call_arr) &lt;= self.current_tool_id:
                self.prev_tool_call_arr.append({})
            while len(self.streamed_args_for_tool) &lt;= self.current_tool_id:
                self.streamed_args_for_tool.append(&#34;&#34;)

            if not self.current_tool_name_sent:
                calls.append(
                    ToolCallItem(
                        tool_index=self.current_tool_id,
                        name=function_name,
                        parameters=&#34;&#34;,
                    )
                )
                self.current_tool_name_sent = True
                # Store the tool call info for serving layer completions endpoint
                self.prev_tool_call_arr[self.current_tool_id] = {
                    &#34;name&#34;: function_name,
                    &#34;arguments&#34;: {},
                }
            else:
                argument_diff = (
                    function_args[len(self._last_arguments) :]
                    if function_args.startswith(self._last_arguments)
                    else function_args
                )

                parsed_args_diff = argument_diff.split(&#34;&lt;|tool_call_end|&gt;&#34;, 1)[0]

                if parsed_args_diff:

                    calls.append(
                        ToolCallItem(
                            tool_index=self.current_tool_id,
                            name=None,
                            parameters=parsed_args_diff,
                        )
                    )
                    self._last_arguments += argument_diff
                    self.streamed_args_for_tool[
                        self.current_tool_id
                    ] += parsed_args_diff

                parsed_args = function_args.split(&#34;&lt;|tool_call_end|&gt;&#34;, 1)[0]
                if _is_complete_json(parsed_args):
                    try:
                        parsed_args = json.loads(parsed_args)
                        self.prev_tool_call_arr[self.current_tool_id][
                            &#34;arguments&#34;
                        ] = parsed_args
                    except json.JSONDecodeError:
                        pass

                    # Find the end of the current tool call and remove only that part from buffer
                    tool_call_end_pattern = (
                        r&#34;&lt;\|tool_call_begin\|&gt;.*?&lt;\|tool_call_end\|&gt;&#34;
                    )
                    match = re.search(
                        tool_call_end_pattern, current_text, re.DOTALL
                    )
                    if match:
                        # Remove the completed tool call from buffer, keep any remaining content
                        self._buffer = current_text[match.end() :]
                    else:
                        self._buffer = &#34;&#34;

                    result = StreamingParseResult(normal_text=&#34;&#34;, calls=calls)
                    self.current_tool_id += 1
                    self._last_arguments = &#34;&#34;
                    self.current_tool_name_sent = False
                    return result

        return StreamingParseResult(normal_text=&#34;&#34;, calls=calls)

    except Exception as e:
        logger.error(f&#34;Error in parse_streaming_increment: {e}&#34;)
        return StreamingParseResult(normal_text=current_text)</code></pre>
</details>
<div class="desc"><p>Streaming incremental parsing tool calls for KimiK2 format.</p></div>
</dd>
<dt id="sglang.srt.function_call.kimik2_detector.KimiK2Detector.structure_info"><code class="name flex">
<span>def <span class="ident">structure_info</span></span>(<span>self) ‑> Callable[[str], <a title="sglang.srt.function_call.core_types.StructureInfo" href="core_types.html#sglang.srt.function_call.core_types.StructureInfo">StructureInfo</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structure_info(self) -&gt; _GetInfoFunc:
    &#34;&#34;&#34;Return function that creates StructureInfo for guided generation.&#34;&#34;&#34;

    def get_info(name: str) -&gt; StructureInfo:
        return StructureInfo(
            begin=f&#34;&lt;|tool_calls_section_begin|&gt;&lt;|tool_call_begin|&gt;functions.{name}:0&lt;|tool_call_argument_begin|&gt;&#34;,
            end=&#34;&lt;|tool_call_end|&gt;&lt;|tool_calls_section_end|&gt;&#34;,
            trigger=&#34;&lt;|tool_calls_section_begin|&gt;&#34;,
        )

    return get_info</code></pre>
</details>
<div class="desc"><p>Return function that creates StructureInfo for guided generation.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.function_call.base_format_detector.BaseFormatDetector" href="base_format_detector.html#sglang.srt.function_call.base_format_detector.BaseFormatDetector">BaseFormatDetector</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.function_call.base_format_detector.BaseFormatDetector.supports_structural_tag" href="base_format_detector.html#sglang.srt.function_call.base_format_detector.BaseFormatDetector.supports_structural_tag">supports_structural_tag</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.function_call" href="index.html">sglang.srt.function_call</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.function_call.kimik2_detector.KimiK2Detector" href="#sglang.srt.function_call.kimik2_detector.KimiK2Detector">KimiK2Detector</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.function_call.kimik2_detector.KimiK2Detector.build_ebnf" href="#sglang.srt.function_call.kimik2_detector.KimiK2Detector.build_ebnf">build_ebnf</a></code></li>
<li><code><a title="sglang.srt.function_call.kimik2_detector.KimiK2Detector.detect_and_parse" href="#sglang.srt.function_call.kimik2_detector.KimiK2Detector.detect_and_parse">detect_and_parse</a></code></li>
<li><code><a title="sglang.srt.function_call.kimik2_detector.KimiK2Detector.has_tool_call" href="#sglang.srt.function_call.kimik2_detector.KimiK2Detector.has_tool_call">has_tool_call</a></code></li>
<li><code><a title="sglang.srt.function_call.kimik2_detector.KimiK2Detector.parse_streaming_increment" href="#sglang.srt.function_call.kimik2_detector.KimiK2Detector.parse_streaming_increment">parse_streaming_increment</a></code></li>
<li><code><a title="sglang.srt.function_call.kimik2_detector.KimiK2Detector.structure_info" href="#sglang.srt.function_call.kimik2_detector.KimiK2Detector.structure_info">structure_info</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
