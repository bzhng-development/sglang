<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.disaggregation.prefill API documentation</title>
<meta name="description" content="Life cycle of a request in the prefill server …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.disaggregation.prefill</code></h1>
</header>
<section id="section-intro">
<p>Life cycle of a request in the prefill server</p>
<ol>
<li>
<p>Bootstrap Queue
a. Initialize a sender for each request
b. Use the queue to store requests whose bootstrap (handshake and preallocation) has not finished
c. Poll senders to check bootstrap state
d. Once bootstrap is complete, move request to Waiting Queue</p>
</li>
<li>
<p>Waiting Queue
a. Use PrefillAdder to pop requests
b. Run forward
c. Add the request to Inflight Queue</p>
</li>
<li>
<p>Inflight Queue
a. Poll (non-blocking) the sender of the request
b. Once the transfer has finished, return the request</p>
</li>
</ol>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue"><code class="flex name class">
<span>class <span class="ident">PrefillBootstrapQueue</span></span>
<span>(</span><span>token_to_kv_pool: KVCache,<br>draft_token_to_kv_pool: Optional[KVCache],<br>req_to_metadata_buffer_idx_allocator: ReqToMetadataIdxAllocator,<br>metadata_buffers: MetadataBuffers,<br>tp_rank: int,<br>tp_size: int,<br>gpu_id: int,<br>bootstrap_port: int,<br>gloo_group: ProcessGroup,<br>max_total_num_tokens: int,<br>decode_tp_size: int,<br>decode_dp_size: int,<br>scheduler: Scheduler,<br>pp_rank: int,<br>pp_size: int,<br>transfer_backend: TransferBackend)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PrefillBootstrapQueue:
    &#34;&#34;&#34;
    Store the requests in bootstrapping
    &#34;&#34;&#34;

    def __init__(
        self,
        token_to_kv_pool: KVCache,
        draft_token_to_kv_pool: Optional[KVCache],
        req_to_metadata_buffer_idx_allocator: ReqToMetadataIdxAllocator,
        metadata_buffers: MetadataBuffers,
        tp_rank: int,
        tp_size: int,
        gpu_id: int,
        bootstrap_port: int,
        gloo_group: ProcessGroup,
        max_total_num_tokens: int,
        decode_tp_size: int,
        decode_dp_size: int,
        scheduler: Scheduler,
        pp_rank: int,
        pp_size: int,
        transfer_backend: TransferBackend,
    ):
        self.token_to_kv_pool = token_to_kv_pool
        self.draft_token_to_kv_pool = draft_token_to_kv_pool
        self.is_mla_backend = is_mla_backend(token_to_kv_pool)
        self.metadata_buffers = metadata_buffers
        self.req_to_metadata_buffer_idx_allocator = req_to_metadata_buffer_idx_allocator
        self.tp_rank = tp_rank
        self.tp_size = tp_size
        self.decode_tp_size = decode_tp_size
        self.decode_dp_size = decode_dp_size
        self.pp_rank = pp_rank
        self.pp_size = pp_size
        self.gpu_id = gpu_id
        self.bootstrap_port = bootstrap_port
        self.queue: List[Req] = []
        self.gloo_group = gloo_group
        self.max_total_num_tokens = max_total_num_tokens
        self.scheduler = scheduler
        self.transfer_backend = transfer_backend
        self.kv_manager = self._init_kv_manager()

    def _init_kv_manager(self) -&gt; BaseKVManager:
        kv_args_class = get_kv_class(self.transfer_backend, KVClassType.KVARGS)
        kv_args = kv_args_class()
        kv_args.engine_rank = self.tp_rank
        kv_args.pp_rank = self.pp_rank
        kv_args.system_dp_rank = self.scheduler.dp_rank
        kv_args.decode_tp_size = self.decode_tp_size // self.decode_dp_size
        kv_args.prefill_pp_size = self.pp_size
        kv_args.prefill_start_layer = self.token_to_kv_pool.start_layer
        kv_data_ptrs, kv_data_lens, kv_item_lens = (
            self.token_to_kv_pool.get_contiguous_buf_infos()
        )

        if self.draft_token_to_kv_pool is not None:
            # We should also transfer draft model kv cache. The indices are
            # always shared with a target model.
            draft_kv_data_ptrs, draft_kv_data_lens, draft_kv_item_lens = (
                self.draft_token_to_kv_pool.get_contiguous_buf_infos()
            )
            kv_data_ptrs += draft_kv_data_ptrs
            kv_data_lens += draft_kv_data_lens
            kv_item_lens += draft_kv_item_lens

        kv_args.kv_data_ptrs = kv_data_ptrs
        kv_args.kv_data_lens = kv_data_lens
        kv_args.kv_item_lens = kv_item_lens
        if not self.is_mla_backend:
            kv_args.kv_head_num = self.token_to_kv_pool.head_num
        kv_args.page_size = self.token_to_kv_pool.page_size

        kv_args.aux_data_ptrs, kv_args.aux_data_lens, kv_args.aux_item_lens = (
            self.metadata_buffers.get_buf_infos()
        )
        kv_args.ib_device = self.scheduler.server_args.disaggregation_ib_device
        kv_args.gpu_id = self.scheduler.gpu_id

        kv_manager_class = get_kv_class(self.transfer_backend, KVClassType.MANAGER)
        kv_manager = kv_manager_class(
            kv_args,
            DisaggregationMode.PREFILL,
            self.scheduler.server_args,
            self.is_mla_backend,
        )
        return kv_manager

    def add(self, req: Req, num_kv_heads: int) -&gt; None:
        if self._check_if_req_exceed_kv_capacity(req):
            return

        if req.bootstrap_host == FAKE_BOOTSTRAP_HOST:
            kv_sender_class = get_kv_class(TransferBackend.FAKE, KVClassType.SENDER)
        else:
            kv_sender_class = get_kv_class(self.transfer_backend, KVClassType.SENDER)

        dest_tp_ranks = [self.tp_rank]

        req.disagg_kv_sender = kv_sender_class(
            mgr=self.kv_manager,
            bootstrap_addr=f&#34;{req.bootstrap_host}:{self.bootstrap_port}&#34;,
            bootstrap_room=req.bootstrap_room,
            dest_tp_ranks=dest_tp_ranks,
            pp_rank=self.pp_rank,
        )
        self._process_req(req)
        self.queue.append(req)

    def extend(self, reqs: List[Req], num_kv_heads: int) -&gt; None:
        for req in reqs:
            self.add(req, num_kv_heads)

    def _check_if_req_exceed_kv_capacity(self, req: Req) -&gt; bool:
        if len(req.origin_input_ids) &gt; self.max_total_num_tokens:
            message = f&#34;Request {req.rid} exceeds the maximum number of tokens: {len(req.origin_input_ids)} &gt; {self.max_total_num_tokens}&#34;
            logger.error(message)
            prepare_abort(req, message, status_code=HTTPStatus.BAD_REQUEST)
            self.scheduler.stream_output([req], req.return_logprob)
            return True
        return False

    def _process_req(self, req: Req) -&gt; None:
        &#34;&#34;&#34;
        Set max_new_tokens = 1, so PrefillAdder memory estimation is accurate
        &#34;&#34;&#34;
        req.sampling_params.max_new_tokens = 1

    def pop_bootstrapped(
        self,
        return_failed_reqs: bool = False,
        rids_to_check: Optional[List[str]] = None,
    ) -&gt; List[Req]:
        &#34;&#34;&#34;
        pop the reqs which has finished bootstrapping

        return_failed_reqs: For PP, on rank 0, also return the failed reqs to notify the next rank
        rids_to_check: For PP, on rank &gt; 0, check the rids from the previous rank has consensus with the current rank.
        &#34;&#34;&#34;

        bootstrapped_reqs = []
        failed_reqs = []
        indices_to_remove = set()

        if len(self.queue) == 0:
            if return_failed_reqs is False:
                return []
            else:
                return [], []

        polls = poll_and_all_reduce(
            [req.disagg_kv_sender for req in self.queue], self.gloo_group
        )

        for i, (req, poll) in enumerate(zip(self.queue, polls)):
            if rids_to_check is not None:
                # if req not in reqs_info_to_check, skip
                if req.rid not in rids_to_check:
                    continue
                # Either waiting for input or failed
                assert poll == KVPoll.WaitingForInput or poll == KVPoll.Failed

            if poll == KVPoll.Bootstrapping:
                continue
            elif poll == KVPoll.Failed:
                error_message = f&#34;Prefill bootstrap failed for request rank={self.tp_rank} {req.rid=} {req.bootstrap_room=}&#34;
                try:
                    req.disagg_kv_sender.failure_exception()
                except Exception as e:
                    error_message += f&#34; with exception {e}&#34;
                logger.error(error_message)
                prepare_abort(
                    req, error_message, status_code=HTTPStatus.INTERNAL_SERVER_ERROR
                )
                self.scheduler.stream_output([req], req.return_logprob)
                indices_to_remove.add(i)
                failed_reqs.append(req)
                if self.scheduler.enable_metrics:
                    self.scheduler.metrics_collector.increment_bootstrap_failed_reqs()
                continue

            # KV.WaitingForInput - init here
            num_kv_indices = len(req.origin_input_ids)
            if self.req_to_metadata_buffer_idx_allocator.available_size() == 0:
                break

            req.metadata_buffer_index = (
                self.req_to_metadata_buffer_idx_allocator.alloc()
            )
            assert req.metadata_buffer_index is not None

            num_pages = kv_to_page_num(num_kv_indices, self.token_to_kv_pool.page_size)
            req.disagg_kv_sender.init(num_pages, req.metadata_buffer_index)
            bootstrapped_reqs.append(req)
            indices_to_remove.add(i)

        self.queue = [
            entry for i, entry in enumerate(self.queue) if i not in indices_to_remove
        ]

        if return_failed_reqs is False:
            return bootstrapped_reqs
        else:
            return bootstrapped_reqs, failed_reqs</code></pre>
</details>
<div class="desc"><p>Store the requests in bootstrapping</p></div>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, req: Req, num_kv_heads: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, req: Req, num_kv_heads: int) -&gt; None:
    if self._check_if_req_exceed_kv_capacity(req):
        return

    if req.bootstrap_host == FAKE_BOOTSTRAP_HOST:
        kv_sender_class = get_kv_class(TransferBackend.FAKE, KVClassType.SENDER)
    else:
        kv_sender_class = get_kv_class(self.transfer_backend, KVClassType.SENDER)

    dest_tp_ranks = [self.tp_rank]

    req.disagg_kv_sender = kv_sender_class(
        mgr=self.kv_manager,
        bootstrap_addr=f&#34;{req.bootstrap_host}:{self.bootstrap_port}&#34;,
        bootstrap_room=req.bootstrap_room,
        dest_tp_ranks=dest_tp_ranks,
        pp_rank=self.pp_rank,
    )
    self._process_req(req)
    self.queue.append(req)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.extend"><code class="name flex">
<span>def <span class="ident">extend</span></span>(<span>self, reqs: List[Req], num_kv_heads: int) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend(self, reqs: List[Req], num_kv_heads: int) -&gt; None:
    for req in reqs:
        self.add(req, num_kv_heads)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.pop_bootstrapped"><code class="name flex">
<span>def <span class="ident">pop_bootstrapped</span></span>(<span>self,<br>return_failed_reqs: bool = False,<br>rids_to_check: Optional[List[str]] = None) ‑> List[<a title="sglang.srt.managers.schedule_batch.Req" href="../managers/schedule_batch.html#sglang.srt.managers.schedule_batch.Req">Req</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_bootstrapped(
    self,
    return_failed_reqs: bool = False,
    rids_to_check: Optional[List[str]] = None,
) -&gt; List[Req]:
    &#34;&#34;&#34;
    pop the reqs which has finished bootstrapping

    return_failed_reqs: For PP, on rank 0, also return the failed reqs to notify the next rank
    rids_to_check: For PP, on rank &gt; 0, check the rids from the previous rank has consensus with the current rank.
    &#34;&#34;&#34;

    bootstrapped_reqs = []
    failed_reqs = []
    indices_to_remove = set()

    if len(self.queue) == 0:
        if return_failed_reqs is False:
            return []
        else:
            return [], []

    polls = poll_and_all_reduce(
        [req.disagg_kv_sender for req in self.queue], self.gloo_group
    )

    for i, (req, poll) in enumerate(zip(self.queue, polls)):
        if rids_to_check is not None:
            # if req not in reqs_info_to_check, skip
            if req.rid not in rids_to_check:
                continue
            # Either waiting for input or failed
            assert poll == KVPoll.WaitingForInput or poll == KVPoll.Failed

        if poll == KVPoll.Bootstrapping:
            continue
        elif poll == KVPoll.Failed:
            error_message = f&#34;Prefill bootstrap failed for request rank={self.tp_rank} {req.rid=} {req.bootstrap_room=}&#34;
            try:
                req.disagg_kv_sender.failure_exception()
            except Exception as e:
                error_message += f&#34; with exception {e}&#34;
            logger.error(error_message)
            prepare_abort(
                req, error_message, status_code=HTTPStatus.INTERNAL_SERVER_ERROR
            )
            self.scheduler.stream_output([req], req.return_logprob)
            indices_to_remove.add(i)
            failed_reqs.append(req)
            if self.scheduler.enable_metrics:
                self.scheduler.metrics_collector.increment_bootstrap_failed_reqs()
            continue

        # KV.WaitingForInput - init here
        num_kv_indices = len(req.origin_input_ids)
        if self.req_to_metadata_buffer_idx_allocator.available_size() == 0:
            break

        req.metadata_buffer_index = (
            self.req_to_metadata_buffer_idx_allocator.alloc()
        )
        assert req.metadata_buffer_index is not None

        num_pages = kv_to_page_num(num_kv_indices, self.token_to_kv_pool.page_size)
        req.disagg_kv_sender.init(num_pages, req.metadata_buffer_index)
        bootstrapped_reqs.append(req)
        indices_to_remove.add(i)

    self.queue = [
        entry for i, entry in enumerate(self.queue) if i not in indices_to_remove
    ]

    if return_failed_reqs is False:
        return bootstrapped_reqs
    else:
        return bootstrapped_reqs, failed_reqs</code></pre>
</details>
<div class="desc"><p>pop the reqs which has finished bootstrapping</p>
<p>return_failed_reqs: For PP, on rank 0, also return the failed reqs to notify the next rank
rids_to_check: For PP, on rank &gt; 0, check the rids from the previous rank has consensus with the current rank.</p></div>
</dd>
</dl>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin"><code class="flex name class">
<span>class <span class="ident">SchedulerDisaggregationPrefillMixin</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchedulerDisaggregationPrefillMixin:
    &#34;&#34;&#34;
    Mixin for Scheduler to handle disaggregation prefill
    &#34;&#34;&#34;

    @torch.no_grad()
    def event_loop_normal_disagg_prefill(self: Scheduler) -&gt; None:
        &#34;&#34;&#34;A normal scheduler loop for prefill worker in disaggregation mode.&#34;&#34;&#34;

        while True:
            recv_reqs = self.recv_requests()
            self.process_input_requests(recv_reqs)
            self.waiting_queue.extend(
                self.disagg_prefill_bootstrap_queue.pop_bootstrapped()
            )
            self.process_prefill_chunk()
            batch = self.get_new_batch_prefill()

            if require_mlp_sync(self.server_args):
                batch = self.prepare_mlp_sync_batch(batch)
            self.cur_batch = batch

            if batch:
                result = self.run_batch(batch)
                self.process_batch_result_disagg_prefill(batch, result)

            if len(self.disagg_prefill_inflight_queue) &gt; 0:
                self.process_disagg_prefill_inflight_queue()

            if batch is None and len(self.disagg_prefill_inflight_queue) == 0:
                self.self_check_during_idle()

            self.last_batch = batch
            # HACK (byronhsu): reset the batch_is_full flag because we never enter update_running_batch which resets it
            # Otherwise, it hangs under high concurrency
            self.running_batch.batch_is_full = False

    @torch.no_grad()
    def event_loop_overlap_disagg_prefill(self: Scheduler) -&gt; None:
        self.result_queue = deque()

        while True:
            recv_reqs = self.recv_requests()
            self.process_input_requests(recv_reqs)
            self.waiting_queue.extend(
                self.disagg_prefill_bootstrap_queue.pop_bootstrapped()
            )
            self.process_prefill_chunk()
            batch = self.get_new_batch_prefill()

            if require_mlp_sync(self.server_args):
                batch = self.prepare_mlp_sync_batch(batch)
            self.cur_batch = batch
            if batch:
                result = self.run_batch(batch)
                self.result_queue.append((batch.copy(), result))

                if self.last_batch is None:
                    # Create a dummy first batch to start the pipeline for overlap schedule.
                    # It is now used for triggering the sampling_info_done event.
                    tmp_batch = ScheduleBatch(
                        reqs=None,
                        forward_mode=ForwardMode.DUMMY_FIRST,
                        next_batch_sampling_info=self.tp_worker.cur_sampling_info,
                    )
                    self.set_next_batch_sampling_info_done(tmp_batch)

            if self.last_batch:
                tmp_batch, tmp_result = self.result_queue.popleft()
                tmp_batch.next_batch_sampling_info = (
                    self.tp_worker.cur_sampling_info if batch else None
                )
                self.process_batch_result_disagg_prefill(tmp_batch, tmp_result)

            if len(self.disagg_prefill_inflight_queue) &gt; 0:
                self.process_disagg_prefill_inflight_queue()

            if batch is None and len(self.disagg_prefill_inflight_queue) == 0:
                self.self_check_during_idle()

            self.last_batch = batch
            # HACK (byronhsu): reset the batch_is_full flag because we never enter update_running_batch which resets it
            # Otherwise, it hangs under high concurrency
            self.running_batch.batch_is_full = False

    def process_batch_result_disagg_prefill(
        self: Scheduler,
        batch: ScheduleBatch,
        result: GenerationBatchResult,
        launch_done: Optional[threading.Event] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Transfer kv for prefill completed requests and add it into disagg_prefill_inflight_queue
        Adapted from process_batch_result_prefill
        &#34;&#34;&#34;
        (
            logits_output,
            next_token_ids,
            extend_input_len_per_req,
            extend_logprob_start_len_per_req,
        ) = (
            result.logits_output,
            result.next_token_ids,
            result.extend_input_len_per_req,
            result.extend_logprob_start_len_per_req,
        )

        logprob_pt = 0
        # Transfer kv for prefill completed requests and add it into disagg_prefill_inflight_queue
        if self.enable_overlap:
            # wait
            logits_output, next_token_ids, _ = self.tp_worker.resolve_last_batch_result(
                launch_done
            )
        else:
            next_token_ids = result.next_token_ids.tolist()
            if batch.return_logprob:
                if logits_output.next_token_logprobs is not None:
                    logits_output.next_token_logprobs = (
                        logits_output.next_token_logprobs.tolist()
                    )
                if logits_output.input_token_logprobs is not None:
                    logits_output.input_token_logprobs = tuple(
                        logits_output.input_token_logprobs.tolist()
                    )

        hidden_state_offset = 0
        for i, (req, next_token_id) in enumerate(
            zip(batch.reqs, next_token_ids, strict=True)
        ):
            req: Req
            if req.is_chunked &lt;= 0:
                # There is no output_ids for prefill
                req.output_ids.append(next_token_id)
                self.tree_cache.cache_unfinished_req(req)  # update the tree and lock
                self.disagg_prefill_inflight_queue.append(req)
                if (
                    logits_output is not None
                    and logits_output.hidden_states is not None
                ):
                    last_hidden_index = (
                        hidden_state_offset + extend_input_len_per_req[i] - 1
                    )
                    req.hidden_states_tensor = (
                        logits_output.hidden_states[last_hidden_index].cpu().clone()
                    )
                    hidden_state_offset += extend_input_len_per_req[i]
                else:
                    req.hidden_states_tensor = None
                if req.return_logprob:
                    assert extend_logprob_start_len_per_req is not None
                    assert extend_input_len_per_req is not None
                    extend_logprob_start_len = extend_logprob_start_len_per_req[i]
                    extend_input_len = extend_input_len_per_req[i]
                    num_input_logprobs = extend_input_len - extend_logprob_start_len
                    self.add_logprob_return_values(
                        i,
                        req,
                        logprob_pt,
                        next_token_ids,
                        num_input_logprobs,
                        logits_output,
                    )
                    logprob_pt += num_input_logprobs
                self.send_kv_chunk(req, last_chunk=True)

                if req.grammar is not None:
                    # FIXME: this try-except block is for handling unexpected xgrammar issue.
                    try:
                        req.grammar.accept_token(next_token_id)
                    except ValueError as e:
                        # Grammar accept_token can raise ValueError if the token is not in the grammar.
                        # This can happen if the grammar is not set correctly or the token is invalid.
                        error_message = f&#34;Grammar accept_token failed for req {req.rid} with token {next_token_id}: {e}&#34;
                        self.tree_cache.cache_finished_req(req)
                        prepare_abort(
                            req,
                            error_message,
                            status_code=HTTPStatus.INTERNAL_SERVER_ERROR,
                        )
                    req.grammar.finished = req.finished()
            else:
                # being chunked reqs&#39; prefill is not finished
                req.is_chunked -= 1

                if req.return_logprob:
                    extend_logprob_start_len = extend_logprob_start_len_per_req[i]
                    extend_input_len = extend_input_len_per_req[i]
                    if extend_logprob_start_len &lt; extend_input_len:
                        # Update input logprobs.
                        num_input_logprobs = extend_input_len - extend_logprob_start_len
                        self.add_input_logprob_return_values(
                            i,
                            req,
                            logits_output,
                            logprob_pt,
                            num_input_logprobs,
                            last_prefill_chunk=False,
                        )
                        logprob_pt += num_input_logprobs

                if self.enable_overlap:
                    self.send_kv_chunk(req, last_chunk=False, end_idx=req.tmp_end_idx)

        # We need to remove the sync in the following function for overlap schedule.
        self.set_next_batch_sampling_info_done(batch)
        self.maybe_send_health_check_signal()

    def process_disagg_prefill_inflight_queue(
        self: Scheduler, rids_to_check: Optional[List[str]] = None
    ) -&gt; List[Req]:
        &#34;&#34;&#34;
        Poll the requests in the middle of transfer. If done, return the request.
        rids_to_check: For PP, on rank &gt; 0, check the rids from the previous rank has consensus with the current rank.
        &#34;&#34;&#34;
        if len(self.disagg_prefill_inflight_queue) == 0:
            return []

        done_reqs = []

        polls = poll_and_all_reduce(
            [req.disagg_kv_sender for req in self.disagg_prefill_inflight_queue],
            self.attn_tp_cpu_group,
        )

        undone_reqs: List[Req] = []
        # Check .poll() for the reqs in disagg_prefill_inflight_queue. If Success, respond to the client and remove it from the queue
        for req, poll in zip(self.disagg_prefill_inflight_queue, polls):

            if rids_to_check is not None:
                if req.rid not in rids_to_check:
                    undone_reqs.append(req)
                    continue

                assert poll == KVPoll.Success or poll == KVPoll.Failed

            if poll in [KVPoll.WaitingForInput, KVPoll.Transferring]:
                undone_reqs.append(req)
            elif poll == KVPoll.Success:  # transfer done
                self.tree_cache.cache_finished_req(req)  # unlock the tree
                req.finished_reason = FINISH_LENGTH(length=0)
                # FIXME: clean up req&#39;s data in transfer engine
                if hasattr(req.disagg_kv_sender, &#34;clear&#34;):
                    req.disagg_kv_sender.clear()
                done_reqs.append(req)
            elif poll == KVPoll.Failed:
                error_message = f&#34;Prefill transfer failed for request rank={self.tp_rank} {req.rid=} {req.bootstrap_room=}&#34;
                try:
                    req.disagg_kv_sender.failure_exception()
                except Exception as e:
                    error_message += f&#34; with exception {e}&#34;
                logger.warning(error_message)
                self.tree_cache.cache_finished_req(req)  # unlock the tree
                prepare_abort(
                    req, error_message, status_code=HTTPStatus.INTERNAL_SERVER_ERROR
                )
                done_reqs.append(req)
                if self.enable_metrics:
                    self.metrics_collector.increment_transfer_failed_reqs()
            else:
                assert False, f&#34;Unexpected polling state {poll=}&#34;

        # Stream requests which have finished transfer
        self.stream_output(
            done_reqs,
            any(req.return_logprob for req in done_reqs),
            None,
        )
        for req in done_reqs:
            req: Req
            self.req_to_metadata_buffer_idx_allocator.free(req.metadata_buffer_index)
            req.metadata_buffer_index = -1

        self.disagg_prefill_inflight_queue = undone_reqs

        return done_reqs

    def get_transferred_rids(self: Scheduler) -&gt; List[str]:
        &#34;&#34;&#34;
        Used by PP, get the transferred rids but **do not pop**
        &#34;&#34;&#34;
        polls = poll_and_all_reduce(
            [req.disagg_kv_sender for req in self.disagg_prefill_inflight_queue],
            self.tp_worker.get_tp_group().cpu_group,
        )

        transferred_rids: List[str] = []

        for req, poll in zip(self.disagg_prefill_inflight_queue, polls):
            if poll == KVPoll.Success or poll == KVPoll.Failed:
                transferred_rids.append(req.rid)

        return transferred_rids

    def process_prefill_chunk(self: Scheduler) -&gt; None:
        if self.last_batch and self.last_batch.forward_mode.is_extend():
            if self.chunked_req:
                # Move the chunked request out of the batch so that we can merge
                # only finished requests to running_batch.
                self.last_batch.filter_batch(chunked_req_to_exclude=self.chunked_req)
                self.tree_cache.cache_unfinished_req(self.chunked_req, chunked=True)
                if self.enable_overlap:
                    # Delay KV transfer to process_batch_result_disagg_prefill when overlap is enabled to ensure results are resolved
                    self.chunked_req.tmp_end_idx = min(
                        len(self.chunked_req.fill_ids),
                        len(self.chunked_req.origin_input_ids),
                    )
                else:
                    self.send_kv_chunk(self.chunked_req)
                # chunked request keeps its rid but will get a new req_pool_idx
                self.req_to_token_pool.free(self.chunked_req.req_pool_idx)
                self.running_batch.batch_is_full = False

    def send_kv_chunk(
        self: Scheduler,
        req: Req,
        last_chunk: bool = False,
        end_idx: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Send a prefilled chunk to the decode server
        &#34;&#34;&#34;
        page_size = self.token_to_kv_pool_allocator.page_size
        start_idx = req.start_send_idx
        end_idx = (
            end_idx
            if end_idx is not None
            else min(len(req.fill_ids), len(req.origin_input_ids))
        )

        if not last_chunk:
            # if not the last chunk and the last page is partial, delay the last partial page to the next send
            end_idx = end_idx - end_idx % page_size

        kv_indices = (
            self.req_to_token_pool.req_to_token[req.req_pool_idx, start_idx:end_idx]
            .cpu()
            .numpy()
        )
        req.start_send_idx = end_idx
        if last_chunk:
            self.disagg_metadata_buffers.set_buf(req)
        page_indices = kv_to_page_indices(kv_indices, page_size)
        if len(page_indices) == 0:
            logger.info(
                f&#34;Skip sending kv chunk for request {req.rid=} {req.bootstrap_room=} because page_indices is empty&#34;
            )
            return
        req.disagg_kv_sender.send(page_indices)

    # PP
    @DynamicGradMode()
    def event_loop_pp_disagg_prefill(self: Scheduler):
        &#34;&#34;&#34;
        An event loop for the prefill server in pipeline parallelism.

        Rules:
        1. Each stage runs in the same order and is notified by the previous stage.
        2. Each send/recv operation is blocking and matched by the neighboring stage.

        Regular Schedule:
        ====================================================================
        Stage i                   | Stage i+1
        send ith req              | recv ith req
        send ith proxy            | recv ith proxy
        send prev (i+1)th carry   | recv prev (i+1)th carry
        ====================================================================

        Prefill Server Schedule:
        ====================================================================
        Stage i                        | Stage i+1
        send ith req                   | recv ith req
        send ith bootstrap req         | recv ith bootstrap req
        send ith transferred req       | recv ith transferred req
        send ith proxy                 | recv ith proxy
        send prev (i+1)th carry        | recv prev (i+1)th carry
        send prev (i+1)th release req  | recv prev (i+1)th release req
        ====================================================================

        There are two additional elements compared to the regular schedule:

        1. Bootstrap Requests:
            a. Instead of polling the status on the current workers, we should wait for the previous stage to notify to avoid desynchronization.
            b. The first stage polls the status and propagates the bootstrapped requests down to all other stages.
            c. If the first stage polls successfully, by nature, other ranks are also successful because they performed a handshake together.

        2. Transferred Requests + Release Requests:
            a. The first stage polls the transfer finished requests, performs an intersection with the next stage&#39;s finished requests, and propagates down to the last stage.
            b. The last stage receives the requests that have finished transfer on all stages (consensus), then sends them to the first stage to release the memory.
            c. The first stage receives the release requests, releases the memory, and then propagates the release requests down to the last stage.
        &#34;&#34;&#34;
        from sglang.srt.managers.scheduler import GenerationBatchResult

        mbs = [None] * self.pp_size
        last_mbs = [None] * self.pp_size
        self.running_mbs = [
            ScheduleBatch(reqs=[], batch_is_full=False) for _ in range(self.pp_size)
        ]
        bids = [None] * self.pp_size
        pp_outputs: Optional[PPProxyTensors] = None

        # Either success or failed
        bootstrapped_rids: List[str] = []
        transferred_rids: List[str] = []
        release_rids: Optional[List[str]] = None

        # transferred microbatch
        tmbs = [None] * self.pp_size

        ENABLE_RELEASE = True  # For debug

        while True:
            server_is_idle = True

            for mb_id in range(self.pp_size):
                self.running_batch = self.running_mbs[mb_id]
                self.last_batch = last_mbs[mb_id]

                recv_reqs = self.recv_requests()

                self.process_input_requests(recv_reqs)

                if self.pp_group.is_first_rank:
                    # First rank, pop the bootstrap reqs from the bootstrap queue
                    bootstrapped_reqs, failed_reqs = (
                        self.disagg_prefill_bootstrap_queue.pop_bootstrapped(
                            return_failed_reqs=True
                        )
                    )
                    bootstrapped_rids = [req.rid for req in bootstrapped_reqs] + [
                        req.rid for req in failed_reqs
                    ]
                    self.waiting_queue.extend(bootstrapped_reqs)
                else:
                    # Other ranks, receive the bootstrap reqs info from the previous rank and ensure the consensus
                    bootstrapped_rids = self.recv_pyobj_from_prev_stage()
                    bootstrapped_reqs = (
                        self.disagg_prefill_bootstrap_queue.pop_bootstrapped(
                            rids_to_check=bootstrapped_rids
                        )
                    )
                    self.waiting_queue.extend(bootstrapped_reqs)

                if self.pp_group.is_first_rank:
                    transferred_rids = self.get_transferred_rids()
                # if other ranks,
                else:
                    # 1. recv previous stage&#39;s transferred reqs info
                    prev_transferred_rids = self.recv_pyobj_from_prev_stage()
                    # 2. get the current stage&#39;s transferred reqs info
                    curr_transferred_rids = self.get_transferred_rids()
                    # 3. new consensus rids = intersection(previous consensus rids, transfer finished rids)
                    transferred_rids = list(
                        set(prev_transferred_rids) &amp; set(curr_transferred_rids)
                    )

                tmbs[mb_id] = transferred_rids

                self.process_prefill_chunk()
                mbs[mb_id] = self.get_new_batch_prefill()
                self.running_mbs[mb_id] = self.running_batch

                self.cur_batch = mbs[mb_id]
                if self.cur_batch:
                    server_is_idle = False
                    result = self.run_batch(self.cur_batch)

                # send the outputs to the next step
                if self.pp_group.is_last_rank:
                    if self.cur_batch:
                        next_token_ids, bids[mb_id] = (
                            result.next_token_ids,
                            result.bid,
                        )
                        pp_outputs = PPProxyTensors(
                            {
                                &#34;next_token_ids&#34;: next_token_ids,
                            }
                        )
                        # send the output from the last round to let the next stage worker run post processing
                        self.pp_group.send_tensor_dict(
                            pp_outputs.tensors,
                            all_gather_group=self.attn_tp_group,
                        )

                if ENABLE_RELEASE:
                    if self.pp_group.is_last_rank:
                        # At the last stage, all stages has reached the consensus to release memory for transferred_rids
                        release_rids = transferred_rids
                        # send to the first rank
                        self.send_pyobj_to_next_stage(release_rids)

                # receive outputs and post-process (filter finished reqs) the coming microbatch
                next_mb_id = (mb_id + 1) % self.pp_size
                next_pp_outputs = None
                next_release_rids = None

                if mbs[next_mb_id] is not None:
                    next_pp_outputs: Optional[PPProxyTensors] = PPProxyTensors(
                        self.pp_group.recv_tensor_dict(
                            all_gather_group=self.attn_tp_group
                        )
                    )
                    mbs[next_mb_id].output_ids = next_pp_outputs[&#34;next_token_ids&#34;]
                    output_result = GenerationBatchResult(
                        logits_output=None,
                        pp_hidden_states_proxy_tensors=None,
                        next_token_ids=next_pp_outputs[&#34;next_token_ids&#34;],
                        extend_input_len_per_req=None,
                        extend_logprob_start_len_per_req=None,
                        bid=bids[next_mb_id],
                        can_run_cuda_graph=result.can_run_cuda_graph,
                    )
                    self.process_batch_result_disagg_prefill(
                        mbs[next_mb_id], output_result
                    )

                    last_mbs[next_mb_id] = mbs[next_mb_id]

                if ENABLE_RELEASE:
                    if tmbs[next_mb_id] is not None:
                        # recv consensus rids from the previous rank
                        next_release_rids = self.recv_pyobj_from_prev_stage()
                        self.process_disagg_prefill_inflight_queue(next_release_rids)

                # carry the outputs to the next stage
                if not self.pp_group.is_last_rank:
                    if self.cur_batch:
                        bids[mb_id] = result.bid
                    if pp_outputs:
                        # send the outputs from the last round to let the next stage worker run post processing
                        self.pp_group.send_tensor_dict(
                            pp_outputs.tensors,
                            all_gather_group=self.attn_tp_group,
                        )
                    if ENABLE_RELEASE:
                        if release_rids is not None:
                            self.send_pyobj_to_next_stage(release_rids)

                if not self.pp_group.is_last_rank:
                    # send out reqs to the next stage
                    self.send_pyobj_to_next_stage(recv_reqs)
                    self.send_pyobj_to_next_stage(bootstrapped_rids)
                    self.send_pyobj_to_next_stage(transferred_rids)

                    # send out proxy tensors to the next stage
                    if self.cur_batch:
                        self.pp_group.send_tensor_dict(
                            result.pp_hidden_states_proxy_tensors,
                            all_gather_group=self.attn_tp_group,
                        )

                pp_outputs = next_pp_outputs
                release_rids = next_release_rids

                self.running_batch.batch_is_full = False

            if not ENABLE_RELEASE:
                if len(self.disagg_prefill_inflight_queue) &gt; 0:
                    self.process_disagg_prefill_inflight_queue()

            # When the server is idle, self-check and re-init some states
            if server_is_idle and len(self.disagg_prefill_inflight_queue) == 0:
                self.check_memory()
                self.check_tree_cache()
                self.new_token_ratio = self.init_new_token_ratio

    def send_pyobj_to_next_stage(self, data):
        if self.attn_tp_rank == 0:
            dp_offset = self.attn_dp_rank * self.attn_tp_size
            point_to_point_pyobj(
                data,
                self.pp_rank * self.tp_size + dp_offset,
                self.world_group.device_group,
                self.pp_rank * self.tp_size + dp_offset,
                ((self.pp_rank + 1) % self.pp_size) * self.tp_size + dp_offset,
            )

    def recv_pyobj_from_prev_stage(self):
        if self.attn_tp_rank == 0:
            dp_offset = self.attn_dp_rank * self.attn_tp_size
            data = point_to_point_pyobj(
                [],
                self.pp_rank * self.tp_size + dp_offset,
                self.world_group.device_group,
                ((self.pp_rank - 1) % self.pp_size) * self.tp_size + dp_offset,
                self.pp_rank * self.tp_size + dp_offset,
            )
        else:
            data = None

        if self.tp_size != 1:
            data = broadcast_pyobj(
                data, self.tp_group.rank, self.tp_cpu_group, src=self.tp_group.ranks[0]
            )
        return data</code></pre>
</details>
<div class="desc"><p>Mixin for Scheduler to handle disaggregation prefill</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sglang.srt.managers.scheduler.Scheduler" href="../managers/scheduler.html#sglang.srt.managers.scheduler.Scheduler">Scheduler</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_normal_disagg_prefill"><code class="name flex">
<span>def <span class="ident">event_loop_normal_disagg_prefill</span></span>(<span>self: Scheduler) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@torch.no_grad()
def event_loop_normal_disagg_prefill(self: Scheduler) -&gt; None:
    &#34;&#34;&#34;A normal scheduler loop for prefill worker in disaggregation mode.&#34;&#34;&#34;

    while True:
        recv_reqs = self.recv_requests()
        self.process_input_requests(recv_reqs)
        self.waiting_queue.extend(
            self.disagg_prefill_bootstrap_queue.pop_bootstrapped()
        )
        self.process_prefill_chunk()
        batch = self.get_new_batch_prefill()

        if require_mlp_sync(self.server_args):
            batch = self.prepare_mlp_sync_batch(batch)
        self.cur_batch = batch

        if batch:
            result = self.run_batch(batch)
            self.process_batch_result_disagg_prefill(batch, result)

        if len(self.disagg_prefill_inflight_queue) &gt; 0:
            self.process_disagg_prefill_inflight_queue()

        if batch is None and len(self.disagg_prefill_inflight_queue) == 0:
            self.self_check_during_idle()

        self.last_batch = batch
        # HACK (byronhsu): reset the batch_is_full flag because we never enter update_running_batch which resets it
        # Otherwise, it hangs under high concurrency
        self.running_batch.batch_is_full = False</code></pre>
</details>
<div class="desc"><p>A normal scheduler loop for prefill worker in disaggregation mode.</p></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_overlap_disagg_prefill"><code class="name flex">
<span>def <span class="ident">event_loop_overlap_disagg_prefill</span></span>(<span>self: Scheduler) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@torch.no_grad()
def event_loop_overlap_disagg_prefill(self: Scheduler) -&gt; None:
    self.result_queue = deque()

    while True:
        recv_reqs = self.recv_requests()
        self.process_input_requests(recv_reqs)
        self.waiting_queue.extend(
            self.disagg_prefill_bootstrap_queue.pop_bootstrapped()
        )
        self.process_prefill_chunk()
        batch = self.get_new_batch_prefill()

        if require_mlp_sync(self.server_args):
            batch = self.prepare_mlp_sync_batch(batch)
        self.cur_batch = batch
        if batch:
            result = self.run_batch(batch)
            self.result_queue.append((batch.copy(), result))

            if self.last_batch is None:
                # Create a dummy first batch to start the pipeline for overlap schedule.
                # It is now used for triggering the sampling_info_done event.
                tmp_batch = ScheduleBatch(
                    reqs=None,
                    forward_mode=ForwardMode.DUMMY_FIRST,
                    next_batch_sampling_info=self.tp_worker.cur_sampling_info,
                )
                self.set_next_batch_sampling_info_done(tmp_batch)

        if self.last_batch:
            tmp_batch, tmp_result = self.result_queue.popleft()
            tmp_batch.next_batch_sampling_info = (
                self.tp_worker.cur_sampling_info if batch else None
            )
            self.process_batch_result_disagg_prefill(tmp_batch, tmp_result)

        if len(self.disagg_prefill_inflight_queue) &gt; 0:
            self.process_disagg_prefill_inflight_queue()

        if batch is None and len(self.disagg_prefill_inflight_queue) == 0:
            self.self_check_during_idle()

        self.last_batch = batch
        # HACK (byronhsu): reset the batch_is_full flag because we never enter update_running_batch which resets it
        # Otherwise, it hangs under high concurrency
        self.running_batch.batch_is_full = False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_pp_disagg_prefill"><code class="name flex">
<span>def <span class="ident">event_loop_pp_disagg_prefill</span></span>(<span>self: Scheduler)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@DynamicGradMode()
def event_loop_pp_disagg_prefill(self: Scheduler):
    &#34;&#34;&#34;
    An event loop for the prefill server in pipeline parallelism.

    Rules:
    1. Each stage runs in the same order and is notified by the previous stage.
    2. Each send/recv operation is blocking and matched by the neighboring stage.

    Regular Schedule:
    ====================================================================
    Stage i                   | Stage i+1
    send ith req              | recv ith req
    send ith proxy            | recv ith proxy
    send prev (i+1)th carry   | recv prev (i+1)th carry
    ====================================================================

    Prefill Server Schedule:
    ====================================================================
    Stage i                        | Stage i+1
    send ith req                   | recv ith req
    send ith bootstrap req         | recv ith bootstrap req
    send ith transferred req       | recv ith transferred req
    send ith proxy                 | recv ith proxy
    send prev (i+1)th carry        | recv prev (i+1)th carry
    send prev (i+1)th release req  | recv prev (i+1)th release req
    ====================================================================

    There are two additional elements compared to the regular schedule:

    1. Bootstrap Requests:
        a. Instead of polling the status on the current workers, we should wait for the previous stage to notify to avoid desynchronization.
        b. The first stage polls the status and propagates the bootstrapped requests down to all other stages.
        c. If the first stage polls successfully, by nature, other ranks are also successful because they performed a handshake together.

    2. Transferred Requests + Release Requests:
        a. The first stage polls the transfer finished requests, performs an intersection with the next stage&#39;s finished requests, and propagates down to the last stage.
        b. The last stage receives the requests that have finished transfer on all stages (consensus), then sends them to the first stage to release the memory.
        c. The first stage receives the release requests, releases the memory, and then propagates the release requests down to the last stage.
    &#34;&#34;&#34;
    from sglang.srt.managers.scheduler import GenerationBatchResult

    mbs = [None] * self.pp_size
    last_mbs = [None] * self.pp_size
    self.running_mbs = [
        ScheduleBatch(reqs=[], batch_is_full=False) for _ in range(self.pp_size)
    ]
    bids = [None] * self.pp_size
    pp_outputs: Optional[PPProxyTensors] = None

    # Either success or failed
    bootstrapped_rids: List[str] = []
    transferred_rids: List[str] = []
    release_rids: Optional[List[str]] = None

    # transferred microbatch
    tmbs = [None] * self.pp_size

    ENABLE_RELEASE = True  # For debug

    while True:
        server_is_idle = True

        for mb_id in range(self.pp_size):
            self.running_batch = self.running_mbs[mb_id]
            self.last_batch = last_mbs[mb_id]

            recv_reqs = self.recv_requests()

            self.process_input_requests(recv_reqs)

            if self.pp_group.is_first_rank:
                # First rank, pop the bootstrap reqs from the bootstrap queue
                bootstrapped_reqs, failed_reqs = (
                    self.disagg_prefill_bootstrap_queue.pop_bootstrapped(
                        return_failed_reqs=True
                    )
                )
                bootstrapped_rids = [req.rid for req in bootstrapped_reqs] + [
                    req.rid for req in failed_reqs
                ]
                self.waiting_queue.extend(bootstrapped_reqs)
            else:
                # Other ranks, receive the bootstrap reqs info from the previous rank and ensure the consensus
                bootstrapped_rids = self.recv_pyobj_from_prev_stage()
                bootstrapped_reqs = (
                    self.disagg_prefill_bootstrap_queue.pop_bootstrapped(
                        rids_to_check=bootstrapped_rids
                    )
                )
                self.waiting_queue.extend(bootstrapped_reqs)

            if self.pp_group.is_first_rank:
                transferred_rids = self.get_transferred_rids()
            # if other ranks,
            else:
                # 1. recv previous stage&#39;s transferred reqs info
                prev_transferred_rids = self.recv_pyobj_from_prev_stage()
                # 2. get the current stage&#39;s transferred reqs info
                curr_transferred_rids = self.get_transferred_rids()
                # 3. new consensus rids = intersection(previous consensus rids, transfer finished rids)
                transferred_rids = list(
                    set(prev_transferred_rids) &amp; set(curr_transferred_rids)
                )

            tmbs[mb_id] = transferred_rids

            self.process_prefill_chunk()
            mbs[mb_id] = self.get_new_batch_prefill()
            self.running_mbs[mb_id] = self.running_batch

            self.cur_batch = mbs[mb_id]
            if self.cur_batch:
                server_is_idle = False
                result = self.run_batch(self.cur_batch)

            # send the outputs to the next step
            if self.pp_group.is_last_rank:
                if self.cur_batch:
                    next_token_ids, bids[mb_id] = (
                        result.next_token_ids,
                        result.bid,
                    )
                    pp_outputs = PPProxyTensors(
                        {
                            &#34;next_token_ids&#34;: next_token_ids,
                        }
                    )
                    # send the output from the last round to let the next stage worker run post processing
                    self.pp_group.send_tensor_dict(
                        pp_outputs.tensors,
                        all_gather_group=self.attn_tp_group,
                    )

            if ENABLE_RELEASE:
                if self.pp_group.is_last_rank:
                    # At the last stage, all stages has reached the consensus to release memory for transferred_rids
                    release_rids = transferred_rids
                    # send to the first rank
                    self.send_pyobj_to_next_stage(release_rids)

            # receive outputs and post-process (filter finished reqs) the coming microbatch
            next_mb_id = (mb_id + 1) % self.pp_size
            next_pp_outputs = None
            next_release_rids = None

            if mbs[next_mb_id] is not None:
                next_pp_outputs: Optional[PPProxyTensors] = PPProxyTensors(
                    self.pp_group.recv_tensor_dict(
                        all_gather_group=self.attn_tp_group
                    )
                )
                mbs[next_mb_id].output_ids = next_pp_outputs[&#34;next_token_ids&#34;]
                output_result = GenerationBatchResult(
                    logits_output=None,
                    pp_hidden_states_proxy_tensors=None,
                    next_token_ids=next_pp_outputs[&#34;next_token_ids&#34;],
                    extend_input_len_per_req=None,
                    extend_logprob_start_len_per_req=None,
                    bid=bids[next_mb_id],
                    can_run_cuda_graph=result.can_run_cuda_graph,
                )
                self.process_batch_result_disagg_prefill(
                    mbs[next_mb_id], output_result
                )

                last_mbs[next_mb_id] = mbs[next_mb_id]

            if ENABLE_RELEASE:
                if tmbs[next_mb_id] is not None:
                    # recv consensus rids from the previous rank
                    next_release_rids = self.recv_pyobj_from_prev_stage()
                    self.process_disagg_prefill_inflight_queue(next_release_rids)

            # carry the outputs to the next stage
            if not self.pp_group.is_last_rank:
                if self.cur_batch:
                    bids[mb_id] = result.bid
                if pp_outputs:
                    # send the outputs from the last round to let the next stage worker run post processing
                    self.pp_group.send_tensor_dict(
                        pp_outputs.tensors,
                        all_gather_group=self.attn_tp_group,
                    )
                if ENABLE_RELEASE:
                    if release_rids is not None:
                        self.send_pyobj_to_next_stage(release_rids)

            if not self.pp_group.is_last_rank:
                # send out reqs to the next stage
                self.send_pyobj_to_next_stage(recv_reqs)
                self.send_pyobj_to_next_stage(bootstrapped_rids)
                self.send_pyobj_to_next_stage(transferred_rids)

                # send out proxy tensors to the next stage
                if self.cur_batch:
                    self.pp_group.send_tensor_dict(
                        result.pp_hidden_states_proxy_tensors,
                        all_gather_group=self.attn_tp_group,
                    )

            pp_outputs = next_pp_outputs
            release_rids = next_release_rids

            self.running_batch.batch_is_full = False

        if not ENABLE_RELEASE:
            if len(self.disagg_prefill_inflight_queue) &gt; 0:
                self.process_disagg_prefill_inflight_queue()

        # When the server is idle, self-check and re-init some states
        if server_is_idle and len(self.disagg_prefill_inflight_queue) == 0:
            self.check_memory()
            self.check_tree_cache()
            self.new_token_ratio = self.init_new_token_ratio</code></pre>
</details>
<div class="desc"><p>An event loop for the prefill server in pipeline parallelism.</p>
<p>Rules:
1. Each stage runs in the same order and is notified by the previous stage.
2. Each send/recv operation is blocking and matched by the neighboring stage.</p>
<h1 id="regular-schedule">Regular Schedule:</h1>
<p>Stage i
| Stage i+1
send ith req
| recv ith req
send ith proxy
| recv ith proxy
send prev (i+1)th carry
| recv prev (i+1)th carry
====================================================================</p>
<h1 id="prefill-server-schedule">Prefill Server Schedule:</h1>
<p>Stage i
| Stage i+1
send ith req
| recv ith req
send ith bootstrap req
| recv ith bootstrap req
send ith transferred req
| recv ith transferred req
send ith proxy
| recv ith proxy
send prev (i+1)th carry
| recv prev (i+1)th carry
send prev (i+1)th release req
| recv prev (i+1)th release req
====================================================================</p>
<p>There are two additional elements compared to the regular schedule:</p>
<ol>
<li>
<p>Bootstrap Requests:
a. Instead of polling the status on the current workers, we should wait for the previous stage to notify to avoid desynchronization.
b. The first stage polls the status and propagates the bootstrapped requests down to all other stages.
c. If the first stage polls successfully, by nature, other ranks are also successful because they performed a handshake together.</p>
</li>
<li>
<p>Transferred Requests + Release Requests:
a. The first stage polls the transfer finished requests, performs an intersection with the next stage's finished requests, and propagates down to the last stage.
b. The last stage receives the requests that have finished transfer on all stages (consensus), then sends them to the first stage to release the memory.
c. The first stage receives the release requests, releases the memory, and then propagates the release requests down to the last stage.</p>
</li>
</ol></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.get_transferred_rids"><code class="name flex">
<span>def <span class="ident">get_transferred_rids</span></span>(<span>self: Scheduler) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transferred_rids(self: Scheduler) -&gt; List[str]:
    &#34;&#34;&#34;
    Used by PP, get the transferred rids but **do not pop**
    &#34;&#34;&#34;
    polls = poll_and_all_reduce(
        [req.disagg_kv_sender for req in self.disagg_prefill_inflight_queue],
        self.tp_worker.get_tp_group().cpu_group,
    )

    transferred_rids: List[str] = []

    for req, poll in zip(self.disagg_prefill_inflight_queue, polls):
        if poll == KVPoll.Success or poll == KVPoll.Failed:
            transferred_rids.append(req.rid)

    return transferred_rids</code></pre>
</details>
<div class="desc"><p>Used by PP, get the transferred rids but <strong>do not pop</strong></p></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_batch_result_disagg_prefill"><code class="name flex">
<span>def <span class="ident">process_batch_result_disagg_prefill</span></span>(<span>self: Scheduler,<br>batch: ScheduleBatch,<br>result: GenerationBatchResult,<br>launch_done: Optional[threading.Event] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_batch_result_disagg_prefill(
    self: Scheduler,
    batch: ScheduleBatch,
    result: GenerationBatchResult,
    launch_done: Optional[threading.Event] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Transfer kv for prefill completed requests and add it into disagg_prefill_inflight_queue
    Adapted from process_batch_result_prefill
    &#34;&#34;&#34;
    (
        logits_output,
        next_token_ids,
        extend_input_len_per_req,
        extend_logprob_start_len_per_req,
    ) = (
        result.logits_output,
        result.next_token_ids,
        result.extend_input_len_per_req,
        result.extend_logprob_start_len_per_req,
    )

    logprob_pt = 0
    # Transfer kv for prefill completed requests and add it into disagg_prefill_inflight_queue
    if self.enable_overlap:
        # wait
        logits_output, next_token_ids, _ = self.tp_worker.resolve_last_batch_result(
            launch_done
        )
    else:
        next_token_ids = result.next_token_ids.tolist()
        if batch.return_logprob:
            if logits_output.next_token_logprobs is not None:
                logits_output.next_token_logprobs = (
                    logits_output.next_token_logprobs.tolist()
                )
            if logits_output.input_token_logprobs is not None:
                logits_output.input_token_logprobs = tuple(
                    logits_output.input_token_logprobs.tolist()
                )

    hidden_state_offset = 0
    for i, (req, next_token_id) in enumerate(
        zip(batch.reqs, next_token_ids, strict=True)
    ):
        req: Req
        if req.is_chunked &lt;= 0:
            # There is no output_ids for prefill
            req.output_ids.append(next_token_id)
            self.tree_cache.cache_unfinished_req(req)  # update the tree and lock
            self.disagg_prefill_inflight_queue.append(req)
            if (
                logits_output is not None
                and logits_output.hidden_states is not None
            ):
                last_hidden_index = (
                    hidden_state_offset + extend_input_len_per_req[i] - 1
                )
                req.hidden_states_tensor = (
                    logits_output.hidden_states[last_hidden_index].cpu().clone()
                )
                hidden_state_offset += extend_input_len_per_req[i]
            else:
                req.hidden_states_tensor = None
            if req.return_logprob:
                assert extend_logprob_start_len_per_req is not None
                assert extend_input_len_per_req is not None
                extend_logprob_start_len = extend_logprob_start_len_per_req[i]
                extend_input_len = extend_input_len_per_req[i]
                num_input_logprobs = extend_input_len - extend_logprob_start_len
                self.add_logprob_return_values(
                    i,
                    req,
                    logprob_pt,
                    next_token_ids,
                    num_input_logprobs,
                    logits_output,
                )
                logprob_pt += num_input_logprobs
            self.send_kv_chunk(req, last_chunk=True)

            if req.grammar is not None:
                # FIXME: this try-except block is for handling unexpected xgrammar issue.
                try:
                    req.grammar.accept_token(next_token_id)
                except ValueError as e:
                    # Grammar accept_token can raise ValueError if the token is not in the grammar.
                    # This can happen if the grammar is not set correctly or the token is invalid.
                    error_message = f&#34;Grammar accept_token failed for req {req.rid} with token {next_token_id}: {e}&#34;
                    self.tree_cache.cache_finished_req(req)
                    prepare_abort(
                        req,
                        error_message,
                        status_code=HTTPStatus.INTERNAL_SERVER_ERROR,
                    )
                req.grammar.finished = req.finished()
        else:
            # being chunked reqs&#39; prefill is not finished
            req.is_chunked -= 1

            if req.return_logprob:
                extend_logprob_start_len = extend_logprob_start_len_per_req[i]
                extend_input_len = extend_input_len_per_req[i]
                if extend_logprob_start_len &lt; extend_input_len:
                    # Update input logprobs.
                    num_input_logprobs = extend_input_len - extend_logprob_start_len
                    self.add_input_logprob_return_values(
                        i,
                        req,
                        logits_output,
                        logprob_pt,
                        num_input_logprobs,
                        last_prefill_chunk=False,
                    )
                    logprob_pt += num_input_logprobs

            if self.enable_overlap:
                self.send_kv_chunk(req, last_chunk=False, end_idx=req.tmp_end_idx)

    # We need to remove the sync in the following function for overlap schedule.
    self.set_next_batch_sampling_info_done(batch)
    self.maybe_send_health_check_signal()</code></pre>
</details>
<div class="desc"><p>Transfer kv for prefill completed requests and add it into disagg_prefill_inflight_queue
Adapted from process_batch_result_prefill</p></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_disagg_prefill_inflight_queue"><code class="name flex">
<span>def <span class="ident">process_disagg_prefill_inflight_queue</span></span>(<span>self: Scheduler, rids_to_check: Optional[List[str]] = None) ‑> List[Req]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_disagg_prefill_inflight_queue(
    self: Scheduler, rids_to_check: Optional[List[str]] = None
) -&gt; List[Req]:
    &#34;&#34;&#34;
    Poll the requests in the middle of transfer. If done, return the request.
    rids_to_check: For PP, on rank &gt; 0, check the rids from the previous rank has consensus with the current rank.
    &#34;&#34;&#34;
    if len(self.disagg_prefill_inflight_queue) == 0:
        return []

    done_reqs = []

    polls = poll_and_all_reduce(
        [req.disagg_kv_sender for req in self.disagg_prefill_inflight_queue],
        self.attn_tp_cpu_group,
    )

    undone_reqs: List[Req] = []
    # Check .poll() for the reqs in disagg_prefill_inflight_queue. If Success, respond to the client and remove it from the queue
    for req, poll in zip(self.disagg_prefill_inflight_queue, polls):

        if rids_to_check is not None:
            if req.rid not in rids_to_check:
                undone_reqs.append(req)
                continue

            assert poll == KVPoll.Success or poll == KVPoll.Failed

        if poll in [KVPoll.WaitingForInput, KVPoll.Transferring]:
            undone_reqs.append(req)
        elif poll == KVPoll.Success:  # transfer done
            self.tree_cache.cache_finished_req(req)  # unlock the tree
            req.finished_reason = FINISH_LENGTH(length=0)
            # FIXME: clean up req&#39;s data in transfer engine
            if hasattr(req.disagg_kv_sender, &#34;clear&#34;):
                req.disagg_kv_sender.clear()
            done_reqs.append(req)
        elif poll == KVPoll.Failed:
            error_message = f&#34;Prefill transfer failed for request rank={self.tp_rank} {req.rid=} {req.bootstrap_room=}&#34;
            try:
                req.disagg_kv_sender.failure_exception()
            except Exception as e:
                error_message += f&#34; with exception {e}&#34;
            logger.warning(error_message)
            self.tree_cache.cache_finished_req(req)  # unlock the tree
            prepare_abort(
                req, error_message, status_code=HTTPStatus.INTERNAL_SERVER_ERROR
            )
            done_reqs.append(req)
            if self.enable_metrics:
                self.metrics_collector.increment_transfer_failed_reqs()
        else:
            assert False, f&#34;Unexpected polling state {poll=}&#34;

    # Stream requests which have finished transfer
    self.stream_output(
        done_reqs,
        any(req.return_logprob for req in done_reqs),
        None,
    )
    for req in done_reqs:
        req: Req
        self.req_to_metadata_buffer_idx_allocator.free(req.metadata_buffer_index)
        req.metadata_buffer_index = -1

    self.disagg_prefill_inflight_queue = undone_reqs

    return done_reqs</code></pre>
</details>
<div class="desc"><p>Poll the requests in the middle of transfer. If done, return the request.
rids_to_check: For PP, on rank &gt; 0, check the rids from the previous rank has consensus with the current rank.</p></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_prefill_chunk"><code class="name flex">
<span>def <span class="ident">process_prefill_chunk</span></span>(<span>self: Scheduler) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_prefill_chunk(self: Scheduler) -&gt; None:
    if self.last_batch and self.last_batch.forward_mode.is_extend():
        if self.chunked_req:
            # Move the chunked request out of the batch so that we can merge
            # only finished requests to running_batch.
            self.last_batch.filter_batch(chunked_req_to_exclude=self.chunked_req)
            self.tree_cache.cache_unfinished_req(self.chunked_req, chunked=True)
            if self.enable_overlap:
                # Delay KV transfer to process_batch_result_disagg_prefill when overlap is enabled to ensure results are resolved
                self.chunked_req.tmp_end_idx = min(
                    len(self.chunked_req.fill_ids),
                    len(self.chunked_req.origin_input_ids),
                )
            else:
                self.send_kv_chunk(self.chunked_req)
            # chunked request keeps its rid but will get a new req_pool_idx
            self.req_to_token_pool.free(self.chunked_req.req_pool_idx)
            self.running_batch.batch_is_full = False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.recv_pyobj_from_prev_stage"><code class="name flex">
<span>def <span class="ident">recv_pyobj_from_prev_stage</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recv_pyobj_from_prev_stage(self):
    if self.attn_tp_rank == 0:
        dp_offset = self.attn_dp_rank * self.attn_tp_size
        data = point_to_point_pyobj(
            [],
            self.pp_rank * self.tp_size + dp_offset,
            self.world_group.device_group,
            ((self.pp_rank - 1) % self.pp_size) * self.tp_size + dp_offset,
            self.pp_rank * self.tp_size + dp_offset,
        )
    else:
        data = None

    if self.tp_size != 1:
        data = broadcast_pyobj(
            data, self.tp_group.rank, self.tp_cpu_group, src=self.tp_group.ranks[0]
        )
    return data</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_kv_chunk"><code class="name flex">
<span>def <span class="ident">send_kv_chunk</span></span>(<span>self: Scheduler,<br>req: Req,<br>last_chunk: bool = False,<br>end_idx: Optional[int] = None) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_kv_chunk(
    self: Scheduler,
    req: Req,
    last_chunk: bool = False,
    end_idx: Optional[int] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Send a prefilled chunk to the decode server
    &#34;&#34;&#34;
    page_size = self.token_to_kv_pool_allocator.page_size
    start_idx = req.start_send_idx
    end_idx = (
        end_idx
        if end_idx is not None
        else min(len(req.fill_ids), len(req.origin_input_ids))
    )

    if not last_chunk:
        # if not the last chunk and the last page is partial, delay the last partial page to the next send
        end_idx = end_idx - end_idx % page_size

    kv_indices = (
        self.req_to_token_pool.req_to_token[req.req_pool_idx, start_idx:end_idx]
        .cpu()
        .numpy()
    )
    req.start_send_idx = end_idx
    if last_chunk:
        self.disagg_metadata_buffers.set_buf(req)
    page_indices = kv_to_page_indices(kv_indices, page_size)
    if len(page_indices) == 0:
        logger.info(
            f&#34;Skip sending kv chunk for request {req.rid=} {req.bootstrap_room=} because page_indices is empty&#34;
        )
        return
    req.disagg_kv_sender.send(page_indices)</code></pre>
</details>
<div class="desc"><p>Send a prefilled chunk to the decode server</p></div>
</dd>
<dt id="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_pyobj_to_next_stage"><code class="name flex">
<span>def <span class="ident">send_pyobj_to_next_stage</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_pyobj_to_next_stage(self, data):
    if self.attn_tp_rank == 0:
        dp_offset = self.attn_dp_rank * self.attn_tp_size
        point_to_point_pyobj(
            data,
            self.pp_rank * self.tp_size + dp_offset,
            self.world_group.device_group,
            self.pp_rank * self.tp_size + dp_offset,
            ((self.pp_rank + 1) % self.pp_size) * self.tp_size + dp_offset,
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.disaggregation" href="index.html">sglang.srt.disaggregation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue" href="#sglang.srt.disaggregation.prefill.PrefillBootstrapQueue">PrefillBootstrapQueue</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.add" href="#sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.add">add</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.extend" href="#sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.extend">extend</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.pop_bootstrapped" href="#sglang.srt.disaggregation.prefill.PrefillBootstrapQueue.pop_bootstrapped">pop_bootstrapped</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin">SchedulerDisaggregationPrefillMixin</a></code></h4>
<ul class="">
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_normal_disagg_prefill" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_normal_disagg_prefill">event_loop_normal_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_overlap_disagg_prefill" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_overlap_disagg_prefill">event_loop_overlap_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_pp_disagg_prefill" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.event_loop_pp_disagg_prefill">event_loop_pp_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.get_transferred_rids" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.get_transferred_rids">get_transferred_rids</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_batch_result_disagg_prefill" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_batch_result_disagg_prefill">process_batch_result_disagg_prefill</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_disagg_prefill_inflight_queue" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_disagg_prefill_inflight_queue">process_disagg_prefill_inflight_queue</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_prefill_chunk" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.process_prefill_chunk">process_prefill_chunk</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.recv_pyobj_from_prev_stage" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.recv_pyobj_from_prev_stage">recv_pyobj_from_prev_stage</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_kv_chunk" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_kv_chunk">send_kv_chunk</a></code></li>
<li><code><a title="sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_pyobj_to_next_stage" href="#sglang.srt.disaggregation.prefill.SchedulerDisaggregationPrefillMixin.send_pyobj_to_next_stage">send_pyobj_to_next_stage</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
