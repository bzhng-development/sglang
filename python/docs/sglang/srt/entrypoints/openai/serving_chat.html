<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.srt.entrypoints.openai.serving_chat API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.srt.entrypoints.openai.serving_chat</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.srt.entrypoints.openai.serving_chat.OpenAIServingChat"><code class="flex name class">
<span>class <span class="ident">OpenAIServingChat</span></span>
<span>(</span><span>tokenizer_manager: <a title="sglang.srt.managers.tokenizer_manager.TokenizerManager" href="../../managers/tokenizer_manager.html#sglang.srt.managers.tokenizer_manager.TokenizerManager">TokenizerManager</a>,<br>template_manager: <a title="sglang.srt.managers.template_manager.TemplateManager" href="../../managers/template_manager.html#sglang.srt.managers.template_manager.TemplateManager">TemplateManager</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OpenAIServingChat(OpenAIServingBase):
    &#34;&#34;&#34;Handler for /v1/chat/completions requests&#34;&#34;&#34;

    def __init__(
        self,
        tokenizer_manager: TokenizerManager,
        template_manager: TemplateManager,
    ):
        super().__init__(tokenizer_manager)
        self.template_manager = template_manager

    def _request_id_prefix(self) -&gt; str:
        return &#34;chatcmpl-&#34;

    def _validate_request(self, request: ChatCompletionRequest) -&gt; Optional[str]:
        &#34;&#34;&#34;Validate that the input is valid.&#34;&#34;&#34;
        if not request.messages:
            return &#34;Messages cannot be empty.&#34;

        if (
            isinstance(request.tool_choice, str)
            and request.tool_choice.lower() == &#34;required&#34;
            and not request.tools
        ):
            return &#34;Tools cannot be empty if tool choice is set to required.&#34;

        max_output_tokens = request.max_completion_tokens or request.max_tokens
        server_context_length = self.tokenizer_manager.server_args.context_length
        if (
            max_output_tokens
            and server_context_length
            and max_output_tokens &gt; server_context_length
        ):
            return (
                f&#34;max_completion_tokens is too large: {max_output_tokens}.&#34;
                f&#34;This model supports at most {server_context_length} completion tokens.&#34;
            )

        if request.response_format and request.response_format.type == &#34;json_schema&#34;:
            schema = getattr(request.response_format.json_schema, &#34;schema_&#34;, None)
            if schema is None:
                return &#34;schema_ is required for json_schema response format request.&#34;

        return None

    def _convert_to_internal_request(
        self,
        request: ChatCompletionRequest,
    ) -&gt; tuple[GenerateReqInput, ChatCompletionRequest]:
        reasoning_effort = (
            request.chat_template_kwargs.pop(&#34;reasoning_effort&#34;, None)
            if request.chat_template_kwargs
            else None
        )
        if reasoning_effort is not None:
            request.reasoning_effort = reasoning_effort

        &#34;&#34;&#34;Convert OpenAI chat completion request to internal format&#34;&#34;&#34;
        is_multimodal = self.tokenizer_manager.model_config.is_multimodal

        # Process messages and apply chat template
        processed_messages = self._process_messages(request, is_multimodal)

        # Build sampling parameters
        sampling_params = self._build_sampling_params(
            request,
            processed_messages.stop,
            processed_messages.tool_call_constraint,
        )

        # Handle single vs multiple requests
        if is_multimodal:
            prompt_kwargs = {&#34;text&#34;: processed_messages.prompt}
        else:
            if isinstance(processed_messages.prompt_ids, str):
                prompt_kwargs = {&#34;text&#34;: processed_messages.prompt_ids}
            else:
                prompt_kwargs = {&#34;input_ids&#34;: processed_messages.prompt_ids}

        adapted_request = GenerateReqInput(
            **prompt_kwargs,
            image_data=processed_messages.image_data,
            video_data=processed_messages.video_data,
            audio_data=processed_messages.audio_data,
            sampling_params=sampling_params,
            return_logprob=request.logprobs,
            logprob_start_len=-1,
            top_logprobs_num=request.top_logprobs or 0,
            stream=request.stream,
            return_text_in_logprobs=True,
            modalities=processed_messages.modalities,
            lora_path=request.lora_path,
            bootstrap_host=request.bootstrap_host,
            bootstrap_port=request.bootstrap_port,
            bootstrap_room=request.bootstrap_room,
            return_hidden_states=request.return_hidden_states,
            rid=request.rid,
        )

        return adapted_request, request

    def _process_messages(
        self, request: ChatCompletionRequest, is_multimodal: bool
    ) -&gt; MessageProcessingResult:
        &#34;&#34;&#34;Process chat messages and apply chat template&#34;&#34;&#34;
        is_gpt_oss = (
            hasattr(self.tokenizer_manager.model_config, &#34;hf_config&#34;)
            and hasattr(self.tokenizer_manager.model_config.hf_config, &#34;model_type&#34;)
            and self.tokenizer_manager.model_config.hf_config.model_type == &#34;gpt_oss&#34;
        )

        # GptOss model needs to keep special tokens for harmony parsing
        if is_gpt_oss:
            request.skip_special_tokens = False

        tool_call_constraint = None

        # Apply chat template and its stop strings
        tools = None
        if request.tools and request.tool_choice != &#34;none&#34;:
            request.skip_special_tokens = False
            if not isinstance(request.tool_choice, str):
                tools = [
                    item.function.model_dump()
                    for item in request.tools
                    if item.function.name == request.tool_choice.function.name
                ]
            else:
                tools = [item.function.model_dump() for item in request.tools]

            tool_call_parser = self.tokenizer_manager.server_args.tool_call_parser
            parser = FunctionCallParser(request.tools, tool_call_parser)
            tool_call_constraint = parser.get_structure_constraint(request.tool_choice)

        # Use chat template
        if self.template_manager.chat_template_name is None:
            result = self._apply_jinja_template(request, tools, is_multimodal)
        else:
            result = self._apply_conversation_template(request, is_multimodal)

        result.tool_call_constraint = tool_call_constraint
        return result

    def _apply_jinja_template(
        self,
        request: ChatCompletionRequest,
        tools: Optional[List[Dict]],
        is_multimodal: bool,
    ) -&gt; MessageProcessingResult:
        &#34;&#34;&#34;Apply Jinja chat template&#34;&#34;&#34;
        prompt = &#34;&#34;
        prompt_ids = []
        openai_compatible_messages = []
        image_data = []
        video_data = []
        audio_data = []
        modalities = []

        template_content_format = self.template_manager.jinja_template_content_format

        for message in request.messages:
            if message.content is None:
                message.content = &#34;&#34;
            msg_dict = message.model_dump()

            # Process content based on detected template format
            processed_msg = process_content_for_template_format(
                msg_dict,
                template_content_format,
                image_data,
                video_data,
                audio_data,
                modalities,
            )

            # per the Transformers docs &amp; maintainers, tool call arguments in
            # assistant-role messages with tool_calls need to be dicts not JSON str -
            # this is how tool-use chat templates will expect them moving forwards
            # so, for messages that have tool_calls, parse the string (which we get
            # from openAI format) to dict
            if (
                processed_msg[&#34;role&#34;] == &#34;assistant&#34;
                and &#34;tool_calls&#34; in processed_msg
                and isinstance(processed_msg[&#34;tool_calls&#34;], list)
            ):
                for item in processed_msg[&#34;tool_calls&#34;]:
                    if &#34;arguments&#34; in item[&#34;function&#34;] and isinstance(
                        item[&#34;function&#34;][&#34;arguments&#34;], str
                    ):
                        item[&#34;function&#34;][&#34;arguments&#34;] = json.loads(
                            item[&#34;function&#34;][&#34;arguments&#34;]
                        )

            openai_compatible_messages.append(processed_msg)

        # Handle assistant prefix for continue_final_message
        assistant_prefix = None
        if (
            openai_compatible_messages
            and openai_compatible_messages[-1][&#34;role&#34;] == &#34;assistant&#34;
        ):
            if request.continue_final_message:
                assistant_prefix = openai_compatible_messages[-1][&#34;content&#34;]
                openai_compatible_messages = openai_compatible_messages[:-1]

        try:
            prompt_ids = self.tokenizer_manager.tokenizer.apply_chat_template(
                openai_compatible_messages,
                tokenize=True,
                add_generation_prompt=True,
                tools=tools,
                reasoning_effort=request.reasoning_effort,
                **(
                    request.chat_template_kwargs if request.chat_template_kwargs else {}
                ),
            )
        except Exception:
            # This except branch will be triggered when the chosen model
            # has a different tools input format that is not compatible
            # with openAI&#39;s apply_chat_template tool_call format, like Mistral.
            tools = (
                [t if &#34;function&#34; in t else {&#34;function&#34;: t} for t in tools]
                if tools
                else None
            )
            prompt_ids = self.tokenizer_manager.tokenizer.apply_chat_template(
                openai_compatible_messages,
                tokenize=True,
                add_generation_prompt=True,
                tools=tools,
                reasoning_effort=request.reasoning_effort,
                **(
                    request.chat_template_kwargs if request.chat_template_kwargs else {}
                ),
            )

        if assistant_prefix:
            encoded = self.tokenizer_manager.tokenizer.encode(assistant_prefix)
            if encoded and encoded[0] == self.tokenizer_manager.tokenizer.bos_token_id:
                encoded = encoded[1:]
            prompt_ids += encoded

        if is_multimodal:
            prompt = self.tokenizer_manager.tokenizer.decode(prompt_ids)

        stop = request.stop
        image_data = image_data if image_data else None
        audio_data = audio_data if audio_data else None
        video_data = video_data if video_data else None
        modalities = modalities if modalities else []
        return MessageProcessingResult(
            prompt=prompt,
            prompt_ids=prompt_ids,
            image_data=image_data,
            video_data=video_data,
            audio_data=audio_data,
            modalities=modalities,
            stop=stop,
        )

    def _apply_conversation_template(
        self,
        request: ChatCompletionRequest,
        is_multimodal: bool,
    ) -&gt; MessageProcessingResult:
        &#34;&#34;&#34;Apply conversation template&#34;&#34;&#34;
        prompt = &#34;&#34;
        prompt_ids = []
        conv = generate_chat_conv(request, self.template_manager.chat_template_name)

        # If we should continue the final assistant message, adjust the conversation.
        if (
            request.continue_final_message
            and request.messages
            and request.messages[-1].role == &#34;assistant&#34;
        ):
            # Remove the auto-added blank assistant turn, if present.
            if conv.messages and conv.messages[-1][1] is None:
                conv.messages.pop()
            # Rebuild the prompt from the conversation.
            prompt = conv.get_prompt()
            # Strip trailing stop tokens or separators that indicate end-of-assistant.
            if isinstance(conv.stop_str, list):
                for stop_token in conv.stop_str:
                    if prompt.endswith(stop_token):
                        prompt = prompt[: -len(stop_token)]
            elif isinstance(conv.stop_str, str) and prompt.endswith(conv.stop_str):
                prompt = prompt[: -len(conv.stop_str)]
            if conv.sep and prompt.endswith(conv.sep):
                prompt = prompt[: -len(conv.sep)]
            if getattr(conv, &#34;sep2&#34;, None) and prompt.endswith(conv.sep2):
                prompt = prompt[: -len(conv.sep2)]
        else:
            prompt = conv.get_prompt()
            if self._get_enable_thinking_from_request(request):
                prompt += &#34;&lt;think&gt;&#34;  # Note(Xinyuan): hard code thinking token

        image_data = conv.image_data if conv.image_data else None
        video_data = conv.video_data if conv.video_data else None
        audio_data = conv.audio_data if conv.audio_data else None
        modalities = conv.modalities if conv.modalities else []
        stop = copy.copy(conv.stop_str or [] if not request.ignore_eos else [])

        if request.stop:
            if isinstance(request.stop, str):
                stop.append(request.stop)
            else:
                stop.extend(request.stop)

        if not is_multimodal:
            prompt_ids = self.tokenizer_manager.tokenizer.encode(prompt)

        return MessageProcessingResult(
            prompt=prompt,
            prompt_ids=prompt_ids,
            image_data=image_data,
            video_data=video_data,
            audio_data=audio_data,
            modalities=modalities,
            stop=stop,
        )

    def _build_sampling_params(
        self,
        request: ChatCompletionRequest,
        stop: List[str],
        tool_call_constraint: Optional[Any],
    ) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Build sampling parameters for the request&#34;&#34;&#34;

        sampling_params = {
            &#34;temperature&#34;: request.temperature,
            &#34;max_new_tokens&#34;: request.max_tokens or request.max_completion_tokens,
            &#34;min_new_tokens&#34;: request.min_tokens,
            &#34;stop&#34;: stop,
            &#34;stop_token_ids&#34;: request.stop_token_ids,
            &#34;top_p&#34;: request.top_p,
            &#34;top_k&#34;: request.top_k,
            &#34;min_p&#34;: request.min_p,
            &#34;presence_penalty&#34;: request.presence_penalty,
            &#34;frequency_penalty&#34;: request.frequency_penalty,
            &#34;repetition_penalty&#34;: request.repetition_penalty,
            &#34;regex&#34;: request.regex,
            &#34;ebnf&#34;: request.ebnf,
            &#34;n&#34;: request.n,
            &#34;no_stop_trim&#34;: request.no_stop_trim,
            &#34;ignore_eos&#34;: request.ignore_eos,
            &#34;skip_special_tokens&#34;: request.skip_special_tokens,
            &#34;logit_bias&#34;: request.logit_bias,
        }

        if request.response_format and request.response_format.type == &#34;json_schema&#34;:
            sampling_params[&#34;json_schema&#34;] = convert_json_schema_to_str(
                request.response_format.json_schema.schema_
            )
        elif request.response_format and request.response_format.type == &#34;json_object&#34;:
            sampling_params[&#34;json_schema&#34;] = &#39;{&#34;type&#34;: &#34;object&#34;}&#39;
        elif (
            request.response_format and request.response_format.type == &#34;structural_tag&#34;
        ):
            sampling_params[&#34;structural_tag&#34;] = convert_json_schema_to_str(
                request.response_format.model_dump(by_alias=True)
            )

        # Check if there are already existing output constraints
        has_existing_constraints = (
            sampling_params.get(&#34;regex&#34;)
            or sampling_params.get(&#34;ebnf&#34;)
            or sampling_params.get(&#34;structural_tag&#34;)
            or sampling_params.get(&#34;json_schema&#34;)
        )

        if tool_call_constraint and has_existing_constraints:
            logger.warning(&#34;Constrained decoding is not compatible with tool calls.&#34;)
        elif tool_call_constraint:
            constraint_type, constraint_value = tool_call_constraint
            if constraint_type == &#34;structural_tag&#34;:
                sampling_params[constraint_type] = convert_json_schema_to_str(
                    constraint_value.model_dump(by_alias=True)
                )
            else:
                sampling_params[constraint_type] = constraint_value
        return sampling_params

    async def _handle_streaming_request(
        self,
        adapted_request: GenerateReqInput,
        request: ChatCompletionRequest,
        raw_request: Request,
    ) -&gt; StreamingResponse:
        &#34;&#34;&#34;Handle streaming chat completion request&#34;&#34;&#34;
        return StreamingResponse(
            self._generate_chat_stream(adapted_request, request, raw_request),
            media_type=&#34;text/event-stream&#34;,
            background=self.tokenizer_manager.create_abort_task(adapted_request),
        )

    async def _generate_chat_stream(
        self,
        adapted_request: GenerateReqInput,
        request: ChatCompletionRequest,
        raw_request: Request,
    ) -&gt; AsyncGenerator[str, None]:
        &#34;&#34;&#34;Generate streaming chat completion response&#34;&#34;&#34;
        # Parsers for tool calls and reasoning
        parser_dict = {}
        reasoning_parser_dict = {}

        # State tracking for streaming
        is_firsts = {}
        stream_buffers = {}
        n_prev_tokens = {}
        has_tool_calls = {}
        finish_reasons = {}

        # Usage tracking
        prompt_tokens = {}
        completion_tokens = {}
        cached_tokens = {}
        hidden_states = {}

        try:
            async for content in self.tokenizer_manager.generate_request(
                adapted_request, raw_request
            ):
                index = content.get(&#34;index&#34;, 0)

                prompt_tokens[index] = content[&#34;meta_info&#34;][&#34;prompt_tokens&#34;]
                completion_tokens[index] = content[&#34;meta_info&#34;][&#34;completion_tokens&#34;]
                cached_tokens[index] = content[&#34;meta_info&#34;].get(&#34;cached_tokens&#34;, 0)
                hidden_states[index] = content[&#34;meta_info&#34;].get(&#34;hidden_states&#34;, None)

                # Handle logprobs
                choice_logprobs = None
                if request.logprobs:
                    choice_logprobs = self._process_streaming_logprobs(
                        content, n_prev_tokens.get(index, 0)
                    )
                    n_prev_tokens[index] = len(
                        content[&#34;meta_info&#34;][&#34;output_token_logprobs&#34;]
                    )

                finish_reason = content[&#34;meta_info&#34;][&#34;finish_reason&#34;]
                finish_reason_type = finish_reason[&#34;type&#34;] if finish_reason else None

                # Track finish_reason for each index
                if finish_reason_type:
                    finish_reasons[index] = finish_reason

                # First chunk with role
                if is_firsts.get(index, True):
                    is_firsts[index] = False
                    delta = DeltaMessage(role=&#34;assistant&#34;, content=&#34;&#34;)
                    choice_data = ChatCompletionResponseStreamChoice(
                        index=index,
                        delta=delta,
                        finish_reason=None,
                        logprobs=None,
                    )
                    chunk = ChatCompletionStreamResponse(
                        id=content[&#34;meta_info&#34;][&#34;id&#34;],
                        created=int(time.time()),
                        choices=[choice_data],
                        model=request.model,
                    )
                    yield f&#34;data: {chunk.model_dump_json()}\n\n&#34;

                stream_buffer = stream_buffers.get(index, &#34;&#34;)
                delta = content[&#34;text&#34;][len(stream_buffer) :]
                stream_buffers[index] = stream_buffer + delta

                # Handle reasoning content
                if (
                    self.tokenizer_manager.server_args.reasoning_parser
                    and request.separate_reasoning
                ):
                    reasoning_text, delta = self._process_reasoning_stream(
                        index, delta, reasoning_parser_dict, content, request
                    )
                    if reasoning_text:
                        choice_data = ChatCompletionResponseStreamChoice(
                            index=index,
                            delta=DeltaMessage(reasoning_content=reasoning_text),
                            finish_reason=None,
                        )
                        chunk = ChatCompletionStreamResponse(
                            id=content[&#34;meta_info&#34;][&#34;id&#34;],
                            created=int(time.time()),
                            choices=[choice_data],
                            model=request.model,
                        )
                        yield f&#34;data: {chunk.model_dump_json()}\n\n&#34;

                # Handle tool calls
                if request.tool_choice != &#34;none&#34; and request.tools:
                    async for chunk in self._process_tool_call_stream(
                        index,
                        delta,
                        parser_dict,
                        content,
                        request,
                        has_tool_calls,
                    ):
                        if chunk:
                            yield chunk

                    # Send any remaining tool call arguments when generation finishes
                    if finish_reason_type is not None and index in parser_dict:
                        parser = parser_dict[index]
                        remaining_chunk = self._check_for_unstreamed_tool_args(
                            parser, content, request, index
                        )
                        if remaining_chunk:
                            yield remaining_chunk

                else:
                    # Regular content
                    if delta:
                        choice_data = ChatCompletionResponseStreamChoice(
                            index=index,
                            delta=DeltaMessage(content=delta),
                            finish_reason=None,
                            matched_stop=None,
                            logprobs=choice_logprobs,
                        )
                        chunk = ChatCompletionStreamResponse(
                            id=content[&#34;meta_info&#34;][&#34;id&#34;],
                            created=int(time.time()),
                            choices=[choice_data],
                            model=request.model,
                        )
                        yield f&#34;data: {chunk.model_dump_json()}\n\n&#34;

            # Send finish_reason chunks for each index that completed
            for idx, finish_reason_data in finish_reasons.items():
                finish_reason_type = finish_reason_data[&#34;type&#34;]

                # Change finish_reason to &#34;tool_calls&#34; if we had tool calls and stopped naturally
                final_finish_reason = finish_reason_type
                if has_tool_calls.get(idx, False) and finish_reason_type == &#34;stop&#34;:
                    final_finish_reason = &#34;tool_calls&#34;

                finish_reason_chunk = ChatCompletionStreamResponse(
                    id=content[&#34;meta_info&#34;][
                        &#34;id&#34;
                    ],  # NOTE: openai uses the same chatcmpl-id for all indices
                    created=int(time.time()),
                    choices=[
                        ChatCompletionResponseStreamChoice(
                            index=idx,
                            delta=DeltaMessage(),
                            finish_reason=final_finish_reason,
                            matched_stop=(
                                finish_reason_data[&#34;matched&#34;]
                                if &#34;matched&#34; in finish_reason_data
                                else None
                            ),
                        )
                    ],
                    model=request.model,
                    usage=None,
                )
                yield f&#34;data: {finish_reason_chunk.model_dump_json()}\n\n&#34;

            # Send hidden states if requested
            if request.return_hidden_states and hidden_states:
                for index, choice_hidden_states in hidden_states.items():
                    if choice_hidden_states:
                        last_token_hidden_states = (
                            choice_hidden_states[-1]
                            if len(choice_hidden_states) &gt; 1
                            else []
                        )
                        hidden_states_chunk = ChatCompletionStreamResponse(
                            id=content[&#34;meta_info&#34;][&#34;id&#34;],
                            created=int(time.time()),
                            choices=[
                                ChatCompletionResponseStreamChoice(
                                    index=index,
                                    delta=DeltaMessage(
                                        hidden_states=last_token_hidden_states
                                    ),
                                    finish_reason=None,  # Hidden states don&#39;t need finish_reason
                                )
                            ],
                            model=request.model,
                        )
                        yield f&#34;data: {hidden_states_chunk.model_dump_json()}\n\n&#34;

            # Additional usage chunk
            if request.stream_options and request.stream_options.include_usage:
                usage = UsageProcessor.calculate_streaming_usage(
                    prompt_tokens,
                    completion_tokens,
                    cached_tokens,
                    n_choices=request.n,
                    enable_cache_report=self.tokenizer_manager.server_args.enable_cache_report,
                )
                usage_chunk = ChatCompletionStreamResponse(
                    id=content[&#34;meta_info&#34;][&#34;id&#34;],
                    created=int(time.time()),
                    choices=[],  # Empty choices array as per OpenAI spec
                    model=request.model,
                    usage=usage,
                )
                yield f&#34;data: {usage_chunk.model_dump_json()}\n\n&#34;

        except ValueError as e:
            error = self.create_streaming_error_response(str(e))
            yield f&#34;data: {error}\n\n&#34;

        yield &#34;data: [DONE]\n\n&#34;

    async def _handle_non_streaming_request(
        self,
        adapted_request: GenerateReqInput,
        request: ChatCompletionRequest,
        raw_request: Request,
    ) -&gt; Union[ChatCompletionResponse, ErrorResponse, ORJSONResponse]:
        &#34;&#34;&#34;Handle non-streaming chat completion request&#34;&#34;&#34;
        try:
            ret = await self.tokenizer_manager.generate_request(
                adapted_request, raw_request
            ).__anext__()
        except ValueError as e:
            return self.create_error_response(str(e))

        if not isinstance(ret, list):
            ret = [ret]

        response = self._build_chat_response(
            request,
            ret,
            int(time.time()),
        )

        return response

    def _build_chat_response(
        self,
        request: ChatCompletionRequest,
        ret: List[Dict[str, Any]],
        created: int,
    ) -&gt; Union[ChatCompletionResponse, ORJSONResponse]:
        &#34;&#34;&#34;Build chat completion response from generation results&#34;&#34;&#34;
        choices = []

        for idx, ret_item in enumerate(ret):
            # Process logprobs
            choice_logprobs = None
            if request.logprobs:
                choice_logprobs = self._process_response_logprobs(ret_item)

            # Handle hidden states
            hidden_states = process_hidden_states_from_ret(ret_item, request)

            finish_reason = ret_item[&#34;meta_info&#34;][&#34;finish_reason&#34;]
            text = ret_item[&#34;text&#34;]

            # Handle reasoning content
            reasoning_text = None
            reasoning_parser = self.tokenizer_manager.server_args.reasoning_parser
            if reasoning_parser and request.separate_reasoning:
                is_force_reasoning = (
                    self.template_manager.force_reasoning
                    or self._get_enable_thinking_from_request(request)
                )
                try:
                    parser = ReasoningParser(
                        model_type=reasoning_parser,
                        stream_reasoning=False,
                        force_reasoning=is_force_reasoning,
                    )
                    reasoning_text, text = parser.parse_non_stream(text)
                except Exception as e:
                    logger.error(f&#34;Reasoning parsing error: {e}&#34;)
                    return self.create_error_response(
                        &#34;Failed to parse reasoning content&#34;,
                        err_type=&#34;InternalServerError&#34;,
                        status_code=500,
                    )

            # Handle tool calls
            tool_calls = None
            if request.tool_choice != &#34;none&#34; and request.tools:
                tool_call_parser = self.tokenizer_manager.server_args.tool_call_parser
                tool_calls, text, finish_reason = self._process_tool_calls(
                    text, request.tools, tool_call_parser, finish_reason
                )

            choice_data = ChatCompletionResponseChoice(
                index=idx,
                message=ChatMessage(
                    role=&#34;assistant&#34;,
                    content=text if text else None,
                    tool_calls=tool_calls,
                    reasoning_content=reasoning_text if reasoning_text else None,
                ),
                logprobs=choice_logprobs,
                finish_reason=finish_reason[&#34;type&#34;] if finish_reason else None,
                matched_stop=(
                    finish_reason[&#34;matched&#34;]
                    if finish_reason and &#34;matched&#34; in finish_reason
                    else None
                ),
                hidden_states=hidden_states,
            )
            choices.append(choice_data)

        # Calculate usage
        usage = UsageProcessor.calculate_response_usage(
            ret,
            n_choices=request.n,
            enable_cache_report=self.tokenizer_manager.server_args.enable_cache_report,
        )

        return ChatCompletionResponse(
            id=ret[0][&#34;meta_info&#34;][&#34;id&#34;],
            created=created,
            model=request.model,
            choices=choices,
            usage=usage,
            metadata={&#34;weight_version&#34;: ret[0][&#34;meta_info&#34;][&#34;weight_version&#34;]},
        )

    def _process_logprobs_tokens(
        self, logprobs: LogProbs, use_token_index: bool = False
    ) -&gt; List[ChatCompletionTokenLogprob]:
        &#34;&#34;&#34;Common helper to process logprobs tokens for both streaming and non-streaming

        Args:
            logprobs: LogProbs data from model
            use_token_index: True for non-streaming (use token_idx), False for streaming (use index 0)
        &#34;&#34;&#34;
        token_logprobs = []

        for token_idx, (token, logprob) in enumerate(
            zip(logprobs.tokens, logprobs.token_logprobs)
        ):
            token_bytes = list(token.encode(&#34;utf-8&#34;))
            top_logprobs = []
            if logprobs.top_logprobs:
                # - Non-streaming (use_token_index=True): uses token_idx for full data
                # - Streaming (use_token_index=False): uses index 0 for pre-sliced data
                top_logprobs_idx = token_idx if use_token_index else 0
                for top_token, top_logprob in logprobs.top_logprobs[
                    top_logprobs_idx
                ].items():
                    top_token_bytes = list(top_token.encode(&#34;utf-8&#34;))
                    top_logprobs.append(
                        TopLogprob(
                            token=top_token,
                            bytes=top_token_bytes,
                            logprob=top_logprob,
                        )
                    )
            token_logprobs.append(
                ChatCompletionTokenLogprob(
                    token=token,
                    bytes=token_bytes,
                    logprob=logprob,
                    top_logprobs=top_logprobs,
                )
            )

        return token_logprobs

    def _process_response_logprobs(self, ret_item: Dict[str, Any]) -&gt; ChoiceLogprobs:
        &#34;&#34;&#34;Process logprobs for non-streaming response&#34;&#34;&#34;
        logprobs = to_openai_style_logprobs(
            output_token_logprobs=ret_item[&#34;meta_info&#34;][&#34;output_token_logprobs&#34;],
            output_top_logprobs=ret_item[&#34;meta_info&#34;].get(&#34;output_top_logprobs&#34;, None),
        )

        token_logprobs = self._process_logprobs_tokens(logprobs, use_token_index=True)
        return ChoiceLogprobs(content=token_logprobs)

    def _process_tool_calls(
        self,
        text: str,
        tools: List[Any],
        tool_call_parser: Optional[str],
        finish_reason: Dict[str, Any],
    ) -&gt; tuple[Optional[List[ToolCall]], str, Dict[str, Any]]:
        &#34;&#34;&#34;Process tool calls in the response&#34;&#34;&#34;
        parser = FunctionCallParser(tools, tool_call_parser)
        if parser.has_tool_call(text):
            if finish_reason[&#34;type&#34;] == &#34;stop&#34;:
                finish_reason[&#34;type&#34;] = &#34;tool_calls&#34;
                finish_reason[&#34;matched&#34;] = None
            try:
                text, call_info_list = parser.parse_non_stream(text)
                tool_calls = []
                for call_info in call_info_list:
                    # For Kimi-K2, align tool_call_id with the model format: functions.{name}:{index}
                    if tool_call_parser == &#34;kimi_k2&#34; and call_info.name is not None:
                        tool_id = f&#34;functions.{call_info.name}:{call_info.tool_index}&#34;
                    else:
                        tool_id = f&#34;call_{uuid.uuid4().hex[:24]}&#34;

                    tool_calls.append(
                        ToolCall(
                            id=tool_id,
                            index=getattr(call_info, &#34;tool_index&#34;, None),
                            function=FunctionResponse(
                                name=call_info.name, arguments=call_info.parameters
                            ),
                        )
                    )
                return tool_calls, text, finish_reason
            except Exception as e:
                logger.error(f&#34;Tool call parsing error: {e}&#34;)
                # Return error but don&#39;t fail the whole request
                return None, text, finish_reason

        return None, text, finish_reason

    def _process_streaming_logprobs(
        self, content: Dict[str, Any], n_prev_token: int
    ) -&gt; ChoiceLogprobs:
        &#34;&#34;&#34;Process logprobs for streaming response&#34;&#34;&#34;
        logprobs = to_openai_style_logprobs(
            output_token_logprobs=content[&#34;meta_info&#34;][&#34;output_token_logprobs&#34;][
                n_prev_token:
            ],
            output_top_logprobs=content[&#34;meta_info&#34;].get(&#34;output_top_logprobs&#34;, [])[
                n_prev_token:
            ],
        )

        token_logprobs = self._process_logprobs_tokens(logprobs, use_token_index=False)
        return ChoiceLogprobs(content=token_logprobs)

    def _process_reasoning_stream(
        self,
        index: int,
        delta: str,
        reasoning_parser_dict: Dict[int, ReasoningParser],
        content: Dict[str, Any],
        request: ChatCompletionRequest,
    ) -&gt; tuple[Optional[str], str]:
        &#34;&#34;&#34;Process reasoning content in streaming response&#34;&#34;&#34;
        if index not in reasoning_parser_dict:
            is_force_reasoning = (
                self.template_manager.force_reasoning
                or self._get_enable_thinking_from_request(request)
            )
            reasoning_parser_dict[index] = ReasoningParser(
                self.tokenizer_manager.server_args.reasoning_parser,
                request.stream_reasoning,
                is_force_reasoning,
            )
        reasoning_parser = reasoning_parser_dict[index]
        return reasoning_parser.parse_stream_chunk(delta)

    def _get_enable_thinking_from_request(self, request: ChatCompletionRequest) -&gt; bool:
        &#34;&#34;&#34;Extracts the &#39;enable_thinking&#39; flag from request chat_template_kwargs.

        NOTE: This parameter is only useful for models that support enable_thinking
        flag, such as Qwen3.

        Args:
            request_obj: The request object (or an item from a list of requests).
        Returns:
            The boolean value of &#39;enable_thinking&#39; if found, otherwise False.
        &#34;&#34;&#34;
        if hasattr(request, &#34;chat_template_kwargs&#34;) and request.chat_template_kwargs:
            # For Qwen3 models, `enable_thinking` is supported.
            if request.chat_template_kwargs.get(&#34;enable_thinking&#34;) is not None:
                return request.chat_template_kwargs.get(&#34;enable_thinking&#34;)
            # For DeepSeek-V3.1 models, `thinking` is supported.
            elif request.chat_template_kwargs.get(&#34;thinking&#34;) is not None:
                return request.chat_template_kwargs.get(&#34;thinking&#34;)
            else:
                return False
        return False

    async def _process_tool_call_stream(
        self,
        index: int,
        delta: str,
        parser_dict: Dict[int, FunctionCallParser],
        content: Dict[str, Any],
        request: ChatCompletionRequest,
        has_tool_calls: Dict[int, bool],
    ):
        &#34;&#34;&#34;Process tool calls in streaming response&#34;&#34;&#34;
        if index not in parser_dict:
            parser_dict[index] = FunctionCallParser(
                tools=request.tools,
                tool_call_parser=self.tokenizer_manager.server_args.tool_call_parser,
            )
        parser = parser_dict[index]

        normal_text, calls = parser.parse_stream_chunk(delta)

        # Yield normal text
        if normal_text:
            choice_data = ChatCompletionResponseStreamChoice(
                index=index,
                delta=DeltaMessage(content=normal_text),
                finish_reason=None,
            )
            chunk = ChatCompletionStreamResponse(
                id=content[&#34;meta_info&#34;][&#34;id&#34;],
                created=int(time.time()),
                choices=[choice_data],
                model=request.model,
            )
            yield f&#34;data: {chunk.model_dump_json()}\n\n&#34;

        # Yield tool calls
        for call_item in calls:
            # Mark that this choice has tool calls
            has_tool_calls[index] = True

            # Tool call ID should be generated only once per tool call
            if call_item.name:
                # First chunk: include ID and function name
                if self.tokenizer_manager.server_args.tool_call_parser == &#34;kimi_k2&#34;:
                    # Align with Kimi-K2 format: functions.{name}:{index}
                    tool_call_id = f&#34;functions.{call_item.name}:{call_item.tool_index}&#34;
                else:
                    tool_call_id = f&#34;call_{uuid.uuid4().hex[:24]}&#34;
                function_name = call_item.name
            else:
                # Subsequent chunks: null ID and name for argument deltas
                tool_call_id = None
                function_name = None

            tool_call = ToolCall(
                id=tool_call_id,
                index=call_item.tool_index,
                function=FunctionResponse(
                    name=function_name,
                    arguments=call_item.parameters,
                ),
            )

            choice_data = ChatCompletionResponseStreamChoice(
                index=index,
                delta=DeltaMessage(tool_calls=[tool_call]),
                finish_reason=None,
            )
            chunk = ChatCompletionStreamResponse(
                id=content[&#34;meta_info&#34;][&#34;id&#34;],
                created=int(time.time()),
                choices=[choice_data],
                model=request.model,
            )
            yield f&#34;data: {chunk.model_dump_json()}\n\n&#34;

    def _check_for_unstreamed_tool_args(
        self,
        parser: FunctionCallParser,
        content: Dict[str, Any],
        request: ChatCompletionRequest,
        index: int,
    ) -&gt; Optional[str]:
        &#34;&#34;&#34;
        Check for any remaining tool call arguments that need to be streamed
        when generation finishes. This ensures tool calls are properly completed
        even if the model generates the final arguments in the last chunk.
        &#34;&#34;&#34;
        # Only check if we have tool calls and the parser has tracked data
        if (
            not hasattr(parser.detector, &#34;prev_tool_call_arr&#34;)
            or not parser.detector.prev_tool_call_arr
        ):
            return None

        if (
            not hasattr(parser.detector, &#34;streamed_args_for_tool&#34;)
            or not parser.detector.streamed_args_for_tool
        ):
            return None

        # Get the last tool call that was being processed
        tool_index = len(parser.detector.prev_tool_call_arr) - 1
        if tool_index &lt; 0 or tool_index &gt;= len(parser.detector.streamed_args_for_tool):
            return None

        # Get expected vs actual arguments
        expected_args = parser.detector.prev_tool_call_arr[tool_index].get(
            &#34;arguments&#34;, {}
        )
        expected_call = json.dumps(expected_args, ensure_ascii=False)
        actual_call = parser.detector.streamed_args_for_tool[tool_index]

        # Check if there are remaining arguments to send
        remaining_call = (
            expected_call.replace(actual_call, &#34;&#34;, 1)
            if actual_call in expected_call
            else &#34;&#34;
        )

        if remaining_call:
            # Create tool call chunk with remaining arguments
            tool_call = ToolCall(
                id=None,  # No ID for argument deltas
                index=tool_index,
                function=FunctionResponse(
                    name=None,  # No name for argument deltas
                    arguments=remaining_call,
                ),
            )

            choice_data = ChatCompletionResponseStreamChoice(
                index=index,
                delta=DeltaMessage(tool_calls=[tool_call]),
                finish_reason=None,  # Don&#39;t send finish_reason with this chunk
            )

            chunk = ChatCompletionStreamResponse(
                id=content[&#34;meta_info&#34;][&#34;id&#34;],
                created=int(time.time()),
                choices=[choice_data],
                model=request.model,
            )

            return f&#34;data: {chunk.model_dump_json()}\n\n&#34;

        return None</code></pre>
</details>
<div class="desc"><p>Handler for /v1/chat/completions requests</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase" href="serving_base.html#sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase">OpenAIServingBase</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sglang.srt.entrypoints.openai.serving_responses.OpenAIServingResponses" href="serving_responses.html#sglang.srt.entrypoints.openai.serving_responses.OpenAIServingResponses">OpenAIServingResponses</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase" href="serving_base.html#sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase">OpenAIServingBase</a></b></code>:
<ul class="hlist">
<li><code><a title="sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase.create_error_response" href="serving_base.html#sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase.create_error_response">create_error_response</a></code></li>
<li><code><a title="sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase.create_streaming_error_response" href="serving_base.html#sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase.create_streaming_error_response">create_streaming_error_response</a></code></li>
<li><code><a title="sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase.handle_request" href="serving_base.html#sglang.srt.entrypoints.openai.serving_base.OpenAIServingBase.handle_request">handle_request</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.srt.entrypoints.openai" href="index.html">sglang.srt.entrypoints.openai</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.srt.entrypoints.openai.serving_chat.OpenAIServingChat" href="#sglang.srt.entrypoints.openai.serving_chat.OpenAIServingChat">OpenAIServingChat</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
