<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>sglang.lang.interpreter API documentation</title>
<meta name="description" content="The interpreter that executes SGL programs">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sglang.lang.interpreter</code></h1>
</header>
<section id="section-intro">
<p>The interpreter that executes SGL programs</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sglang.lang.interpreter.cache_program"><code class="name flex">
<span>def <span class="ident">cache_program</span></span>(<span>program, backend)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_program(program, backend):
    from sglang.lang.tracer import extract_prefix_by_tracing

    prefix = extract_prefix_by_tracing(program, backend)
    if prefix and len(prefix) &gt; 64:
        backend.cache_prefix(prefix)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.run_internal"><code class="name flex">
<span>def <span class="ident">run_internal</span></span>(<span>state, program, func_args, func_kwargs, sync)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_internal(state, program, func_args, func_kwargs, sync):
    try:
        state.ret_value = program.func(state, *func_args, **func_kwargs)
    except Exception as e:
        raise e
    finally:
        state.stream_executor.end()

    if sync:
        state.stream_executor.sync()

    if global_config.verbosity &gt;= 2:
        print(state.text())</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.run_program"><code class="name flex">
<span>def <span class="ident">run_program</span></span>(<span>program,<br>backend,<br>func_args,<br>func_kwargs,<br>default_sampling_para,<br>stream,<br>sync=False,<br>use_thread=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_program(
    program,
    backend,
    func_args,
    func_kwargs,
    default_sampling_para,
    stream,
    sync=False,
    use_thread=True,
):
    if hasattr(backend, &#34;endpoint&#34;):
        backend = backend.endpoint
    assert backend is not None, &#34;Please specify a backend&#34;
    func_kwargs.update(program.bind_arguments)
    stream_executor = StreamExecutor(
        backend,
        func_kwargs,
        default_sampling_para,
        chat_template=None,
        stream=stream,
        num_api_spec_tokens=program.num_api_spec_tokens,
        use_thread=use_thread,
    )
    state = ProgramState(stream_executor)

    if stream:
        t = threading.Thread(
            target=run_internal, args=(state, program, func_args, func_kwargs, sync)
        )
        t.start()
        return state
    else:
        run_internal(state, program, func_args, func_kwargs, sync)
        return state</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.run_program_batch"><code class="name flex">
<span>def <span class="ident">run_program_batch</span></span>(<span>program,<br>backend,<br>batch_arguments,<br>default_sampling_para,<br>num_threads,<br>progress_bar,<br>generator_style=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_program_batch(
    program,
    backend,
    batch_arguments,
    default_sampling_para,
    num_threads,
    progress_bar,
    generator_style=False,
):
    if hasattr(backend, &#34;endpoint&#34;):
        backend = backend.endpoint

    # Pre-cache the common prefix for a batch. The prefix is extracted by tracing the program.
    if global_config.enable_precache_with_tracing and len(batch_arguments) &gt; 1:
        cache_program(program, backend)

    # Run all programs
    if num_threads == &#34;auto&#34;:
        num_threads = max(96, multiprocessing.cpu_count() * 16)
    num_threads = min(num_threads, len(batch_arguments))

    if generator_style:
        return _run_program_batch_generator(
            program,
            backend,
            batch_arguments,
            default_sampling_para,
            num_threads,
            progress_bar,
        )

    # Original code path when generator_style=False
    if num_threads == 1:
        rets = []
        if progress_bar:
            for arguments in tqdm.tqdm(batch_arguments):
                rets.append(
                    run_program(
                        program,
                        backend,
                        (),
                        arguments,
                        default_sampling_para,
                        False,
                        True,
                    )
                )
        else:
            for arguments in batch_arguments:
                rets.append(
                    run_program(
                        program,
                        backend,
                        (),
                        arguments,
                        default_sampling_para,
                        False,
                        True,
                    )
                )
    else:
        if progress_bar:
            pbar = tqdm.tqdm(total=len(batch_arguments))

        with ThreadPoolExecutor(num_threads) as executor:
            futures = []
            for arguments in batch_arguments:
                futures.append(
                    executor.submit(
                        run_program,
                        program,
                        backend,
                        (),
                        arguments,
                        default_sampling_para,
                        False,
                        True,
                    )
                )
                if progress_bar:
                    futures[-1].add_done_callback(lambda _: pbar.update())

            rets = [f.result() for f in futures]
        rets[-1].sync()

        if progress_bar:
            pbar.close()

    return rets</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sglang.lang.interpreter.ProgramState"><code class="flex name class">
<span>class <span class="ident">ProgramState</span></span>
<span>(</span><span>stream_executor: <a title="sglang.lang.interpreter.StreamExecutor" href="#sglang.lang.interpreter.StreamExecutor">StreamExecutor</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgramState:
    &#34;&#34;&#34;The state of an SGL program.&#34;&#34;&#34;

    def __init__(self, stream_executor: StreamExecutor):
        self.stream_executor = stream_executor

    def _role_common(self, name: str, expr: Optional[SglExpr] = None):
        if expr is not None:
            role_expr = SglExprList([SglRoleBegin(name), expr, SglRoleEnd(name)])
            self.stream_executor.submit(role_expr)
            return role_expr
        else:

            @contextmanager
            def role_scope():
                self.stream_executor.submit(SglRoleBegin(name))
                yield
                self.stream_executor.submit(SglRoleEnd(name))

            return role_scope()

    def system(self, expr: Optional[SglExpr] = None):
        return self._role_common(&#34;system&#34;, expr)

    def user(self, expr: Optional[SglExpr] = None):
        return self._role_common(&#34;user&#34;, expr)

    def assistant(self, expr: Optional[SglExpr] = None):
        return self._role_common(&#34;assistant&#34;, expr)

    @contextmanager
    def var_scope(self, name: str):
        self.stream_executor.submit(SglVarScopeBegin(name))
        yield
        self.stream_executor.submit(SglVarScopeEnd(name))

    def fork(
        self,
        size: int = 1,
        position_ids_offset: Optional[List[int]] = None,
    ):
        stream_executors = self.stream_executor.fork(size, position_ids_offset)
        states = [ProgramState(x) for x in stream_executors]
        state_group = ProgramStateGroup(states, self)
        return state_group

    @contextmanager
    def copy(self, position_ids_offset: Optional[List[int]] = None):
        state_group = self.fork(1, position_ids_offset)
        try:
            yield state_group[0]
        finally:
            state_group.join()

    def text(self):
        return self.stream_executor.text()

    def messages(self):
        return self.stream_executor.messages()

    def sync(self):
        return self.stream_executor.sync()

    def error(self):
        return self.stream_executor.error()

    def text_iter(self, var_name: Optional[str] = None):
        if self.stream_executor.stream:
            prev = 0
            if var_name is None:
                event = self.stream_executor.stream_text_event
                while True:
                    event.wait()
                    event.clear()
                    out = str(self.stream_executor.text_[prev:])
                    prev += len(out)
                    if out:
                        yield out
                    if self.stream_executor.is_finished:
                        break
            else:
                event = None
                while not event:
                    if var_name in self.stream_executor.stream_var_event:
                        event = self.stream_executor.stream_var_event[var_name]
                    if self.stream_executor.is_finished:
                        yield &#34;&#34;
                        return

                while True:
                    event.wait()
                    event.clear()
                    out = str(self.stream_executor.variables[var_name][prev:])
                    prev += len(out)
                    if out:
                        yield out
                    if self.stream_executor.variable_event[var_name].is_set():
                        break
        else:
            if var_name is None:
                yield self.text()
            else:
                yield self.get_var(var_name)

    async def text_async_iter(
        self, var_name: Optional[str] = None, return_meta_data: bool = False
    ):
        loop = asyncio.get_running_loop()

        if self.stream_executor.stream:
            prev = 0
            if var_name is None:
                event = self.stream_executor.stream_text_event
                while True:
                    await loop.run_in_executor(None, event.wait)
                    event.clear()
                    out = str(self.stream_executor.text_[prev:])
                    prev += len(out)
                    if out:
                        yield out
                    if self.stream_executor.is_finished:
                        break
            else:
                event = None
                while not event:
                    if var_name in self.stream_executor.stream_var_event:
                        event = self.stream_executor.stream_var_event[var_name]
                    if self.stream_executor.is_finished:
                        yield &#34;&#34;
                        return

                while True:
                    await loop.run_in_executor(None, event.wait)
                    event.clear()
                    out = str(self.stream_executor.variables[var_name][prev:])
                    prev += len(out)
                    if out:
                        if return_meta_data:
                            yield out, self.stream_executor.meta_info[var_name]
                        else:
                            yield out
                    if self.stream_executor.variable_event[var_name].is_set():
                        break
        else:
            if var_name is None:
                yield self.text()
            else:
                yield self.get_var(var_name)

    def get_var(self, name):
        return self.stream_executor.get_var(name)

    def set_var(self, name, value):
        return self.stream_executor.set_var(name, value)

    def get_meta_info(self, name):
        return self.stream_executor.get_meta_info(name)

    def __iadd__(self, other):
        if other is None:
            raise ValueError(&#34;Tried to append None to state.&#34;)
        self.stream_executor.submit(other)
        return self

    def __getitem__(self, name):
        return self.get_var(name)

    def __setitem__(self, name, value):
        self.set_var(name, value)

    def __contains__(self, name):
        return name in self.stream_executor.variables

    def __del__(self):
        self.stream_executor.end()

    def __repr__(self) -&gt; str:
        return f&#34;ProgramState({self.text()})&#34;</code></pre>
</details>
<div class="desc"><p>The state of an SGL program.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sglang.lang.tracer.TracerProgramState" href="tracer.html#sglang.lang.tracer.TracerProgramState">TracerProgramState</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="sglang.lang.interpreter.ProgramState.assistant"><code class="name flex">
<span>def <span class="ident">assistant</span></span>(<span>self,<br>expr: <a title="sglang.lang.ir.SglExpr" href="ir.html#sglang.lang.ir.SglExpr">SglExpr</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assistant(self, expr: Optional[SglExpr] = None):
    return self._role_common(&#34;assistant&#34;, expr)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self, position_ids_offset: List[int] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def copy(self, position_ids_offset: Optional[List[int]] = None):
    state_group = self.fork(1, position_ids_offset)
    try:
        yield state_group[0]
    finally:
        state_group.join()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(self):
    return self.stream_executor.error()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.fork"><code class="name flex">
<span>def <span class="ident">fork</span></span>(<span>self, size: int = 1, position_ids_offset: List[int] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fork(
    self,
    size: int = 1,
    position_ids_offset: Optional[List[int]] = None,
):
    stream_executors = self.stream_executor.fork(size, position_ids_offset)
    states = [ProgramState(x) for x in stream_executors]
    state_group = ProgramStateGroup(states, self)
    return state_group</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.get_meta_info"><code class="name flex">
<span>def <span class="ident">get_meta_info</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_meta_info(self, name):
    return self.stream_executor.get_meta_info(name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.get_var"><code class="name flex">
<span>def <span class="ident">get_var</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var(self, name):
    return self.stream_executor.get_var(name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.messages"><code class="name flex">
<span>def <span class="ident">messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def messages(self):
    return self.stream_executor.messages()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.set_var"><code class="name flex">
<span>def <span class="ident">set_var</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_var(self, name, value):
    return self.stream_executor.set_var(name, value)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    return self.stream_executor.sync()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.system"><code class="name flex">
<span>def <span class="ident">system</span></span>(<span>self,<br>expr: <a title="sglang.lang.ir.SglExpr" href="ir.html#sglang.lang.ir.SglExpr">SglExpr</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system(self, expr: Optional[SglExpr] = None):
    return self._role_common(&#34;system&#34;, expr)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(self):
    return self.stream_executor.text()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.text_async_iter"><code class="name flex">
<span>async def <span class="ident">text_async_iter</span></span>(<span>self, var_name: str | None = None, return_meta_data: bool = False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def text_async_iter(
    self, var_name: Optional[str] = None, return_meta_data: bool = False
):
    loop = asyncio.get_running_loop()

    if self.stream_executor.stream:
        prev = 0
        if var_name is None:
            event = self.stream_executor.stream_text_event
            while True:
                await loop.run_in_executor(None, event.wait)
                event.clear()
                out = str(self.stream_executor.text_[prev:])
                prev += len(out)
                if out:
                    yield out
                if self.stream_executor.is_finished:
                    break
        else:
            event = None
            while not event:
                if var_name in self.stream_executor.stream_var_event:
                    event = self.stream_executor.stream_var_event[var_name]
                if self.stream_executor.is_finished:
                    yield &#34;&#34;
                    return

            while True:
                await loop.run_in_executor(None, event.wait)
                event.clear()
                out = str(self.stream_executor.variables[var_name][prev:])
                prev += len(out)
                if out:
                    if return_meta_data:
                        yield out, self.stream_executor.meta_info[var_name]
                    else:
                        yield out
                if self.stream_executor.variable_event[var_name].is_set():
                    break
    else:
        if var_name is None:
            yield self.text()
        else:
            yield self.get_var(var_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.text_iter"><code class="name flex">
<span>def <span class="ident">text_iter</span></span>(<span>self, var_name: str | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text_iter(self, var_name: Optional[str] = None):
    if self.stream_executor.stream:
        prev = 0
        if var_name is None:
            event = self.stream_executor.stream_text_event
            while True:
                event.wait()
                event.clear()
                out = str(self.stream_executor.text_[prev:])
                prev += len(out)
                if out:
                    yield out
                if self.stream_executor.is_finished:
                    break
        else:
            event = None
            while not event:
                if var_name in self.stream_executor.stream_var_event:
                    event = self.stream_executor.stream_var_event[var_name]
                if self.stream_executor.is_finished:
                    yield &#34;&#34;
                    return

            while True:
                event.wait()
                event.clear()
                out = str(self.stream_executor.variables[var_name][prev:])
                prev += len(out)
                if out:
                    yield out
                if self.stream_executor.variable_event[var_name].is_set():
                    break
    else:
        if var_name is None:
            yield self.text()
        else:
            yield self.get_var(var_name)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.user"><code class="name flex">
<span>def <span class="ident">user</span></span>(<span>self,<br>expr: <a title="sglang.lang.ir.SglExpr" href="ir.html#sglang.lang.ir.SglExpr">SglExpr</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user(self, expr: Optional[SglExpr] = None):
    return self._role_common(&#34;user&#34;, expr)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.ProgramState.var_scope"><code class="name flex">
<span>def <span class="ident">var_scope</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def var_scope(self, name: str):
    self.stream_executor.submit(SglVarScopeBegin(name))
    yield
    self.stream_executor.submit(SglVarScopeEnd(name))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sglang.lang.interpreter.ProgramStateGroup"><code class="flex name class">
<span>class <span class="ident">ProgramStateGroup</span></span>
<span>(</span><span>states: List[<a title="sglang.lang.interpreter.ProgramState" href="#sglang.lang.interpreter.ProgramState">ProgramState</a>],<br>src_state: <a title="sglang.lang.interpreter.ProgramState" href="#sglang.lang.interpreter.ProgramState">ProgramState</a> | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgramStateGroup:
    def __init__(
        self, states: List[ProgramState], src_state: Optional[ProgramState] = None
    ):
        self.states = states
        self.src_state = src_state

    def join(self, mode: str = &#34;gather_variable&#34;):
        if mode == &#34;gather_variable&#34;:
            # Copy variables back
            src_vars = self.src_state.stream_executor.variables
            src_var_set = set(src_vars.keys())
            for child_state in self.states:
                child_state.stream_executor.sync()
                child_vars = child_state.stream_executor.variables
                new_vars = set(child_vars.keys()) - src_var_set

                for k in new_vars:
                    if k in src_vars:
                        src_vars[k].append(child_vars[k])
                    else:
                        src_vars[k] = [child_vars[k]]
        elif mode == &#34;concate_and_append&#34;:
            # Concatenate and append KV cache
            self.src_state += SglConcateAndAppend(self.states)
            # Need a sync here. Otherwise, `states` can be deleted.
            self.src_state.stream_executor.sync()
        else:
            raise ValueError(f&#34;Invalid join mode: {mode}&#34;)

        for s in self.states:
            s.stream_executor.end()

    def __getitem__(self, i: int):
        return self.states[i]

    def __setitem__(self, i: int, value):
        assert self.states[i] == value

    def __iadd__(self, other):
        if isinstance(other, Callable):
            # lambda function
            for i in range(len(self.states)):
                self.states[i] += other(i)
        elif isinstance(other, SglExpr):
            for i in range(len(self.states)):
                self.states[i] += other
        elif isinstance(other, (list, tuple)):
            for i in range(len(self.states)):
                self.states[i] += other[i]
        else:
            raise ValueError(f&#34;Invalid value: {other}&#34;)

        return self</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="sglang.lang.interpreter.ProgramStateGroup.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, mode: str = 'gather_variable')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, mode: str = &#34;gather_variable&#34;):
    if mode == &#34;gather_variable&#34;:
        # Copy variables back
        src_vars = self.src_state.stream_executor.variables
        src_var_set = set(src_vars.keys())
        for child_state in self.states:
            child_state.stream_executor.sync()
            child_vars = child_state.stream_executor.variables
            new_vars = set(child_vars.keys()) - src_var_set

            for k in new_vars:
                if k in src_vars:
                    src_vars[k].append(child_vars[k])
                else:
                    src_vars[k] = [child_vars[k]]
    elif mode == &#34;concate_and_append&#34;:
        # Concatenate and append KV cache
        self.src_state += SglConcateAndAppend(self.states)
        # Need a sync here. Otherwise, `states` can be deleted.
        self.src_state.stream_executor.sync()
    else:
        raise ValueError(f&#34;Invalid join mode: {mode}&#34;)

    for s in self.states:
        s.stream_executor.end()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor"><code class="flex name class">
<span>class <span class="ident">StreamExecutor</span></span>
<span>(</span><span>backend,<br>arguments,<br>default_sampling_para,<br>chat_template,<br>stream,<br>num_api_spec_tokens=None,<br>use_thread=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamExecutor:
    &#34;&#34;&#34;A stream executor that executes SGL expressions in a background thread.&#34;&#34;&#34;

    def __init__(
        self,
        backend,
        arguments,
        default_sampling_para,
        chat_template,
        stream,
        num_api_spec_tokens=None,
        use_thread=True,
    ):
        from sglang.lang.backend.base_backend import BaseBackend

        self.sid = uuid.uuid4().hex
        self.backend: BaseBackend = backend
        self.arguments: Dict[str, Any] = arguments
        self.default_sampling_para = default_sampling_para
        self.stream = stream

        self.variables = {}  # Dict[name: str -&gt; value: str]
        self.variable_event = {}  # Dict[name: str -&gt; event: threading.Event]
        self.meta_info = {}  # Dict[name: str -&gt; info: str]
        self.is_finished = False
        self.error_ = None

        # For completion
        self.text_ = &#34;&#34;  # The full text

        # For chat
        self.messages_ = []  # The messages in the OpenAI API format
        self.chat_template = chat_template or self.backend.get_chat_template()
        self.cur_role = None
        self.cur_role_begin_pos = None

        # For vision
        self.images_ = []
        self.cur_images = []

        # For fork/join
        self.fork_start_text_pos = None

        # For speculative execution
        self.num_api_spec_tokens = num_api_spec_tokens
        self.speculated_text = &#34;&#34;

        # Worker thread
        self.use_thread = use_thread
        if self.use_thread:
            self.queue = queue.Queue()

            def _run_worker_in_context():
                self._thread_worker_func()

            self.worker = threading.Thread(
                target=contextvars.copy_context().run, args=(_run_worker_in_context,)
            )
            self.worker.start()

        # For streaming
        if stream:
            self.stream_text_event = threading.Event()
            self.stream_var_event = {}
        else:
            self.stream_text_event = None
            self.stream_var_event = None

    def submit(self, expr: SglExpr):
        self._init_var_event(expr)

        if self.use_thread:
            self.queue.put(expr)
        else:
            self._execute(expr)

    def sync(self):
        if self.use_thread:
            self.queue.join()

    def get_var(self, name):
        if name in self.variable_event:
            self.variable_event[name].wait()
        return self.variables[name]

    def set_var(self, name, value):
        self.variables[name] = value

    def get_meta_info(self, name, timeout=None):
        if name in self.variable_event:
            got = self.variable_event[name].wait(timeout)
            if not got:
                raise TimeoutError(f&#34;Timeout while waiting for event &#39;{name}&#39;&#34;)
        ret = self.meta_info.get(name, None)
        return ret

    def fork(
        self,
        size: int = 1,
        position_ids_offset: Optional[List[int]] = None,
    ):
        if size &gt; 1 and str(self.text_):
            self.submit(SglCommitLazy())

        self.sync()
        size = int(size)

        exes = [
            StreamExecutor(
                self.backend,
                self.arguments,
                self.default_sampling_para,
                self.chat_template,
                self.stream,
            )
            for _ in range(size)
        ]
        for i in range(size):
            exes[i].variables = dict(self.variables)
            exes[i].text_ = str(self.text_)
            exes[i].messages_ = list(self.messages_)
            exes[i].cur_role = self.cur_role
            exes[i].cur_role_begin_pos = self.cur_role_begin_pos
            exes[i].fork_start_text_pos = len(self.text_)
            exes[i].images_ = list(self.images_)

            # TODO(ying): handle API speculative execution

        return exes

    def text(self):
        self.sync()
        return self.text_

    def messages(self):
        self.sync()
        return self.messages_

    def error(self):
        self.sync()
        return self.error_

    def end(self):
        if self.use_thread:
            if self.worker.is_alive():
                self.queue.put(None)
        self.backend.end_program(self)

    def _thread_worker_func(self):
        error = None

        while True:
            expr = self.queue.get()
            if expr is None:
                self.queue.task_done()
                break

            try:
                self._execute(expr)
            except Exception as e:
                warnings.warn(f&#34;Error in stream_executor: {get_exception_traceback()}&#34;)
                error = e
                break
            self.queue.task_done()
            if self.stream_text_event:
                self.stream_text_event.set()

        # Clean the queue and events
        if error is not None:
            try:
                while True:
                    self.queue.task_done()
                    self.queue.get_nowait()
            except queue.Empty:
                pass
            for name in self.variable_event:
                self.variable_event[name].set()
            if self.stream_var_event:
                for name in self.stream_var_event:
                    self.stream_var_event[name].set()
            self.error_ = error

        if self.stream_text_event:
            self.stream_text_event.set()

        self.is_finished = True

    def _execute(self, other):
        if isinstance(other, str):
            other = SglConstantText(other)

        assert isinstance(other, SglExpr), f&#34;{other}&#34;

        if isinstance(other, SglConstantText):
            self._execute_fill(other.value)
        elif isinstance(other, SglGen):
            self._execute_gen(other)
        elif isinstance(other, SglSelect):
            self._execute_select(other)
        elif isinstance(other, SglExprList):
            for x in other.expr_list:
                self._execute(x)
        elif isinstance(other, SglRoleBegin):
            self._execute_role_begin(other)
        elif isinstance(other, SglRoleEnd):
            self._execute_role_end(other)
        elif isinstance(other, SglImage):
            self._execute_image(other)
        elif isinstance(other, SglVideo):
            self._execute_video(other)
        elif isinstance(other, SglVariable):
            self._execute_variable(other)
        elif isinstance(other, SglVarScopeBegin):
            self._execute_var_scope_begin(other)
        elif isinstance(other, SglVarScopeEnd):
            self._execute_var_scope_end(other)
        elif isinstance(other, SglCommitLazy):
            self._execute_commit_lazy_operations(other)
        elif isinstance(other, SglConcateAndAppend):
            if (
                global_config.enable_parallel_encoding
                and self.backend.support_concate_and_append
            ):
                self._execute_concatenate_and_append_kv_cache(other)
            else:
                self._execute_concatenate_and_append_text(other)
        elif isinstance(other, SglSeparateReasoning):
            self._execute_separate_reasoning(other)
        else:
            raise ValueError(f&#34;Unknown type: {type(other)}&#34;)

    def _execute_fill(self, value: str, prefix=False):
        value = str(value)

        if (
            self.cur_role == &#34;assistant&#34;
            and self.num_api_spec_tokens is not None
            and self.backend.is_chat_model
            and not prefix
        ):
            self.backend.spec_fill(value)
            return

        if self.speculated_text.startswith(value):
            self.speculated_text = self.speculated_text[len(value) :]
        else:
            self.speculated_text = &#34;&#34;

        self.text_ += value

    def _execute_image(self, expr: SglImage):
        path = expr.path

        base64_data = encode_image_base64(path)

        self.images_.append((path, base64_data))
        self.cur_images.append((path, base64_data))
        self.text_ += self.chat_template.image_token

    def _execute_video(self, expr: SglVideo):
        path = expr.path
        num_frames = expr.num_frames

        base64_data = encode_video_base64(path, num_frames)

        self.images_.append((path, base64_data))
        self.cur_images.append((path, base64_data))
        self.text_ += self.chat_template.image_token

    def _spec_gen(self, sampling_params):
        stop = sampling_params.stop
        max_new_tokens = sampling_params.max_new_tokens
        meta_info = {}

        def regen():
            nonlocal meta_info

            sampling_params.max_new_tokens = max(
                sampling_params.max_new_tokens, self.num_api_spec_tokens
            )
            sampling_params.stop = None
            self.speculated_text, meta_info = self.backend.generate(
                self, sampling_params=sampling_params
            )

        def find_stop():
            if isinstance(stop, str):
                return self.speculated_text.find(stop)
            elif isinstance(stop, (tuple, list)):
                pos = -1
                for stop_str in stop:
                    stop_pos = self.speculated_text.find(stop_str)
                    if stop_pos != -1 and (pos == -1 or stop_pos &lt; pos):
                        pos = stop_pos
                return pos
            else:
                raise Exception(&#34;Wrong type of stop in sampling parameters.&#34;)

        if stop is None:
            if len(self.speculated_text) &lt; max_new_tokens:
                regen()
            comp = self.speculated_text[:max_new_tokens]
            self.speculated_text = self.speculated_text[max_new_tokens:]
        elif isinstance(stop, (str, list, tuple)):
            if self.speculated_text == &#34;&#34;:
                regen()
            stop_pos = find_stop()
            if stop_pos == -1:
                stop_pos = min(
                    sampling_params.max_new_tokens,
                    len(self.speculated_text),
                )
            comp = self.speculated_text[:stop_pos]
            self.speculated_text = self.speculated_text[stop_pos:]
        else:
            raise ValueError(&#34;Wrong type of stop in sampling parameters.&#34;)

        return comp, meta_info

    def _execute_gen(self, expr: SglGen):
        sampling_params = self._resolve_sampling_params(expr.sampling_params)
        name = expr.name
        if not self.stream:
            if self.num_api_spec_tokens is None:
                comp, meta_info = self.backend.generate(
                    self,
                    sampling_params=sampling_params,
                )

            else:
                if self.backend.is_chat_model:
                    # Speculative execution on models with only chat interface.
                    # Store the calls into a temporary list.
                    # They will be lazily executed later.
                    comp, meta_info = self.backend.generate(
                        self,
                        sampling_params=sampling_params,
                        spec_var_name=name,
                    )
                    return

                else:  # Speculative execution on models with completion interface
                    comp, meta_info = self._spec_gen(sampling_params)
            if isinstance(comp, list):
                self.text_ += comp[0]
            else:
                assert isinstance(comp, str)
                self.text_ += comp

            self.variables[name] = comp
            self.meta_info[name] = meta_info
            self.variable_event[name].set()
        else:
            assert (
                self.num_api_spec_tokens is None
            ), &#34;stream is not supported with api speculative execution&#34;
            generator = self.backend.generate_stream(
                self, sampling_params=sampling_params
            )

            self.variables[name] = &#34;&#34;
            self.stream_var_event[name].set()

            for comp, meta_info in generator:
                self.text_ += comp
                self.variables[name] += comp
                self.meta_info[name] = meta_info
                self.stream_var_event[name].set()
                self.stream_text_event.set()

            self.variable_event[name].set()
            self.stream_var_event[name].set()

    def _execute_select(self, expr: SglSelect):
        choices_decision = self.backend.select(
            self, expr.choices, expr.temperature, expr.choices_method
        )
        if expr.name is not None:
            name = expr.name
            self.variables[name] = choices_decision.decision
            self.meta_info[name] = choices_decision.meta_info
            self.variable_event[name].set()
            if self.stream_var_event:
                self.stream_var_event[name].set()
        self.text_ += choices_decision.decision

    def _execute_variable(self, expr: SglVariable):
        src_executor = expr.source_stream_executor
        value = src_executor.get_var(expr.name)
        self._execute_fill(value)

    def _execute_role_begin(self, expr: SglRoleBegin):
        assert self.cur_role is None, &#34;Nested roles are not allowed.&#34;

        if len(self.messages_) == 0 and expr.role != &#34;system&#34;:
            # Insert the default system message
            default_system = self.chat_template.default_system_prompt
            if default_system:
                self._execute_role_begin(SglRoleBegin(&#34;system&#34;))
                self._execute_fill(default_system)
                self._execute_role_end(SglRoleEnd(&#34;system&#34;))

        self.cur_role = expr.role

        prefix, _ = self.chat_template.get_prefix_and_suffix(expr.role, self.messages_)

        self._execute_fill(prefix, prefix=True)
        self.cur_role_begin_pos = len(self.text_)

    def _execute_role_end(self, expr: SglRoleEnd):
        if (
            self.cur_role == &#34;assistant&#34;
            and self.num_api_spec_tokens is not None
            and self.backend.is_chat_model
        ):
            # Execute the stored lazy generation calls
            self.backend.role_end_generate(self)
        self.cur_role = None

        new_text = self.text_[self.cur_role_begin_pos :].lstrip()

        _, suffix = self.chat_template.get_prefix_and_suffix(expr.role, self.messages_)
        self._execute_fill(suffix)

        if self.cur_images:
            # OpenAI vision API format
            last_msg = {
                &#34;role&#34;: expr.role,
                &#34;content&#34;: [{&#34;type&#34;: &#34;text&#34;, &#34;text&#34;: new_text}],
            }
            for image_path, image_base64_data in self.cur_images:
                last_msg[&#34;content&#34;].append(
                    {
                        &#34;type&#34;: &#34;image_url&#34;,
                        &#34;image_url&#34;: {
                            &#34;url&#34;: f&#34;data:image/jpeg;base64,{image_base64_data}&#34;
                        },
                    }
                )
            self.messages_.append(last_msg)
            self.cur_images = []
        else:
            # OpenAI chat API format
            self.messages_.append({&#34;role&#34;: expr.role, &#34;content&#34;: new_text})

    def _execute_var_scope_begin(self, expr: SglVarScopeBegin):
        self.variables[expr.name] = int(len(self.text_))

    def _execute_var_scope_end(self, expr: SglVarScopeEnd):
        self.variables[expr.name] = self.text_[self.variables[expr.name] :]
        self.variable_event[expr.name].set()

    def _execute_commit_lazy_operations(self, expr: SglCommitLazy):
        self.backend.commit_lazy_operations(self)

    def _execute_concatenate_and_append_text(self, expr: SglConcateAndAppend):
        new_text = &#34;&#34;
        for s in expr.states:
            exe = s.stream_executor
            exe.sync()
            new_text += exe.text_[exe.fork_start_text_pos :]

        self._execute_fill(new_text)

    def _execute_concatenate_and_append_kv_cache(self, expr: SglConcateAndAppend):
        self_len = len(self.text_)

        for i, s in enumerate(expr.states):
            exe = s.stream_executor
            exe.submit(SglCommitLazy())

        for i, s in enumerate(expr.states):
            exe = s.stream_executor
            exe.sync()
            assert exe.fork_start_text_pos == self_len
            self.text_ += exe.text_[exe.fork_start_text_pos :]

        src_rids = [state.stream_executor.sid for state in expr.states]
        self.backend.concatenate_and_append(src_rids, self.sid)

    def _execute_separate_reasoning(self, expr: SglSeparateReasoning):
        if self.stream:
            # separate reasoning for stream is not supported
            return

        if (
            self.cur_role == &#34;assistant&#34;
            and self.num_api_spec_tokens is not None
            and self.backend.is_chat_model
        ):
            # Execute the stored lazy generation calls
            self.backend.role_end_generate(self)

        from sglang.srt.reasoning_parser import ReasoningParser

        reasoning_parser = ReasoningParser(expr.model_type)
        other = expr.expr
        if not other:
            return
        elif isinstance(other, SglGen) or isinstance(other, SglSelect):
            cur_text = self.get_var(other.name)
            reasoning, normal_text = reasoning_parser.parse_non_stream(cur_text)
            reasoning_name = expr.process_name_for_reasoning(other.name)
            self.set_var(other.name, normal_text)
            self.set_var(reasoning_name, reasoning)
            # the variable is ready to be used
            self.variable_event[reasoning_name].set()
            self.text_ = self.text_[: self.cur_role_begin_pos] + normal_text
        elif isinstance(other, SglExprList):
            for x in other.expr_list:
                self._execute_separate_reasoning(
                    SglSeparateReasoning(expr.model_type, x)
                )

    def _init_var_event(self, expr):
        if isinstance(
            expr, (SglGen, SglSelect, SglVarScopeBegin, SglSeparateReasoning)
        ):
            self.variable_event[expr.name] = threading.Event()
            if self.stream:
                self.stream_var_event[expr.name] = threading.Event()
        elif isinstance(expr, SglExprList):
            for e in expr.expr_list:
                self._init_var_event(e)

    def _resolve_sampling_params(self, sampling_params):
        &#34;&#34;&#34;
        Construct sampling param based on default + override values

        The default values of sampling are populated in `default_sampling_para` via sgl.function.run(...sampling_args)
        , and `sampling_params` contains the override values from sgl.gen().

        Here we use default_sampling_para as the base and override the values if they exist in `sampling_params`.
        It also extends the stop tokens based on the chat template.
        &#34;&#34;&#34;

        # deepcopy is required because the dict has lists inside
        clone = copy.deepcopy(self.default_sampling_para)

        for item in [
            &#34;max_new_tokens&#34;,
            &#34;min_new_tokens&#34;,
            &#34;n&#34;,
            &#34;stop&#34;,
            &#34;stop_token_ids&#34;,
            &#34;temperature&#34;,
            &#34;top_p&#34;,
            &#34;top_k&#34;,
            &#34;min_p&#34;,
            &#34;frequency_penalty&#34;,
            &#34;presence_penalty&#34;,
            &#34;ignore_eos&#34;,
            &#34;return_logprob&#34;,
            &#34;logprob_start_len&#34;,
            &#34;top_logprobs_num&#34;,
            &#34;return_text_in_logprobs&#34;,
            &#34;dtype&#34;,
            &#34;regex&#34;,
            &#34;json_schema&#34;,
        ]:
            value = getattr(sampling_params, item, None)
            if value is not None:
                setattr(clone, item, value)

        if self.chat_template.stop_str:
            if clone.stop == ():
                clone.stop = []
            elif isinstance(clone.stop, str):
                clone.stop = [clone.stop]
            clone.stop += self.chat_template.stop_str

        return clone

    def __del__(self):
        self.end()</code></pre>
</details>
<div class="desc"><p>A stream executor that executes SGL expressions in a background thread.</p></div>
<h3>Methods</h3>
<dl>
<dt id="sglang.lang.interpreter.StreamExecutor.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(self):
    if self.use_thread:
        if self.worker.is_alive():
            self.queue.put(None)
    self.backend.end_program(self)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(self):
    self.sync()
    return self.error_</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.fork"><code class="name flex">
<span>def <span class="ident">fork</span></span>(<span>self, size: int = 1, position_ids_offset: List[int] | None = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fork(
    self,
    size: int = 1,
    position_ids_offset: Optional[List[int]] = None,
):
    if size &gt; 1 and str(self.text_):
        self.submit(SglCommitLazy())

    self.sync()
    size = int(size)

    exes = [
        StreamExecutor(
            self.backend,
            self.arguments,
            self.default_sampling_para,
            self.chat_template,
            self.stream,
        )
        for _ in range(size)
    ]
    for i in range(size):
        exes[i].variables = dict(self.variables)
        exes[i].text_ = str(self.text_)
        exes[i].messages_ = list(self.messages_)
        exes[i].cur_role = self.cur_role
        exes[i].cur_role_begin_pos = self.cur_role_begin_pos
        exes[i].fork_start_text_pos = len(self.text_)
        exes[i].images_ = list(self.images_)

        # TODO(ying): handle API speculative execution

    return exes</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.get_meta_info"><code class="name flex">
<span>def <span class="ident">get_meta_info</span></span>(<span>self, name, timeout=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_meta_info(self, name, timeout=None):
    if name in self.variable_event:
        got = self.variable_event[name].wait(timeout)
        if not got:
            raise TimeoutError(f&#34;Timeout while waiting for event &#39;{name}&#39;&#34;)
    ret = self.meta_info.get(name, None)
    return ret</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.get_var"><code class="name flex">
<span>def <span class="ident">get_var</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_var(self, name):
    if name in self.variable_event:
        self.variable_event[name].wait()
    return self.variables[name]</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.messages"><code class="name flex">
<span>def <span class="ident">messages</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def messages(self):
    self.sync()
    return self.messages_</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.set_var"><code class="name flex">
<span>def <span class="ident">set_var</span></span>(<span>self, name, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_var(self, name, value):
    self.variables[name] = value</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.submit"><code class="name flex">
<span>def <span class="ident">submit</span></span>(<span>self,<br>expr: <a title="sglang.lang.ir.SglExpr" href="ir.html#sglang.lang.ir.SglExpr">SglExpr</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def submit(self, expr: SglExpr):
    self._init_var_event(expr)

    if self.use_thread:
        self.queue.put(expr)
    else:
        self._execute(expr)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.sync"><code class="name flex">
<span>def <span class="ident">sync</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync(self):
    if self.use_thread:
        self.queue.join()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="sglang.lang.interpreter.StreamExecutor.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def text(self):
    self.sync()
    return self.text_</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sglang.lang" href="index.html">sglang.lang</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sglang.lang.interpreter.cache_program" href="#sglang.lang.interpreter.cache_program">cache_program</a></code></li>
<li><code><a title="sglang.lang.interpreter.run_internal" href="#sglang.lang.interpreter.run_internal">run_internal</a></code></li>
<li><code><a title="sglang.lang.interpreter.run_program" href="#sglang.lang.interpreter.run_program">run_program</a></code></li>
<li><code><a title="sglang.lang.interpreter.run_program_batch" href="#sglang.lang.interpreter.run_program_batch">run_program_batch</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sglang.lang.interpreter.ProgramState" href="#sglang.lang.interpreter.ProgramState">ProgramState</a></code></h4>
<ul class="two-column">
<li><code><a title="sglang.lang.interpreter.ProgramState.assistant" href="#sglang.lang.interpreter.ProgramState.assistant">assistant</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.copy" href="#sglang.lang.interpreter.ProgramState.copy">copy</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.error" href="#sglang.lang.interpreter.ProgramState.error">error</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.fork" href="#sglang.lang.interpreter.ProgramState.fork">fork</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.get_meta_info" href="#sglang.lang.interpreter.ProgramState.get_meta_info">get_meta_info</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.get_var" href="#sglang.lang.interpreter.ProgramState.get_var">get_var</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.messages" href="#sglang.lang.interpreter.ProgramState.messages">messages</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.set_var" href="#sglang.lang.interpreter.ProgramState.set_var">set_var</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.sync" href="#sglang.lang.interpreter.ProgramState.sync">sync</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.system" href="#sglang.lang.interpreter.ProgramState.system">system</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.text" href="#sglang.lang.interpreter.ProgramState.text">text</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.text_async_iter" href="#sglang.lang.interpreter.ProgramState.text_async_iter">text_async_iter</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.text_iter" href="#sglang.lang.interpreter.ProgramState.text_iter">text_iter</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.user" href="#sglang.lang.interpreter.ProgramState.user">user</a></code></li>
<li><code><a title="sglang.lang.interpreter.ProgramState.var_scope" href="#sglang.lang.interpreter.ProgramState.var_scope">var_scope</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.lang.interpreter.ProgramStateGroup" href="#sglang.lang.interpreter.ProgramStateGroup">ProgramStateGroup</a></code></h4>
<ul class="">
<li><code><a title="sglang.lang.interpreter.ProgramStateGroup.join" href="#sglang.lang.interpreter.ProgramStateGroup.join">join</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sglang.lang.interpreter.StreamExecutor" href="#sglang.lang.interpreter.StreamExecutor">StreamExecutor</a></code></h4>
<ul class="two-column">
<li><code><a title="sglang.lang.interpreter.StreamExecutor.end" href="#sglang.lang.interpreter.StreamExecutor.end">end</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.error" href="#sglang.lang.interpreter.StreamExecutor.error">error</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.fork" href="#sglang.lang.interpreter.StreamExecutor.fork">fork</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.get_meta_info" href="#sglang.lang.interpreter.StreamExecutor.get_meta_info">get_meta_info</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.get_var" href="#sglang.lang.interpreter.StreamExecutor.get_var">get_var</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.messages" href="#sglang.lang.interpreter.StreamExecutor.messages">messages</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.set_var" href="#sglang.lang.interpreter.StreamExecutor.set_var">set_var</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.submit" href="#sglang.lang.interpreter.StreamExecutor.submit">submit</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.sync" href="#sglang.lang.interpreter.StreamExecutor.sync">sync</a></code></li>
<li><code><a title="sglang.lang.interpreter.StreamExecutor.text" href="#sglang.lang.interpreter.StreamExecutor.text">text</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
